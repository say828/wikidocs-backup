## 02. MongoDB 아키텍처 조감도: Standalone, Replica Set, Sharded Cluster

MongoDB의 도큐먼트 모델이 '무엇을' 저장하는지에 대한 이야기였다면, 아키텍처는 '어떻게' 그 데이터를 안정적이고 확장 가능한 방식으로 운영하는지에 대한 청사진입니다. MongoDB는 개발자의 로컬 머신에서부터 수백 대의 서버로 구성된 글로벌 서비스에 이르기까지, 다양한 요구사항에 대응할 수 있는 세 가지 핵심 아키텍처를 제공합니다.

### 1. Standalone

Standalone은 이름 그대로 단일 `mongod` 프로세스가 하나의 서버에서 실행되는 가장 단순한 구성입니다.

* **구조:** 서버 한 대에 MongoDB 인스턴스 하나.
* **목적:** 주로 개발, 학습, 또는 소규모 테스트 용도로 사용됩니다. MongoDB의 기본 기능을 익히고 애플리케이션의 초기 프로토타입을 만드는 데는 더없이 편리합니다.
* **한계:** 이 방식은 **절대로 프로덕션 환경에서 사용해서는 안 됩니다.** 서버에 하드웨어 장애가 발생하거나 `mongod` 프로세스가 중단되면 데이터베이스는 즉시 다운되고, 이는 곧 서비스 전체의 중단으로 이어집니다. 가용성이나 데이터 이중화가 전혀 보장되지 않는 **단일 장애점(Single Point of Failure)** 구조이기 때문입니다.
* **비유:** 동네에 하나뿐인 작은 편의점과 같습니다. 가깝고 이용하기 편리하지만, 주인이 문을 닫으면 이용할 방법이 없습니다.

### 2. Replica Set (레플리카 셋)

프로덕션 환경의 가장 기본이자 표준이 되는 아키텍처입니다. Replica Set은 데이터를 여러 서버에 복제하여 고가용성(High Availability)과 데이터 이중화(Redundancy)를 보장합니다.

* **구조:** 일반적으로 세 대 이상의 서버로 구성되며, 하나의 **프라이머리(Primary)** 멤버와 여러 개의 **세컨더리(Secondary)** 멤버로 이루어집니다.
* **동작 원리:**
    1.  모든 쓰기(Create, Update, Delete) 연산은 오직 프라이머리 멤버를 통해서만 이루어집니다.
    2.  프라이머리는 데이터 변경이 발생하면, 이 변경 기록(oplog)을 모든 세컨더리 멤버에게 전송하여 복제합니다.
    3.  이를 통해 모든 멤버는 거의 실시간으로 동일한 데이터를 유지하게 됩니다.
    4.  만약 프라이머리 서버에 장애가 발생하면, 남아있는 세컨더리 멤버들이 투표(Election)를 통해 새로운 프라이머리를 자동으로 선출합니다. 이 과정을 **페일오버(Failover)**라 하며, 수 초에서 수십 초 내에 완료되어 서비스 중단을 최소화합니다.
* **목적:** 장애 상황에서도 데이터베이스 서비스를 중단 없이 운영하기 위함입니다. 또한, 읽기 연산을 세컨더리 멤버로 분산시켜 프라이머리의 부하를 줄이는 용도로도 활용할 수 있습니다.
* **비유:** 본점과 여러 지점을 둔 프랜차이즈 식당과 같습니다. 모든 신메뉴 개발(쓰기)은 본점(프라이머리)에서 이루어지지만, 그 레시피는 모든 지점(세컨더리)에 즉시 공유됩니다. 본점에 불이 나더라도, 다른 지점 중 하나가 즉시 본점 역할을 이어받아 영업을 계속할 수 있습니다.

### 3. Sharded Cluster (샤드 클러스터)

데이터의 양이나 트래픽이 단일 Replica Set으로 감당할 수 없을 만큼 거대해졌을 때, MongoDB는 Sharded Cluster를 통해 **수평적 확장(Horizontal Scaling)**의 길을 제시합니다.

* **구조:** 여러 개의 **샤드(Shard)**로 데이터를 분산 저장하는 구조입니다. 각 샤드는 그 자체로 하나의 독립적인 **Replica Set**으로 구성되어, 샤드 클러스터는 고가용성과 수평적 확장을 동시에 달성합니다. 이 클러스터는 세 가지 핵심 컴포넌트로 이루어집니다.
    1.  **Shards (샤드):** 데이터의 일부를 실제로 저장하는 단위입니다. 앞서 말했듯, 각 샤드는 고가용성을 위해 Replica Set으로 구성됩니다.
    2.  **mongos (쿼리 라우터):** 애플리케이션은 데이터베이스에 직접 연결하는 대신 `mongos`라는 라우팅 프로세스에 연결합니다. `mongos`는 쿼리를 받아서 어떤 샤드에 해당 데이터가 있는지 판단하고, 요청을 해당 샤드로 전달하는 역할을 합니다. 클라이언트에게 샤딩의 복잡성을 숨겨주는 투명한 게이트웨이입니다.
    3.  **Config Servers (설정 서버):** 클러스터의 메타데이터, 즉 데이터가 어떤 기준으로 나뉘어 어느 샤드에 저장되어 있는지에 대한 '지도'를 저장합니다. `mongos`는 이 지도를 참조하여 쿼리를 라우팅합니다. 설정 서버 자체의 가용성을 위해 이 역시 Replica Set으로 구성됩니다.
* **목적:** 단일 서버의 물리적 한계를 넘어, 수십억 건의 도큐먼트와 초당 수십만 건의 요청을 처리하기 위한 대규모 분산 데이터베이스 환경을 구축하는 것입니다.
* **비유:** 거대한 국립 도서관 시스템에 비유할 수 있습니다. 책이 너무 많아 한 건물에 다 보관할 수 없게 되자, 'A-L' 저자의 책은 강남 분관(샤드 1)에, 'M-Z' 저자의 책은 판교 분관(샤드 2)에 나누어 보관합니다. 이용자는 중앙 안내 데스크(`mongos`)에 책을 문의하면, 안내원은 전체 도서 목록(설정 서버)을 보고 어떤 분관으로 가야 할지 알려줍니다.

이 세 가지 아키텍처는 MongoDB를 단순한 데이터 저장소에서, 장애를 스스로 극복하고 무한히 확장할 수 있는 강력한 데이터 플랫폼으로 만들어주는 핵심 요소입니다. 이 책의 후반부에서는 Replica Set과 Sharded Cluster의 내부 동작 원리와 운영 전략에 대해 훨씬 더 깊이 있게 다룰 것입니다.