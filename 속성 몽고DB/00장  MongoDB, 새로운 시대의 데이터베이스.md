# 00장: MongoDB, 새로운 시대의 데이터베이스

## 00. 관계형 데이터베이스의 한계와 NoSQL의 등장

지난 수십 년간 데이터베이스의 세계는 관계형 데이터베이스 관리 시스템(RDBMS)이 지배해왔습니다. Oracle, MySQL, PostgreSQL과 같은 RDBMS는 트랜잭션의 정합성을 보장하는 ACID(원자성, 일관성, 고립성, 지속성) 원칙과 정규화를 통해 데이터 중복을 최소화하는 강력한 모델을 기반으로, 금융, 전사적 자원 관리(ERP) 등 안정성과 일관성이 최우선인 시스템의 심장 역할을 해왔습니다. 구조화된 질의 언어인 SQL은 데이터를 조작하고 질의하는 표준으로 자리 잡았으며, 오늘날까지도 그 영향력은 막강합니다.

그러나 21세기에 들어서면서 데이터의 패러다임은 근본적으로 변화하기 시작했습니다. 인터넷의 폭발적인 성장, 소셜 미디어의 등장, 그리고 사물 인터넷(IoT)의 확산은 과거와 비교할 수 없는 규모와 속도, 그리고 다양성을 지닌 데이터를 만들어냈습니다. 우리는 이른바 '빅데이터'의 시대에 살게 된 것입니다. 이러한 변화의 물결 속에서, 견고했던 RDBMS의 아키텍처는 세 가지 주요한 도전에 직면하게 됩니다.

1.  **수평적 확장의 어려움 (The Challenge of Horizontal Scaling)**
    RDBMS는 전통적으로 **수직적 확장(Scale-up)**, 즉 더 강력한 CPU, 더 많은 메모리를 추가하는 방식으로 성능을 높이는 데 최적화되어 있습니다. 하지만 데이터가 기하급수적으로 증가하는 환경에서 서버 한 대의 성능을 높이는 것만으로는 한계가 명확합니다. 대안은 여러 서버에 데이터를 분산하여 처리하는 **수평적 확장(Scale-out)**이지만, 관계(Relation)와 조인(`JOIN`) 연산에 깊이 의존하는 RDBMS의 특성상 수평적 확장은 매우 복잡하고 비용이 많이 드는 작업이었습니다. 샤딩(Sharding)과 같은 기법이 존재하지만, 이를 구현하고 유지하는 것은 애플리케이션과 데이터베이스 관리 양쪽에 큰 부담을 안겨주었습니다.

2.  **엄격한 스키마의 족쇄 (The Shackle of a Rigid Schema)**
    RDBMS는 '쓰기 시 스키마(Schema-on-write)' 모델을 따릅니다. 데이터를 저장하기 전에 테이블의 구조, 즉 스키마를 명확하게 정의해야 합니다. 이는 데이터의 무결성을 보장하는 강력한 장점이지만, 하루에도 몇 번씩 배포가 이루어지는 현대의 애자일(Agile) 및 데브옵스(DevOps) 개발 환경에서는 큰 제약이 되었습니다. 비즈니스 요구사항 변화로 필드 하나를 추가하거나 변경하기 위해 `ALTER TABLE` 명령을 실행하면, 수억 건의 데이터가 저장된 테이블 전체에 락(Lock)이 걸려 서비스 장애로 이어질 수 있었습니다.

3.  **객체-관계 불일치 (Object-Relational Impedance Mismatch)**
    현대 애플리케이션은 대부분 객체 지향 언어(Java, Python, TypeScript 등)로 개발됩니다. 개발자는 '사용자'라는 객체를 `user.name`, `user.address.city` 와 같이 자연스러운 계층 구조로 다루지만, 이를 RDBMS에 저장하려면 정규화 원칙에 따라 `users`, `addresses`, `cities` 등 여러 테이블로 분해해야 합니다. 데이터를 다시 읽어올 때는 복잡한 `JOIN` 연산을 통해 이 테이블들을 재조합해야 하죠. 이처럼 애플리케이션의 객체 모델과 RDBMS의 관계 모델 간의 근본적인 불일치는 개발 생산성을 저해하고 불필요한 복잡성을 야기했습니다.

이러한 RDBMS의 한계를 극복하기 위한 대안으로 **NoSQL(Not Only SQL)** 데이터베이스가 등장했습니다. NoSQL은 단일 기술이 아닌, 유연한 스키마, 수평적 확장성, 그리고 다양한 데이터 모델을 특징으로 하는 데이터베이스 시스템들을 총칭하는 용어입니다. NoSQL 데이터베이스는 크게 네 가지 범주로 나뉩니다.

* **키-값(Key-Value) 데이터베이스:** Redis, Riak (단순한 키와 값의 쌍으로 데이터를 저장, 캐싱에 주로 사용)
* **컬럼 패밀리(Column-Family) 데이터베이스:** Cassandra, HBase (행마다 다른 스키마를 가질 수 있어 대규모 쓰기에 유리)
* **그래프(Graph) 데이터베이스:** Neo4j (데이터 간의 관계를 모델링하는 데 특화, 소셜 네트워크나 추천 엔진에 사용)
* **도큐먼트(Document) 데이터베이스:** **MongoDB**, Couchbase

이 책의 주인공인 MongoDB는 바로 이 **도큐먼트 데이터베이스**의 대표주자입니다. 도큐먼트 데이터베이스는 데이터를 애플리케이션 개발자가 가장 친숙하게 느끼는 JSON(JavaScript Object Notation)과 유사한 형식(MongoDB의 경우 BSON)으로 저장합니다. 이는 '객체-관계 불일치' 문제를 근본적으로 해결하며, 유연한 스키마를 통해 빠르게 변화하는 비즈니스 요구사항에 민첩하게 대응할 수 있는 힘을 제공합니다.

다음 절에서는 MongoDB가 채택한 도큐먼트 모델의 철학이 어떻게 데이터와 애플리케이션의 간극을 메우고 개발의 패러다임을 바꾸었는지 더 깊이 탐구해 보겠습니다.