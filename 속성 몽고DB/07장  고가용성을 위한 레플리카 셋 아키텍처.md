# 07장: 고가용성을 위한 레플리카 셋 아키텍처

이전 6장에서 우리는 데이터와 트래픽이 폭증하는 상황에 대응하여 시스템을 수평적으로 확장하는 **샤딩(Sharding)**에 대해 깊이 있게 탐구했습니다. 이제 현대적인 데이터베이스 시스템의 또 다른 핵심 축인 **고가용성(High Availability)**과 **장애 감내(Fault Tolerance)**에 대해 이야기할 차례입니다. "만약 지금 운영 중인 데이터베이스 서버에 갑자기 장애가 발생한다면?" 이라는 모든 아키텍트의 근본적인 고민에 대해, MongoDB는 **레플리카 셋(Replica Set)**이라는 강력하고 자동화된 해답을 제시합니다.

이번 장에서는 데이터의 중복성과 서비스의 연속성을 보장하는 레플리카 셋의 핵심 원리를 파헤치고, 자동 장애 복구(Failover)의 심장인 선거(Election) 과정부터, 분산 시스템에서 발생할 수 있는 복제 지연(Replication Lag) 문제의 원인과 영향까지 심도 있게 분석합니다.

---

## 00. 데이터 복제(Replication)의 원리와 목적

**복제(Replication)**란 동일한 데이터를 여러 서버에 걸쳐 동기화하여, 여러 개의 복사본을 유지하는 프로세스입니다. MongoDB의 레플리카 셋은 이 복제 원리를 기반으로 구축되었으며, 그 목적은 크게 두 가지입니다.

1.  **데이터 이중화 (Data Redundancy):** 하드웨어 장애나 데이터 유실 사고로부터 데이터를 안전하게 보호합니다.
2.  **고가용성 (High Availability):** 일부 서버에 장애가 발생하더라도, 데이터베이스 시스템 전체가 중단 없이 서비스를 계속할 수 있도록 보장합니다.

### 데이터 복제의 원리: 프라이머리와 Oplog

레플리카 셋은 하나의 **프라이머리(Primary)** 노드와 하나 이상의 **세컨더리(Secondary)** 노드로 구성됩니다.

* **프라이머리(Primary):** 레플리카 셋 내에서 단 하나만 존재하며, 모든 쓰기(create, update, delete) 요청을 독점적으로 처리하는 노드입니다.
* **세컨더리(Secondary):** 프라이머리로부터 데이터 변경 사항을 지속적으로 복제받아 자신의 데이터셋을 동기화하는 노드입니다.

이들 간의 데이터 복제는 **Oplog(Operations Log)**라는 특별한 메커니즘을 통해 이루어집니다.

**Oplog**는 프라이머리 노드에서 발생하는 모든 데이터 변경 작업을 기록하는 일종의 항해 일지 또는 블랙박스와 같습니다. 이 로그는 `oplog.rs`라는 Capped Collection(크기가 고정된 특수 컬렉션)에 저장되며, 각 로그 항목은 멱등성(idempotent)을 가집니다. 즉, 동일한 로그를 여러 번 적용해도 결과는 항상 동일하게 유지됩니다.

**복제 과정은 다음과 같습니다.**

1.  애플리케이션이 프라이머리 노드에 쓰기 작업을 요청합니다.
2.  프라이머리는 자신의 데이터 파일을 변경한 뒤, 해당 작업에 대한 기록(oplog entry)을 자신의 **Oplog**에 순서대로 기록합니다.
3.  세컨더리 노드들은 주기적으로 프라이머리의 Oplog을 확인합니다.
4.  각 세컨더리는 자신이 마지막으로 복제한 Oplog 항목 이후에 새로 기록된 항목들을 프라이머리에게 요청합니다.
5.  프라이머리로부터 새로운 Oplog 항목들을 전달받은 세컨더리는, 그 항목들을 자신에게 순서대로 재현(apply)하여 데이터를 동기화합니다.

이 과정은 기본적으로 **비동기(asynchronous)**로 이루어지므로, 프라이머리에 쓰기가 발생한 시점과 세컨더리에 해당 내용이 반영되는 시점 사이에는 약간의 시간 차이, 즉 **복제 지연(Replication Lag)**이 존재할 수 있습니다.

### 복제의 목적

이러한 복제 메커니즘을 통해 MongoDB는 다음과 같은 핵심적인 가치를 제공합니다.

#### 1. 데이터 이중화 (Data Redundancy)
여러 대의 서버에 동일한 데이터 복사본을 유지함으로써, 단일 서버의 장애가 전체 데이터 유실로 이어지는 것을 방지합니다. 프라이머리 노드의 디스크가 손상되거나 서버 자체가 파괴되는 최악의 상황이 발생하더라도, 세컨더리 노드에 데이터가 온전히 보존되어 있으므로 시스템을 복구할 수 있습니다.

#### 2. 고가용성 (High Availability)
이는 단순히 데이터를 보존하는 것을 넘어, **서비스의 중단 시간을 최소화**하는 것에 초점을 맞춥니다. 만약 프라이머리 노드가 네트워크 문제나 하드웨어 장애로 인해 응답하지 않으면, 레플리카 셋은 이 상황을 자동으로 감지합니다. 그리고 남아있는 세컨더리 노드들 사이에서 투표를 통해 새로운 프라이머리를 선출하여 쓰기 작업을 즉시 인계받도록 합니다. 이 자동 장애 복구(Automatic Failover) 과정 덕분에, 관리자의 수동 개입 없이도 수십 초 내에 서비스가 정상화될 수 있습니다. 비행기의 주 조종사(프라이머리)에게 문제가 생겼을 때 부조종사(세컨더리)가 즉시 조종간을 이어받는 것과 같습니다.

#### 3. 읽기 확장성 (Read Scalability)
애플리케이션의 읽기 요청을 세컨더리 노드로 분산시켜 프라이머리의 부하를 줄이는 용도로도 활용될 수 있습니다. 이를 통해 전체 시스템의 읽기 처리량을 향상시킬 수 있습니다. 단, 복제 지연으로 인해 세컨더리에서 약간 오래된(stale) 데이터를 읽을 수 있다는 점을 감안해야 합니다.

결론적으로, 복제는 MongoDB가 단일 장애점(Single Point of Failure)을 제거하고, 24시간 365일 안정적으로 운영되어야 하는 현대적인 미션 크리티컬 애플리케이션의 데이터베이스로 자리매김할 수 있게 하는 핵심 기반 기술입니다. 다음 절에서는 고가용성의 심장인 자동 장애 복구와 선거 과정에 대해 더 자세히 알아보겠습니다.