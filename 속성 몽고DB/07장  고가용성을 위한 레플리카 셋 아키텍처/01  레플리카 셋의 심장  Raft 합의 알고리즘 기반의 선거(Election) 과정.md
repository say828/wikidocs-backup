## 01. 레플리카 셋의 심장: Raft 합의 알고리즘 기반의 선거(Election) 과정

레플리카 셋의 고가용성을 보장하는 핵심은 프라이머리 노드에 장애가 발생했을 때, 사람의 개입 없이도 남아있는 세컨더리 노드들이 자율적으로 새로운 리더를 선출하는 **자동 장애 복구(Automatic Failover)** 메커니즘입니다. 이 민주적인 절차를 **선거(Election)**라고 부릅니다.

최신 버전의 MongoDB(3.2 이상)는 분산 시스템에서 리더를 선출하는 가장 안정적이고 널리 검증된 방식 중 하나인 **Raft 합의 알고리즘(Raft Consensus Algorithm)**에 기반한 선거 프로토콜을 사용합니다.

---

### 선거는 언제 발생하는가?

선거는 다음과 같은 상황에서 촉발됩니다.

1.  **프라이머리 도달 불가능 (Primary Unreachable):** 가장 일반적인 경우입니다. 세컨더리 노드가 일정 시간(기본 10초) 동안 프라이머리로부터 하트비트(heartbeat) 신호를 받지 못하면, 프라이머리가 다운되었다고 간주하고 새로운 선거를 시작합니다.
2.  **관리자에 의한 강제 선거:** 관리자가 `rs.stepDown()`과 같은 명령어를 사용하여 현재 프라이머리를 강제로 세컨더리로 전환시킬 때 발생합니다. 이는 보통 하드웨어 업그레이드와 같은 계획된 유지보수 작업 시 사용됩니다.
3.  **레플리카 셋 초기화:** `rs.initiate()` 명령으로 레플리카 셋을 처음 구성할 때, 멤버들은 첫 번째 프라이머리를 선출하기 위해 선거를 치릅니다.

---

### 선거 과정의 내부 동작

Raft 알고리즘에 기반한 선거 과정은 체계적인 단계에 따라 진행됩니다.

#### 하트비트 (Heartbeat) - 서로의 생존 신호

레플리카 셋의 모든 멤버들은 기본적으로 2초마다 서로에게 아주 작은 핑(ping)과 같은 **하트비트** 신호를 보냅니다. 이를 통해 서로의 상태를 지속적으로 감시하며, 프라이머리가 살아있는지 확인할 수 있습니다.

**1단계: 후보자 등장 (Candidate Emerges)**
프라이머리가 다운되었다고 판단한 세컨더리는, 스스로를 차기 리더 후보(Candidate)로 선언합니다. 이 노드는 자신의 '임기(term)' 번호를 1 증가시켜, 이번 선거가 이전 선거와는 다른 새로운 선거임을 알립니다. 그리고 다른 모든 멤버들에게 자신에게 투표해달라는 `requestVote` 메시지를 보냅니다.

**2단계: 투표 (The Voting)**
`requestVote` 메시지를 받은 다른 멤버들은 다음 조건들을 확인하고 투표 여부를 결정합니다.

* **최신 데이터 보유 여부:** 투표자는 후보자의 데이터가 자신보다 뒤처져 있지 않은지 확인합니다. 즉, 후보자의 Oplog이 최소한 자신만큼은 최신 상태여야 합니다. **만약 후보자의 데이터가 더 오래되었다면, 절대로 투표하지 않습니다.** 이는 가장 최신 쓰기 작업을 유실한 노드가 프라이머리가 되는 끔찍한 상황을 방지하기 위함입니다.
* **이번 임기(term)에 이미 투표했는가:** 각 멤버는 하나의 임기에 단 한 번만 투표할 수 있습니다.

이 조건들을 통과하면, 멤버는 후보자에게 "찬성" 표를 던집니다.

**3단계: 당선과 새로운 리더의 탄생 (Winning the Election)**
후보자는 자신을 포함한 멤버들로부터 받은 표를 집계합니다. 새로운 프라이머리가 되기 위해서는, 레플리카 셋의 **투표 가능 멤버(voting members) 중 과반수의 찬성**을 얻어야 합니다.

* 3대 구성의 레플리카 셋: 2표 필요
* 5대 구성의 레플리카 셋: 3표 필요

이것이 바로 레플리카 셋의 멤버 수를 **홀수**로 구성하는 것이 강력하게 권장되는 이유입니다. 만약 멤버가 4명이라면, 2 대 2로 표가 나뉘는 교착 상태(split-brain)에 빠져 아무도 리더로 선출되지 못하고 서비스 장애가 길어질 수 있습니다.

과반수 득표에 성공한 후보는 즉시 새로운 프라이머리로 승격되어 쓰기 작업을 받기 시작하고, 다른 멤버들에게 하트비트를 보내 자신의 리더십을 알립니다.

**4단계: 새로운 질서의 확립 (The New Order)**
다른 멤버들은 새로운 임기 번호를 가진 새 프라이머리의 등장을 인지하고, 그를 리더로 인정합니다. 선거에서 패배한 다른 후보자들은 다시 세컨더리 상태로 돌아가, 새로운 프라이머리로부터 데이터를 복제하기 시작합니다. 나중에 기존의 프라이머리가 다시 온라인 상태가 되더라도, 자신보다 높은 임기 번호를 가진 새로운 리더를 발견하고 스스로 세컨더리로 강등됩니다.

---

### Arbiter: 투표권만 가진 중재자

**아비터(Arbiter)**는 데이터를 저장하지 않고 오직 **선거에만 참여**하여 투표권만 행사하는 특별한 `mongod` 프로세스입니다.

* **용도:** 데이터 저장용 서버를 추가하는 비용 없이, 투표 멤버 수를 홀수로 맞추기 위해 사용됩니다. 예를 들어, 프라이머리-세컨더리의 2대 구성에 아비터를 추가하여 3개의 투표권을 만들면, 둘 중 하나에 장애가 발생해도 남은 하나가 아비터의 표를 얻어 과반수를 확보하고 리더가 될 수 있습니다.
* **주의:** 아비터는 데이터 복사본을 가지고 있지 않으므로, 데이터 이중화에는 전혀 기여하지 못합니다. 따라서 가능하면 데이터를 저장하는 노드 3대로 레플리카 셋을 구성하는 것이 항상 최선입니다.

이러한 선거 과정은 MongoDB 고가용성 아키텍처의 심장 박동과 같습니다. 이 자동화되고 안정적인 합의 메커니즘 덕분에, MongoDB는 서버 장애에 스스로를 치유하며 24시간 중단 없는 서비스를 제공할 수 있습니다.