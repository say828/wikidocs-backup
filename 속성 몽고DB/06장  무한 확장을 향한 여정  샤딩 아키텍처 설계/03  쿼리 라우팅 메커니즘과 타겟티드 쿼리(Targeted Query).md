## 03. 쿼리 라우팅 메커니즘과 타겟티드 쿼리(Targeted Query)

샤드 클러스터의 애플리케이션은 샤드에 직접 연결하지 않고 항상 `mongos`를 통해 통신합니다. 그렇다면 `mongos`는 어떻게 수많은 샤드 중에서 쿼리가 가야 할 정확한 위치를 알고 찾아가는 것일까요? 이 과정이 바로 **쿼리 라우팅**이며, 그 효율성은 샤드 키와 쿼리의 구조에 의해 결정됩니다.

---

### `mongos`의 역할과 메타데이터 캐싱

`mongos`가 쿼리 라우터로서 동작하는 핵심 원리는 **설정 서버(Config Server)의 메타데이터**에 있습니다.

1.  `mongos` 프로세스가 시작되면, 가장 먼저 설정 서버 레플리카 셋에 연결합니다.
2.  설정 서버로부터 클러스터의 전체 메타데이터, 즉 어떤 데이터 조각(Chunk)이 어느 샤드에 분포해 있는지에 대한 **라우팅 테이블**(일종의 지도)을 가져옵니다.
3.  `mongos`는 이 라우팅 테이블을 **자신의 메모리에 캐시(cache)**합니다.

이 **캐싱 메커니즘**은 샤드 클러스터의 성능에 매우 중요합니다. 만약 `mongos`가 모든 쿼리마다 설정 서버에게 길을 물어봐야 한다면, 설정 서버는 엄청난 병목 지점이 될 것이고 쿼리 지연 시간은 급증할 것입니다. `mongos`는 캐시된 라우팅 테이블을 통해 대부분의 쿼리를 자체적으로, 그리고 즉각적으로 라우팅할 수 있습니다.

물론 이 캐시는 영구적이지 않습니다. 클러스터의 밸런서가 청크를 다른 샤드로 이동시키는 등 메타데이터에 변경이 생기면, `mongos`는 주기적으로 또는 필요에 따라 캐시를 업데이트하여 최신 상태를 유지합니다.

---

### 쿼리 라우팅의 두 가지 경로: Targeted vs. Scatter-Gather

`mongos`가 쿼리를 받았을 때, 이 쿼리를 처리하는 방식은 크게 두 가지로 나뉩니다.

#### 1. 타겟티드 쿼리 (Targeted Query) - 최적의 경로 🚀

**타겟티드 쿼리**는 `mongos`가 쿼리를 **단 하나의 특정 샤드**로 보낼 수 있는 가장 이상적인 경우입니다.

* **조건:** 쿼리의 필터(filter) 조건에 **샤드 키가 반드시 포함**되어야 합니다.
* **`mongos`의 동작:**
    1.  `orders` 컬렉션이 `customerId`로 샤딩되어 있다고 가정합니다.
    2.  `mongos`가 `db.orders.find({ customerId: "user456", status: "SHIPPED" })` 라는 쿼리를 받습니다.
    3.  쿼리에 샤드 키인 `customerId`가 포함되어 있으므로, `mongos`는 자신의 캐시된 라우팅 테이블을 봅니다.
    4.  라우팅 테이블에는 `customerId` "user456"이 포함된 청크가 **샤드 B**에 있다는 정보가 기록되어 있습니다.
    5.  `mongos`는 다른 샤드에는 전혀 요청을 보내지 않고, 오직 **샤드 B**에게만 이 쿼리를 전달합니다.
* **결과:** 단일 샤드 내에서만 작업이 이루어지므로 매우 빠르고 효율적이며, 클러스터 전체에 주는 부하가 최소화됩니다. **성공적인 샤딩 아키텍처는 가장 빈번하고 중요한 쿼리들을 타겟티드 쿼리로 만드는 것을 목표로 합니다.**

#### 2. 스캐터-개더 쿼리 (Scatter-Gather Query) - 불가피한 경로 🐌

**스캐터-개더 쿼리**는 `mongos`가 쿼리를 특정 샤드로 좁히지 못하고, **여러 샤드(최악의 경우 모든 샤드)**에 흩뿌려야(scatter) 하는 경우입니다.

* **조건:** 쿼리의 필터 조건에 **샤드 키가 포함되어 있지 않을 때** 발생합니다.
* **`mongos`의 동작:**
    1.  `orders` 컬렉션이 `customerId`로 샤딩된 동일한 상황에서, `mongos`가 `db.orders.find({ orderDate: { $gt: ISODate("2025-10-01T00:00:00Z") } })` 라는 쿼리를 받습니다.
    2.  쿼리에 샤드 키인 `customerId`가 없으므로, `mongos`는 특정 날짜의 주문이 어느 샤드에 있는지 알 방법이 없습니다.
    3.  `mongos`는 이 쿼리를 클러스터 내의 **모든 샤드**에게 병렬로 전송합니다(Scatter 단계).
    4.  각 샤드는 자신이 가진 데이터 내에서 이 쿼리를 실행하고, 결과를 `mongos`에게 반환합니다.
    5.  `mongos`는 모든 샤드로부터 응답이 올 때까지 기다린 후, 받은 결과들을 하나로 취합하고(Gather 단계) 정렬/제한(sort/limit) 등의 후처리를 거쳐 최종 결과를 애플리케이션에 반환합니다.
* **결과:** 클러스터의 모든 샤드에 부하를 주고, 네트워크 트래픽을 증가시키며, `mongos`의 추가적인 병합 작업까지 필요하므로 타겟티드 쿼리에 비해 훨씬 느리고 비쌉니다. 간헐적인 분석 쿼리로는 허용될 수 있지만, 애플리케이션의 핵심 경로에서 스캐터-개더 쿼리가 빈번하게 발생한다면 이는 샤드 키 설계가 잘못되었다는 강력한 신호입니다.

#### 업데이트와 Find-and-Modify

* `updateOne`, `updateMany` 같은 업데이트 쿼리 역시 필터 조건에 샤드 키가 포함되면 타겟티드 업데이트가 되지만, 샤드 키가 없으면 스캐터-개더 업데이트가 됩니다.
* `findOneAndUpdate`와 같은 원자적인 Find-and-Modify 계열의 쿼리는 반드시 필터 조건에 **샤드 키를 포함해야만** 실행할 수 있도록 MongoDB가 강제합니다.

결론적으로, `mongos`의 라우팅 메커니즘을 이해하는 것은 샤드 키 선정 원칙의 '이유'를 깨닫는 과정입니다. 훌륭한 아키텍트는 애플리케이션의 쿼리 패턴을 분석하여, 시스템의 핵심 기능들이 가장 빠른 길, 즉 타겟티드 쿼리의 경로를 타도록 샤드 키를 설계해야 합니다.