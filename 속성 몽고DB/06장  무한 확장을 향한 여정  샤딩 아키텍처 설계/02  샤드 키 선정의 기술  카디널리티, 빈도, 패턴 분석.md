## 02. 샤드 키 선정의 기술: 카디널리티, 빈도, 패턴 분석

샤드 클러스터의 구성 요소를 이해했다면, 이제 아키텍처의 성패를 좌우하는 가장 중대한 결정, **샤드 키(Shard Key)** 선정에 대해 알아볼 차례입니다. 샤드 키는 MongoDB가 도큐먼트를 어떤 샤드에 저장할지 결정하는 기준이 되는, 모든 도큐먼트에 존재하는 하나 이상의 필드입니다.

훌륭한 샤드 키는 클러스터 전반에 데이터를 균등하게 분산시켜 선형적인 성능 확장을 보장하는 반면, 잘못 선택된 샤드 키는 오히려 샤딩을 하지 않는 것보다 못한 최악의 성능 병목을 유발할 수 있습니다. 한번 결정된 샤드 키는 변경이 거의 불가능하기 때문에, 최초 설계 단계에서 심층적인 분석과 고민이 반드시 필요합니다.

---

### 좋은 샤드 키의 3대 요건

이상적인 샤드 키는 다음 세 가지 특성을 모두 만족해야 합니다.

#### 1. 높은 카디널리티 (High Cardinality): 쓰기 부하 분산 ⚖️

**카디널리티**란 샤드 키가 가질 수 있는 고유한 값의 개수를 의미합니다. 카디널리티가 높을수록 MongoDB는 데이터를 더 잘게 쪼개어 여러 샤드에 균등하게 분산시킬 수 있습니다.

* **좋은 예:** `userId`, `email`, `orderId` 등 거의 모든 값이 고유한 필드. 수백만 개의 고유한 키 값이 존재하므로, 새로운 쓰기 작업이 여러 샤드로 골고루 분산될 가능성이 매우 높습니다.

* **나쁜 예:** `country` 필드. 만약 서비스 사용자의 80%가 특정 국가(예: 대한민국)에 집중되어 있다면, `country`를 샤드 키로 사용할 경우 전체 쓰기 작업의 80%가 '대한민국' 키 값 범위를 담당하는 단 하나의 샤드로만 몰리게 됩니다. 다른 샤드들은 거의 일을 하지 않는데 특정 샤드만 과부하에 걸리는 **핫스팟(Hotspot)** 이 발생하여 샤딩의 의미가 없어집니다.

#### 2. 균일한 접근 빈도 (Evenly Distributed Access): 핫스팟 방지 📉

높은 카디널리티를 가졌더라도, 특정 키 값에 대한 접근(읽기/쓰기)이 비정상적으로 집중된다면 이 또한 핫스팟을 유발할 수 있습니다.

* **상황:** 이커머스 사이트에서 `productId`를 샤드 키로 사용한다고 가정해 봅시다. `productId`는 카디널리티가 매우 높으므로 좋은 키처럼 보입니다. 하지만 블랙프라이데이에 특정 인기 상품 하나에 대한 대규모 타임 세일을 진행한다면 어떻게 될까요? 해당 `productId`에 대한 조회 및 주문 요청이 폭주하면서, 이 상품 데이터를 담당하는 단 하나의 샤드에 모든 부하가 집중되어 장애를 일으킬 것입니다.

* **해결책:** 데이터 접근 패턴을 예측하여, 특정 값에 대한 집중 현상이 발생할 가능성이 적은 키를 선택해야 합니다. 예를 들어 `userId`는 특정 슈퍼 유저가 존재할 수 있지만, `productId`보다는 일반적으로 접근 빈도가 훨씬 균일합니다.

#### 3. 쿼리 패턴과의 일치 (Query Isolation): 읽기 성능 최적화 🎯

가장 이상적인 쿼리는 `mongos`가 단 하나의 샤드에게만 물어보고 답을 얻는 **타겟티드 쿼리(Targeted Query)** 입니다. 이를 위해서는 샤드 키가 애플리케이션의 **가장 중요하고 빈번한 쿼리**의 필터 조건에 반드시 포함되어야 합니다.

* **나쁜 예:** `orders` 컬렉션을 `orderId`로 샤딩했는데, 애플리케이션의 가장 핵심적인 기능이 특정 고객의 모든 주문 내역(`customerId` 기준)을 조회하는 것이라고 가정해 봅시다. `mongos`는 어떤 `customerId`가 어느 샤드에 있는지에 대한 정보가 없으므로, 이 쿼리를 **모든 샤드에게** 전부 보내서 각자 결과를 취합해야 합니다. 이를 **스캐터-개더(Scatter-gather)** 쿼리라고 하며, 클러스터 전체에 큰 부하를 주고 매우 비효율적입니다.

* **좋은 예:** 위와 같은 상황이라면, `customerId`를 샤드 키로 선택하는 것이 훨씬 현명합니다. `{ customerId: "user001" }` 쿼리는 `mongos`가 `user001` 데이터가 있는 샤드를 정확히 찾아 쿼리를 보내는 타겟티드 쿼리가 되어, 매우 빠르고 효율적으로 동작합니다.

---

### 샤드 키 전략: Ranged vs. Hashed

이러한 요건들을 바탕으로 샤드 키를 선택할 때, MongoDB는 두 가지 주요 분산 전략을 제공합니다.

* **범위 기반 샤딩 (Ranged Sharding):**
    샤드 키 값을 기준으로 연속적인 범위를 만들어 청크(Chunk)를 분할합니다. (예: ID 1~1000은 샤드 A, 1001~2000은 샤드 B)
    * **장점:** `orderDate` 와 같이 범위 기반 쿼리(`find({ orderDate: { $gt: ..., $lt: ... } })`)에 매우 효율적입니다. `mongos`가 해당 날짜 범위가 포함된 샤드들에게만 쿼리를 보낼 수 있습니다.
    * **단점:** `ObjectId`나 타임스탬프처럼 단조롭게 증가하는 값을 키로 사용하면, 모든 새로운 쓰기(insert)가 가장 마지막 범위를 가진 **단 하나의 샤드**에만 집중되어 극심한 쓰기 핫스팟을 유발합니다.

* **해시 기반 샤딩 (Hashed Sharding):**
    샤드 키 필드의 값을 해시(hash)한 뒤, 그 해시 값을 기준으로 데이터를 분산시킵니다.
    * **장점:** 키 값의 분포나 증가 패턴과 상관없이, 데이터를 클러스터 전체에 **완벽하게 균등하게 분산**시킵니다. 단조롭게 증가하는 키의 쓰기 핫스팟 문제를 해결하는 데 이상적입니다.
    * **단점:** 원래 값의 순서와 상관없이 데이터가 무작위로 흩어지므로, **범위 기반 쿼리의 효율성을 완전히 잃게 됩니다.** 모든 범위 쿼리는 스캐터-개더 방식으로 동작할 수밖에 없습니다.

최적의 샤드 키를 선택하는 것은 정답이 없는, 애플리케이션의 데이터 특성과 핵심 쿼리 패턴을 깊이 분석하여 최적의 균형점을 찾아가는 과정입니다. 이 최초의 설계가 미래 시스템의 확장성을 결정짓는다는 것을 명심해야 합니다.