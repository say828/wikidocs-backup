## 02\. 1:1, 1:N, N:M 관계 모델링 패턴

임베딩과 레퍼런싱이라는 두 가지 기본 도구를 이해했으니, 이제 이를 활용하여 데이터베이스 설계 시 마주치는 세 가지 표준 관계(1:1, 1:N, N:M)를 어떻게 모델링하는지 구체적인 패턴을 통해 알아보겠습니다. 어떤 패턴을 선택할지는 데이터 간의 관계(Cardinality), 그리고 애플리케이션이 데이터를 어떻게 읽고 쓰는가(Access Pattern)에 따라 결정됩니다.

### 1:1 (One-to-One) 관계

하나의 도큐먼트가 다른 하나의 도큐먼트와만 관계를 맺는 경우입니다. 예를 들어, 한 명의 `회원(User)`은 하나의 `회원 상세 정보(User Profile)`를 가집니다.

  * **주요 패턴: 임베딩 (Embedding)**
    1:1 관계에서는 거의 항상 두 데이터가 함께 필요합니다. 따라서 관련 데이터를 하나의 서브 도큐먼트로 임베딩하는 것이 가장 자연스럽고 효율적입니다.

    **이커머스 예시: `상품(Product)`과 거의 항상 함께 조회되는 `재고(Inventory)` 정보**

    ```json
    {
      "_id": "MDB_TSHIRT_01",
      "name": "MongoDB Developer T-Shirt",
      "price": 25.00,
      "inventory": {
        "warehouse": "Seoul-A",
        "quantity": 150,
        "reorder_level": 50
      }
    }
    ```

    이렇게 모델링하면 상품 정보를 조회할 때 단 한 번의 쿼리로 재고 정보까지 가져올 수 있습니다.

  * **예외적 패턴: 레퍼런싱 (Referencing)**
    만약 1:1 관계의 데이터 중 일부가 매우 크고(예: 사용자의 상세 바이오그래피), 자주 액세스되지 않는다면 레퍼런싱을 고려할 수 있습니다. 이는 자주 사용하는 메인 도큐먼트의 크기를 작게 유지하여 메모리 효율성을 높이기 위함입니다.

-----

### 1:N (One-to-Many) 관계

하나의 도큐먼트가 여러 개의 다른 도큐먼트와 관계를 맺는, 가장 흔한 관계 유형입니다. 이 관계는 'N'의 개수가 얼마나 많은지에 따라 두 가지 패턴으로 나뉩니다.

  * **패턴 1: '1 대 소수(One-to-Few)' - 임베딩**
    'N'의 개수가 수십, 수백 개 수준으로 제한적이고, 자식 도큐먼트가 부모 도큐먼트의 컨텍스트 안에서만 의미가 있을 때 사용합니다.

    **이커머스 예시: `회원(User)`과 그들의 `배송지 주소(Addresses)`**
    한 명의 회원이 수천 개의 배송지를 가질 확률은 거의 없습니다. 이 경우 `addresses` 배열을 `user` 도큐먼트 안에 임베딩하는 것이 최적입니다.

    ```json
    {
      "_id": "user001",
      "username": "atlas_architect",
      "addresses": [
        { "alias": "집", "address": "서울특별시 강남구", "is_default": true },
        { "alias": "회사", "address": "경기도 성남시 분당구", "is_default": false }
      ]
    }
    ```

  * **패턴 2: '1 대 다수(One-to-Many/Squillions)' - 레퍼런싱**
    'N'의 개수가 수천 개를 넘어 무한히 증가할 수 있다면 반드시 레퍼런싱을 사용해야 합니다.

    **이커머스 예시: `주문(Order)`과 해당 주문에 포함된 수많은 `결제 시도 기록(Payment Attempts)`**
    한 번의 주문에 대해 고객이 카드 실패, 가상계좌 만료 등으로 여러 번 결제를 시도할 수 있습니다. 이 기록은 분석 외에는 주문과 함께 항상 조회될 필요는 없습니다.

    **`orders` 컬렉션:**

    ```json
    {
      "_id": "ORD_20250929_001",
      "user_id": "user001",
      "total_amount": 150.75
    }
    ```

    **`payment_attempts` 컬렉션:**

    ```json
    [
      { "attempt_id": 1, "order_id": "ORD_20250929_001", "status": "FAILED", "reason": "insufficient_funds" },
      { "attempt_id": 2, "order_id": "ORD_20250929_001", "status": "SUCCESS", "method": "credit_card" }
    ]
    ```

    `payment_attempts` 도큐먼트가 부모인 `order`의 `_id`를 `order_id` 필드에 저장하는 방식입니다.

-----

### N:M (Many-to-Many) 관계

여러 도큐먼트가 다른 여러 도큐먼트와 관계를 맺는 경우입니다. 예를 들어, 하나의 `상품`은 여러 `카테고리`에 속할 수 있고, 하나의 `카테고리`는 여러 `상품`을 가질 수 있습니다.

  * **주요 패턴: 양방향 레퍼런싱 (Two-Way Referencing)**
    가장 일반적인 N:M 해결책은 각 도큐먼트가 관계를 맺는 상대방 도큐먼트 `_id`들의 배열을 갖는 것입니다.

    **이커머스 예시: `상품(Products)`과 `카테고리(Categories)`**

    **`products` 컬렉션:**

    ```json
    {
      "_id": "MDB_TSHIRT_01",
      "name": "MongoDB Developer T-Shirt",
      // 카테고리 _id들의 배열을 저장
      "category_ids": ["apparel", "t-shirts", "dev-goods"]
    }
    ```

    **`categories` 컬렉션:**

    ```json
    {
      "_id": "t-shirts",
      "display_name": "T-Shirts",
      // 이 카테고리에 속한 상품 _id들의 배열을 저장
      "product_ids": ["MDB_TSHIRT_01", "ATLAS_TSHIRT_02", ...]
    }
    ```

    이 구조에서는 **"t-shirts" 카테고리에 속한 모든 상품을 찾는 쿼리**와 **"MDB\_TSHIRT\_01" 상품이 속한 모든 카테고리를 찾는 쿼리** 모두 매우 효율적으로 수행할 수 있습니다.

    다만, 상품에 새 카테고리를 추가할 때 `products`와 `categories` 양쪽에 업데이트가 필요하므로 애플리케이션 레벨에서 데이터 일관성을 관리해야 하는 트레이드오프가 있습니다. 어느 한쪽에만 배열을 두는 '단방향 레퍼런싱'도 가능하며, 이는 어떤 방향의 쿼리가 더 빈번한지에 따라 결정합니다.

이처럼 관계의 종류와 데이터 접근 패턴을 분석하여 최적의 모델링을 선택하는 것이 MongoDB를 전문가처럼 사용하는 첫걸음입니다. 다음 절에서는 이 기본 패턴들을 응용한 고급 모델링 패턴에 대해 알아보겠습니다.