-----

## 03\. 다형성 패턴(Polymorphic Pattern)과 속성 패턴(Attribute Pattern)

지금까지 살펴본 표준 관계 모델링을 넘어, MongoDB의 유연한 스키마는 복잡하고 다양한 데이터를 우아하게 처리할 수 있는 고급 패턴의 문을 열어줍니다. 그중에서도 특히 강력한 두 가지 패턴, 다형성 패턴과 속성 패턴을 소개합니다. 이 패턴들은 유사하지만 다른 형태의 데이터를 통합 관리하거나, 예측 불가능한 수많은 속성을 가진 데이터를 모델링해야 할 때 진가를 발휘합니다.

### 다형성 패턴 (Polymorphic Pattern)

**다형성 패턴**은 서로 다른 필드 구조를 가진 도큐먼트들을 **하나의 컬렉션**에 저장하고자 할 때 사용합니다. 이 도큐먼트들은 일부 공통된 필드를 공유하지만, 각자의 '타입'에 따라 고유한 필드를 가집니다.

**💡 언제 사용하는가?**
본질적으로는 같은 범주에 속하지만(예: '결제 수단', '이벤트 로그', '연락처'), 세부 내용은 다른 여러 종류의 데이터를 다룰 때 유용합니다. 각 타입마다 별도의 컬렉션(`credit_cards`, `bank_accounts`)을 만드는 대신, 하나의 컬렉션으로 통합하여 쿼리를 단순화하고 관리를 용이하게 할 수 있습니다.

**이커머스 예시: 회원의 다양한 `결제 수단(payment_methods)` 관리**
회원은 신용카드, 은행 계좌, 포인트 등 다양한 결제 수단을 등록할 수 있습니다. 각 수단은 필요한 정보가 모두 다릅니다.

하나의 `payment_methods` 컬렉션에 다형성 패턴을 적용하면 다음과 같습니다.

```json
[
  {
    "_id": ObjectId("..."),
    "user_id": "user001",
    "method_type": "CREDIT_CARD", // 결제 수단 타입을 명시하는 키 필드
    "is_default": true,
    "card_brand": "Visa",
    "last_4_digits": "1234",
    "expiry_year": 2028
  },
  {
    "_id": ObjectId("..."),
    "user_id": "user001",
    "method_type": "BANK_ACCOUNT",
    "is_default": false,
    "bank_name": "MongoBank",
    "last_4_digits": "5678"
  },
  {
    "_id": ObjectId("..."),
    "user_id": "user002",
    "method_type": "REWARD_POINTS",
    "balance": 15000
  }
]
```

**✅ 장점:**

  * **쿼리의 단순화:** 특정 회원의 '모든' 결제 수단을 조회하는 작업이 `db.payment_methods.find({ user_id: "user001" })` 단 한 번의 쿼리로 끝납니다. 여러 컬렉션을 조회하여 애플리케이션에서 결과를 병합할 필요가 없습니다.
  * **유지보수의 용이성:** 향후 '암호화폐 지갑'과 같은 새로운 결제 수단이 추가되어도, 데이터베이스 스키마를 변경할 필요 없이 애플리케이션 코드만 새로운 `method_type`을 처리하도록 추가하면 됩니다.

-----

### 속성 패턴 (Attribute Pattern)

**속성 패턴**은 수많은 속성(필드)을 가질 수 있는 데이터를 모델링할 때, 특히 그 속성들이 일부 도큐먼트에서만 사용되고 대부분은 비어 있을 경우에 매우 유용합니다. 모든 가능성을 고려하여 수백 개의 필드를 스키마에 정의하는 대신, 속성을 키-값 쌍의 배열로 저장하는 방식입니다.

**💡 언제 사용하는가?**
이커머스 사이트의 **상품(Product)** 데이터가 가장 대표적인 예입니다. 노트북은 `CPU`, `RAM` 속성을, 티셔츠는 `색상`, `사이즈` 속성을, 책은 `ISBN`, `저자` 속성을 가집니다. 이 모든 속성을 최상위 필드로 두면 스키마가 비대해지고 대부분의 필드가 `null` 값을 갖게 되어 비효율적입니다.

**이커머스 예시: 다양한 `상품(products)`의 고유 속성 관리**

속성 패턴을 적용하면 `products` 컬렉션은 다음과 같이 설계됩니다.

```json
[
  {
    "_id": "MDB_LAPTOP_X1",
    "name": "MongoBook Pro 14",
    "price": 1999.00,
    "specs": [ // 속성을 저장하는 배열
      { "key": "cpu", "value": "M3 Max" },
      { "key": "ram_gb", "value": 32 },
      { "key": "storage_gb", "value": 1024 }
    ]
  },
  {
    "_id": "MDB_TSHIRT_01",
    "name": "MongoDB Developer T-Shirt",
    "price": 25.00,
    "specs": [
      { "key": "color", "value": "Leaf Green" },
      { "key": "size", "value": "XL" },
      { "key": "material", "value": "100% Cotton" }
    ]
  }
]
```

**✅ 장점:**

  * **인덱싱 효율 극대화:** `cpu`, `ram`, `color`, `size` 등 수많은 개별 속성에 각각 인덱스를 생성하는 대신, `specs` 배열에 **단 하나의 복합 멀티키 인덱스(Compound Multikey Index)**, 예를 들어 `{"specs.key": 1, "specs.value": 1}` 를 생성할 수 있습니다. 이 단일 인덱스로 "RAM이 32GB인 노트북"을 찾는 쿼리와 "색상이 Leaf Green인 티셔츠"를 찾는 쿼리 모두를 효율적으로 처리할 수 있습니다. 이는 인덱스 개수를 획기적으로 줄여 쓰기 성능과 저장 공간을 절약해 줍니다.
  * **쿼리의 일관성:** 어떤 속성을 검색하든 `db.products.find({ "specs": { $elemMatch: { "key": "ram_gb", "value": 32 } } })` 와 같이 일관된 구조의 쿼리를 사용할 수 있습니다.

다형성 패턴과 속성 패턴은 MongoDB의 스키마 유연성이 단순한 '자유'를 넘어, 어떻게 '최적화'로 이어질 수 있는지를 보여주는 강력한 사례입니다. 데이터의 본질적인 형태를 깊이 분석하여 적절한 패턴을 적용하는 것이야말로 진정한 데이터 모델링 전문가의 역량이라 할 수 있습니다.