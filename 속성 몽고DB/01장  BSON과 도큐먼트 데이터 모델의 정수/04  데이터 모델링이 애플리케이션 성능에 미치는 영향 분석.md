## 04\. 데이터 모델링이 애플리케이션 성능에 미치는 영향 분석

이 장의 시작부터 우리는 BSON의 타입 시스템, 임베딩과 레퍼런싱의 차이, 그리고 다양한 모델링 패턴들을 학습했습니다. 이제 이 모든 지식을 통합하여, **"그래서, 데이터 모델링이 왜 그렇게 중요한가?"** 라는 근본적인 질문에 답할 시간입니다.

결론부터 말하자면, **데이터 모델은 애플리케이션의 성능, 확장성, 그리고 운영 비용을 결정짓는 가장 지배적인 요소**입니다. 잘못된 데이터 모델을 선택하고 그 위에 애플리케이션을 구축하는 것은, 마치 모래 위에 마천루를 짓는 것과 같습니다. 아무리 비싼 하드웨어(CPU, RAM, IOPS)를 투입해도, 근본적인 설계 결함에서 비롯되는 성능 저하를 막을 수는 없습니다.

이 영향을 가장 극적으로 보여주기 위해, 하나의 요구사항에 대한 두 가지 다른 모델링 접근법과 그 결과를 비교 분석해 보겠습니다.

### 케이스 스터디: 이커머스 상품의 Q\&A 게시판

  * **요구사항:** 사용자는 상품 상세 페이지에서 해당 상품에 대한 Q\&A 목록을 볼 수 있습니다. 페이지 로딩 시, 상품 정보와 함께 최신 Q\&A 5개가 즉시 표시되어야 합니다.

-----

#### 모델 A: 정규화된 레퍼런싱 모델 (RDBMS적 접근)

이 모델은 데이터를 정규화하여 `products` 컬렉션과 `qna` 컬렉션으로 분리합니다.

  * **`products` 컬렉션:**

    ```json
    { "_id": "MDB_TSHIRT_01", "name": "MongoDB Developer T-Shirt", ... }
    ```

  * **`qna` 컬렉션:**

    ```json
    { "_id": ObjectId("..."), "product_id": "MDB_TSHIRT_01", "question": "..." },
    { "_id": ObjectId("..."), "product_id": "MDB_TSHIRT_01", "question": "..." }
    ```

  * **데이터를 가져오는 로직 (애플리케이션 코드):**

    1.  상품 정보를 가져온다: `db.products.findOne({ _id: "MDB_TSHIRT_01" });`
    2.  상품 ID를 이용해 Q\&A 목록을 가져온다: `db.qna.find({ product_id: "MDB_TSHIRT_01" }).sort({ createdAt: -1 }).limit(5);`

  * **성능에 미치는 영향:**

      * **네트워크 지연 시간 증가:** 상품 상세 페이지 하나를 렌더링하기 위해 데이터베이스에 **최소 두 번의 독립적인 요청(Round-trip)** 이 필요합니다. 이는 애플리케이션의 응답 시간을 직접적으로 저하시키는 주된 원인입니다.
      * **서버 부하:** 두 개의 분리된 쿼리는 각각의 쿼리 계획 수립, 인덱스 스캔, 데이터 조회를 유발합니다. 사용자가 몰릴수록 이 부하는 배가 됩니다. (`$lookup`을 사용해도 내부적으로는 유사한 조인 오버헤드가 발생합니다.)

-----

#### 모델 B: 서브셋 패턴을 활용한 임베딩 모델 (MongoDB적 접근)

이 모델은 **"함께 자주 읽히는 데이터는 함께 저장한다"** 는 철학을 적용합니다. 모든 Q\&A를 상품 도큐먼트에 임베딩하면 16MB 제한에 걸릴 수 있으므로, 요구사항에 명시된 **가장 자주 필요한 데이터의 일부(Subset)만** 임베딩합니다.

  * **`products` 컬렉션:**

    ```json
    {
      "_id": "MDB_TSHIRT_01",
      "name": "MongoDB Developer T-Shirt",
      // ...
      "recent_qna": [
        { "qna_id": ObjectId("..."), "question_summary": "배송 문의 드립니다.", "createdAt": ISODate("...") },
        { "qna_id": ObjectId("..."), "question_summary": "XL 사이즈 재입고 되나요?", "createdAt": ISODate("...") }
      ],
      "qna_total_count": 25
    }
    ```

  * **`qna` 컬렉션:** 전체 Q\&A 데이터는 여전히 별도 컬렉션에 저장됩니다.

  * **데이터를 가져오는 로직 (애플리케이션 코드):**

    1.  상품 정보를 가져온다: `db.products.findOne({ _id: "MDB_TSHIRT_01" });`

  * **성능에 미치는 영향:**

      * **네트워크 효율 극대화:** **단 한 번의 데이터베이스 요청**으로 페이지 렌더링에 필요한 모든 데이터를 가져올 수 있습니다. 이는 모델 A에 비해 응답 속도에서 압도적인 우위를 가집니다.
      * **서버 부하 감소:** 가장 빠른 `_id` 기반의 단일 도큐먼트 조회 연산은 서버에 주는 부하가 매우 적습니다. 동일한 하드웨어로 훨씬 더 많은 트래픽을 처리할 수 있으며, 이는 **클라우드 환경에서 직접적인 비용 절감**으로 이어집니다.

#### 두 모델의 트레이드오프

물론 모델 B는 새로운 Q\&A가 등록될 때마다 `qna` 컬렉션에 문서를 삽입하고, 동시에 `products` 컬렉션의 `recent_qna` 배열을 업데이트하는 추가적인 쓰기 로직이 필요합니다. 하지만 대부분의 애플리케이션(특히 이커머스)은 **쓰기보다 읽기가 압도적으로 많습니다 (Read-heavy).** 모델 B는 이처럼 불균형한 읽기/쓰기 비율을 고려하여, 가장 빈번한 **읽기 작업(80%)을 최적화**하기 위해 상대적으로 드문 **쓰기 작업(20%)의 복잡성을 감수**하는 현명한 엔지니어링적 결정입니다.

이처럼 데이터 모델링은 단순히 데이터를 어떻게 구성할지의 문제가 아닙니다. 그것은 애플리케이션의 핵심적인 데이터 접근 패턴을 분석하고, 성능과 비용, 개발 생산성 사이에서 최적의 균형점을 찾아가는 아키텍처 설계의 과정입니다. 잘 설계된 데이터 모델은 MongoDB의 성능을 100% 끌어내는 열쇠이며, 잘못된 모델은 값비싼 서버로도 해결할 수 없는 성능의 족쇄가 될 것입니다.