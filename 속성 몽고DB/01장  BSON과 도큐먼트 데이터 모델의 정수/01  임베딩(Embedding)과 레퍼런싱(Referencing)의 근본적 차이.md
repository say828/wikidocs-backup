## 01\. 임베딩(Embedding)과 레퍼런싱(Referencing)의 근본적 차이

MongoDB에서 효율적인 데이터 모델을 설계하는 것은 하나의 질문으로 귀결됩니다: **"관련된 데이터를 하나의 도큐먼트 안에 넣을 것인가(Embedding), 아니면 별도의 도큐먼트로 분리하고 연결할 것인가(Referencing)?"** 이 결정은 애플리케이션의 성능, 데이터의 일관성, 그리고 쿼리의 복잡성에 지대한 영향을 미치는 가장 근본적인 선택입니다.

### 임베딩 (Embedding) - '포함'의 미학

**임베딩**은 관계형 데이터베이스의 '비정규화(Denormalization)'와 유사한 개념으로, 관련된 데이터를 부모 도큐먼트 내에 서브 도큐먼트나 배열의 형태로 포함시키는 방식입니다. 이 모델의 핵심 철학은 여전히 **"함께 액세스하는 데이터는 함께 저장한다"** 입니다.

예를 들어, 하나의 **상품(Product)** 과 그 상품에 달린 여러 개의 **리뷰(Reviews)** 관계를 생각해 보겠습니다. 임베딩 모델에서는 `reviews` 배열을 `product` 도큐먼트 안에 직접 포함시킵니다.

```json
{
  "_id": "MDB_BOOK_01",
  "title": "MongoDB 완전 정복",
  "author": "Alex Kim",
  "price": 32.00,
  "currency": "USD",
  "reviews": [
    {
      "username": "atlas_architect",
      "rating": 5,
      "comment": "이 책 하나면 충분합니다. 최고의 MongoDB 서적!",
      "created_at": ISODate("2025-09-28T14:30:00Z")
    },
    {
      "username": "bson_lover",
      "rating": 4,
      "comment": "내용이 깊이가 있지만, 초심자에겐 조금 어려울 수도 있겠네요.",
      "created_at": ISODate("2025-09-29T11:25:00Z")
    }
  ]
}
```

**✅ 장점:**

  * **압도적인 읽기 성능:** 상품 상세 페이지를 표시하기 위해 필요한 모든 정보(상품 정보, 리뷰 목록)를 단 한 번의 데이터베이스 읽기 작업으로 가져올 수 있습니다. 애플리케이션 레벨에서 추가적인 쿼리나 `JOIN` 이 필요 없어 매우 빠릅니다.
  * **데이터의 원자성(Atomicity):** 단일 도큐먼트 내에서의 모든 변경 작업은 원자적으로 처리됩니다. 즉, 상품의 가격을 변경하면서 동시에 새로운 리뷰를 추가하는 작업을 하나의 단위로 묶어 처리할 수 있어, 데이터가 중간 상태에 머무는 것을 방지하고 강력한 일관성을 보장합니다.

**❌ 단점:**

  * **도큐먼트 크기 제한:** BSON 도큐먼트는 최대 16MB의 크기 제한이 있습니다. 만약 `reviews` 배열이 수천, 수만 개로 무한히 증가할 수 있다면(unbounded), 언젠가 이 크기 제한에 도달할 위험이 있습니다.
  * **데이터 중복 및 업데이트의 어려움:** 만약 `username` 대신 사용자 정보 전체를 리뷰마다 임베딩했는데, 사용자가 닉네임을 변경한다면 해당 사용자가 작성한 모든 리뷰를 찾아 닉네임을 수정해야 하는 복잡한 업데이트 작업이 필요합니다.

### 레퍼런싱 (Referencing) - '연결'의 유연함

**레퍼런싱**은 관계형 데이터베이스의 '정규화(Normalization)'와 유사한 접근 방식으로, 관련된 데이터를 별도의 컬렉션에 저장하고 각 도큐먼트가 서로의 `_id` 값을 참조(Reference)하도록 하는 방식입니다.

앞선 예제를 레퍼런싱 모델로 변경하면, `products` 컬렉션과 `reviews` 컬렉션으로 분리됩니다.

**`products` 컬렉션:**

```json
{
  "_id": "MDB_BOOK_01",
  "title": "MongoDB 완전 정복",
  "author": "Alex Kim",
  "price": 32.00,
  "currency": "USD"
}
```

**`reviews` 컬렉션:**

```json
[
  {
    "_id": ObjectId("..."),
    "product_id": "MDB_BOOK_01", // products 컬렉션의 _id를 참조
    "username": "atlas_architect",
    "rating": 5,
    "comment": "이 책 하나면 충분합니다. 최고의 MongoDB 서적!",
    "created_at": ISODate("2025-09-28T14:30:00Z")
  },
  {
    "_id": ObjectId("..."),
    "product_id": "MDB_BOOK_01",
    "username": "bson_lover",
    "rating": 4,
    "comment": "내용이 깊이가 있지만, 초심자에겐 조금 어려울 수도 있겠네요.",
    "created_at": ISODate("2025-09-29T11:25:00Z")
  }
]
```

**✅ 장점:**

  * **데이터 중복 최소화:** 사용자 정보나 상품 정보가 변경되어도 해당 컬렉션의 도큐먼트 하나만 수정하면 되므로 데이터 정합성을 유지하기 쉽습니다.
  * **크기 제한의 자유로움:** 상품에 리뷰가 아무리 많이 달려도 `products` 도큐먼트의 크기는 변하지 않습니다. '일대다' 관계에서 '다'에 해당하는 부분이 무한히 커질 수 있을 때 적합합니다.
  * **유연한 데이터 접근:** 리뷰 데이터만 독립적으로 조회하거나 분석하기에 용이합니다.

**❌ 단점:**

  * **읽기 성능 저하:** 상품과 모든 리뷰를 함께 가져오려면 최소 두 번의 쿼리가 필요합니다. (1. `products` 컬렉션에서 상품 조회, 2. `reviews` 컬렉션에서 `product_id`로 리뷰들 조회) 이는 데이터베이스와의 통신 횟수(round-trip)를 증가시켜 지연 시간을 유발합니다. MongoDB의 애그리게이션 파이프라인 스테이지인 `$lookup` 을 사용하면 서버 단에서 `JOIN` 과 유사한 작업을 수행할 수 있지만, 임베딩 모델의 단일 읽기보다는 일반적으로 느립니다.

### 결론: 언제 무엇을 선택할 것인가?

두 모델 사이의 선택은 정답이 없는 트레이드오프 관계입니다. 하지만 MongoDB 모델링에는 다음과 같은 황금률이 존재합니다.

> **"명백한 반대 이유가 없는 한, 임베딩을 우선적으로 고려하라."**
> (Favor embedding unless there is a compelling reason not to.)

'명백한 반대 이유'란 다음과 같은 경우를 의미합니다.

1.  임베딩될 데이터가 **무한히 커질 가능성**이 있는 경우 (예: IoT 센서의 로그, 게시물의 댓글)
2.  임베딩된 데이터가 그 자체로 **자주, 그리고 독립적으로 조회**되어야 하는 경우
3.  데이터의 **일관성**이 읽기 성능보다 훨씬 더 중요한 경우

이 근본적인 차이를 이해하는 것이 효과적인 MongoDB 데이터 모델링의 첫걸음입니다. 다음 절에서는 이 두 가지 기법을 활용하여 1:1, 1:N, N:M 과 같은 구체적인 데이터 관계를 어떻게 모델링하는지 살펴보겠습니다.