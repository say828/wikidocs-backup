## 쿼리 플랜(Query Plan) 상세 분석 가이드

쿼리 성능 튜닝은 추측의 영역이 아닌 과학의 영역입니다. MongoDB는 `explain()` 메소드를 통해, 특정 쿼리를 어떻게 실행할 것인지에 대한 내부적인 실행 계획, 즉 **쿼리 플랜(Query Plan)**을 상세하게 제공합니다. 이 쿼리 플랜을 해독하는 능력은 비효율적인 쿼리를 식별하고 최적화하는 데 필수적인 기술입니다.

이 부록은 `explain()` 결과의 핵심 구조와 주요 실행 스테이지(stage)를 분석하여, 전문가 수준의 성능 분석을 수행할 수 있도록 돕는 가이드입니다. 대부분의 경우, 실제 쿼리를 실행하고 통계까지 함께 보는 `executionStats` 모드를 사용하는 것이 가장 유용합니다.
`db.collection.find({ ... }).explain("executionStats")`

---

### 실행 계획의 핵심 구조: 스테이지 트리(Tree of Stages)

쿼리 플랜은 **스테이지(Stage)**들이 나무(tree) 형태로 연결된 구조를 가집니다. 데이터는 가장 아래쪽의 리프(leaf) 스테이지에서부터 시작하여, 부모 스테이지로 전달되며 가공된 후, 최종적으로 루트(root) 스테이지에서 결과가 출력됩니다.

* **예시:** `LIMIT` → `FETCH` → `IXSCAN`
    * `IXSCAN` (리프 스테이지): 인덱스를 스캔하여 조건에 맞는 문서의 위치(포인터)를 찾습니다.
    * `FETCH`: `IXSCAN`으로부터 받은 위치 정보를 이용해 디스크에서 실제 문서를 읽어옵니다.
    * `LIMIT` (루트 스테이지): `FETCH`로부터 받은 문서들 중 처음 N개만 최종 결과로 반환합니다.

가장 중요한 것은 리프 스테이지가 무엇인지 확인하는 것입니다. `COLLSCAN`인지 `IXSCAN`인지에 따라 쿼리의 성능은 하늘과 땅 차이입니다.

---

### 주요 실행 스테이지(Execution Stages) 상세 분석

| 스테이지 | 의미 | 분석 및 대응 방안 |
| :--- | :--- | :--- |
| **`COLLSCAN`** | **컬렉션 스캔.** 쿼리를 처리하기 위해 적절한 인덱스를 찾지 못하고 컬렉션의 모든 문서를 스캔했음을 의미합니다. | **(심각한 성능 문제 🚩)** 대용량 컬렉션에서 절대적으로 피해야 합니다. 쿼리의 필터 조건에 맞는 새로운 인덱스를 즉시 생성해야 합니다. |
| **`IXSCAN`** | **인덱스 스캔.** 쿼리가 인덱스를 성공적으로 사용했음을 의미합니다. | **(좋은 신호 ✅)** 어떤 인덱스(`indexName`)를 사용했는지, 인덱스 범위를 얼마나 효율적으로 좁혔는지(`indexBounds`) 확인하여 가장 최적의 인덱스를 사용했는지 검토합니다. |
| **`FETCH`** | `IXSCAN`을 통해 찾은 문서 포인터를 따라 디스크에서 **실제 문서를 가져오는 단계**입니다. | `IXSCAN` 뒤에 항상 따라붙는 것이 일반적입니다. 만약 이 단계를 없앨 수 있다면 성능이 극대화됩니다. 쿼리에 필요한 모든 필드가 인덱스에 포함되도록 하여 **커버드 쿼리(Covered Query)**로 만들 수 있는지 검토합니다. |
| **`SORT`** | 인덱스를 통해 정렬 순서를 만족시키지 못하고, **메모리 내에서 별도의 정렬 작업**을 수행했음을 의미합니다. | 대용량 데이터에 대한 인메모리 정렬은 매우 비효율적이며 CPU와 RAM을 많이 소모합니다. 쿼리의 필터 조건과 정렬 조건을 모두 포함하는 **복합 인덱스**를 생성하여 `SORT` 스테이지를 제거해야 합니다. |
| **`LIMIT`** | `.limit()` 메소드에 해당하는 결과를 제한하는 단계입니다. | 문제가 없습니다. |
| **`SKIP`** | `.skip()` 메소드에 해당하는 문서를 건너뛰는 단계입니다. | 페이지네이션(pagination) 구현 시 `SKIP`의 값이 커질수록(예: 100만 번째 페이지 조회), 건너뛰기 위해 불필요한 문서를 많이 읽어야 하므로 성능이 급격히 저하될 수 있습니다. |

---

### `executionStats` 핵심 통계 해석

* **`executionTimeMillis`**: 쿼리 실행에 걸린 총 시간. 성능의 최종 결과 지표입니다.
* **`totalKeysExamined`**: 쿼리를 위해 스캔한 총 인덱스 키의 수.
* **`totalDocsExamined`**: 쿼리를 위해 스캔한 총 문서의 수.
* **`nReturned`**: 쿼리가 최종적으로 반환한 문서의 수.

**이상적인 쿼리의 황금률: `nReturned` ≈ `totalKeysExamined` ≈ `totalDocsExamined`**

* **`totalDocsExamined` >> `nReturned`:** 인덱스가 데이터를 충분히 걸러주지 못했다는 의미입니다. 인덱스는 사용했지만 선택성이 낮아, 디스크에서 너무 많은 문서를 추가로 확인해야 했습니다. 더 선택성이 높은 인덱스가 필요합니다.
* **`totalKeysExamined` >> `nReturned`:** 인덱스는 넓은 범위를 스캔했지만, 실제 결과는 몇 개 없었다는 의미입니다. 복합 인덱스의 필드 순서가 쿼리에 최적화되지 않았을 수 있습니다.
* **커버드 쿼리:** `totalDocsExamined`가 **`0`**이 됩니다. 실제 문서는 단 하나도 보지 않았다는 가장 확실한 증거입니다.

---

### 분석 시나리오 예시

**쿼리:** 특정 상품(`productId`)에 달린 별점 5점짜리 리뷰를 최신순으로 조회
`db.reviews.find({ productId: "P123", rating: 5 }).sort({ createdAt: -1 })`

* **인덱스 A: `{ productId: 1 }`**
    * **예상 플랜:** `SORT` → `FETCH` → `IXSCAN`
    * **분석:** `productId`로 문서를 찾는 것은 빠르지만, 찾은 모든 문서를 메모리로 가져와 `createdAt` 기준으로 다시 정렬해야 합니다. 리뷰가 많을수록 `SORT` 단계에서 심각한 병목이 발생합니다.

* **인덱스 B: `{ productId: 1, createdAt: -1 }`**
    * **예상 플랜:** `FETCH` → `IXSCAN`
    * **분석:** `productId`로 범위를 좁히고, 그 안에서 이미 `createdAt`으로 정렬된 인덱스를 순서대로 읽기만 하면 됩니다. 별도의 `SORT` 스테이지가 사라져 훨씬 효율적입니다. 하지만 여전히 `rating: 5` 조건을 만족하는지 확인하기 위해 디스크에서 많은 문서를 `FETCH` 해야 할 수 있습니다.

* **인덱스 C: `{ productId: 1, rating: 1, createdAt: -1 }`**
    * **예상 플랜:** `FETCH` → `IXSCAN`
    * **분석:** `productId`와 `rating`으로 조회 대상을 매우 효과적으로 좁힌 후, 이미 정렬된 `createdAt` 순서로 결과를 가져옵니다. **가장 이상적인 인덱스**입니다.

`explain()`은 쿼리 튜닝의 나침반입니다. 이 가이드를 통해 쿼리 플랜을 체계적으로 분석하는 습관을 들여, 항상 최상의 성능을 발휘하는 MongoDB 시스템을 구축하시기 바랍니다.