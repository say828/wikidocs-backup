## 04\. 애그리게이션 파이프라인 성능 최적화 전략

애그리게이션 파이프라인은 강력한 만큼, 어떻게 구성하느냐에 따라 성능이 극명하게 달라질 수 있습니다. 잘못 작성된 파이프라인은 불필요하게 많은 서버 자원(CPU, 메모리, 디스크 I/O)을 소모하여 응답 시간을 저하시키고, 심한 경우 데이터베이스 전체의 안정성에 영향을 미칠 수도 있습니다. 따라서 기능적으로 동작하는 파이프라인을 작성하는 것을 넘어, 효율적으로 동작하는 파이프라인을 작성하는 것이 전문가의 역량입니다.

다음은 애그리게이션 성능을 극대화하기 위한 핵심 전략들입니다.

-----

### 전략 1: 데이터의 양을 최대한 빨리, 최대한 많이 줄여라

이는 애그리게이션 최적화의 제1원칙입니다. 파이프라인의 뒷단으로 갈수록 데이터 처리 비용이 비싸지므로, 최대한 앞쪽에서 불필요한 도큐먼트와 필드를 제거해야 합니다.

  * **`$match`를 맨 앞으로:** 파이프라인의 가장 첫 번째 스테이지에 `$match`를 배치하여, 이어지는 스테이지들이 처리해야 할 도큐먼트의 수를 원천적으로 줄이십시오. 만약 `$match` 조건에 해당하는 필드에 인덱스가 있다면, MongoDB 옵티마이저는 인덱스를 사용하여 이 단계를 매우 빠르게 처리합니다.

  * **`$sort`와 `$match` 조합:** 만약 `$sort`와 `$match`가 연속해서 나오고, 정렬과 필터링에 사용되는 필드에 복합 인덱스가 존재한다면, 옵티마이저는 인덱스를 활용하여 정렬과 필터링을 동시에 효율적으로 처리할 수 있습니다.

  * **`$project`로 불필요한 필드 제거:** 만약 도큐먼트의 크기는 크지만, 실제 집계에는 일부 필드만 필요하다면, 파이프라인 초기에 `$project`를 사용하여 필요한 필드만 남기고 나머지는 제거하십시오. 이는 파이프라인이 사용하는 메모리 양을 크게 줄여줍니다.

**최적화 전 (나쁜 예):**

```javascript
db.logs.aggregate([
  { $sort: { timestamp: -1 } }, // 1억 건의 로그 전체를 먼저 정렬 (매우 비효율적)
  { $match: { level: "ERROR" } } // 그 다음에 필터링
])
```

**최적화 후 (좋은 예):**

```javascript
db.logs.aggregate([
  { $match: { level: "ERROR" } }, // 인덱스를 사용해 에러 로그만 빠르게 필터링
  { $sort: { timestamp: -1 } }  // 훨씬 적어진 데이터 양을 정렬
])
```

-----

### 전략 2: `$lookup` 대신 임베딩 재고려

`$lookup`은 매우 유용한 기능이지만, 본질적으로는 서버 사이드 조인 연산이므로 비용이 저렴하지 않습니다. 만약 특정 집계 쿼리에서 항상 동일한 `$lookup`이 반복적으로 사용된다면, 이는 데이터 모델 자체에 개선의 여지가 있다는 신호일 수 있습니다. 자주 함께 조회되는 데이터라면, 1장에서 다룬 임베딩 모델(또는 서브셋 패턴)을 적용하여 `$lookup`의 필요성 자체를 없애는 것이 가장 근본적인 성능 향상 방법입니다.

-----

### 전략 3: 메모리 사용량과 디스크 활용 허용

`$group`, `$sort`, `$bucket` 등 일부 스테이지는 도큐먼트들을 메모리에 모아서 처리해야 합니다. MongoDB는 단일 애그리게이션 스테이지가 시스템 전체를 마비시키는 것을 방지하기 위해, 기본적으로 스테이지당 **100MB의 메모리 사용량 제한**을 둡니다. 만약 이 한도를 초과하면 쿼리는 에러를 발생시키며 실패합니다.

이러한 대용량 집계가 반드시 필요한 경우, `aggregate` 메소드에 `allowDiskUse: true` 옵션을 추가할 수 있습니다.

```javascript
db.collection.aggregate(
  [ ... pipeline ... ],
  { allowDiskUse: true }
)
```

이 옵션은 MongoDB가 메모리 제한을 초과할 경우, 데이터를 디스크 상의 임시 파일에 기록하여 작업을 계속할 수 있도록 허용합니다. 이는 쿼리가 실패하는 것을 막아주지만, 디스크 I/O는 RAM보다 훨씬 느리므로 성능 저하를 감수해야 합니다. 따라서 이 옵션은 최후의 수단으로 사용하고, 그 전에 1번 전략을 통해 파이프라인에 들어오는 데이터의 양 자체를 줄이는 것이 우선입니다.

-----

### 전략 4: `explain()`으로 실행 계획 분석하기

`find` 쿼리와 마찬가지로, `aggregate` 쿼리에도 `.explain()` 메소드를 붙여 MongoDB가 해당 파이프라인을 어떻게 실행할 계획인지 상세히 확인할 수 있습니다.

```javascript
db.orders.explain().aggregate([ ... ])
```

`explain()` 결과에서 중점적으로 봐야 할 부분은 다음과 같습니다.

  * **`stages` 배열:** 옵티마이저가 수정한 최종 스테이지들의 순서와 내용을 보여줍니다.
  * **인덱스 사용 여부:** 첫 번째 `$match` 스테이지가 인덱스를 사용했는지(`IXSCAN`), 아니면 컬렉션 전체를 스캔했는지(`COLLSCAN`) 확인해야 합니다. `COLLSCAN`은 대용량 컬렉션에서 성능 저하의 주범입니다.
  * **`usedDisk` 필드:** `allowDiskUse` 옵션을 사용했을 때, 실제로 디스크가 사용되었는지 여부를 알려줍니다.

`explain()`을 통해 파이프라인의 병목 지점을 과학적으로 식별하고, 인덱스를 추가하거나 스테이지 순서를 변경하는 등의 방법으로 최적화를 진행해야 합니다.

애그리게이션 파이프라인은 데이터를 통찰력으로 바꾸는 강력한 연금술입니다. 위에 제시된 최적화 전략들을 체화하여, 여러분은 이제 빠르고 효율적이며 안정적인 '현자의 돌'을 만들어낼 수 있게 되었습니다.