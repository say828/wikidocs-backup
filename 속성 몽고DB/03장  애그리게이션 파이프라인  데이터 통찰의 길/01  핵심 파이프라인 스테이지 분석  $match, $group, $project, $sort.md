## 01\. 핵심 파이프라인 스테이지 분석: $match, $group, $project, $sort

애그리게이션 파이프라인은 수십 개의 다양한 스테이지로 구성될 수 있지만, 그중에서도 네 개의 핵심 스테이지는 거의 모든 집계 쿼리의 뼈대를 이룹니다. 바로 **`$match`**, **`$group`**, **`$project`**, **`$sort`** 입니다. 이 네 가지 스테이지의 역할과 상호작용을 이해하는 것은 파이프라인을 능숙하게 다루기 위한 첫걸음입니다.

-----

### `$match`: 데이터의 범위를 좁히는 필터

`$match` 스테이지는 파이프라인으로 들어오는 도큐먼트들을 필터링하여, 주어진 조건과 일치하는 도큐먼트만 다음 스테이지로 전달하는 역할을 합니다. SQL의 `WHERE` 절과 정확히 동일한 기능입니다.

  * **구문:** `$match` 내부에는 `db.collection.find()`에서 사용했던 것과 동일한 쿼리 도큐먼트가 들어갑니다. 모든 비교, 논리, 엘리먼트 연산자를 자유롭게 사용할 수 있습니다.

  * **성능 최적화의 핵심:** `$match`는 파이프라인의 **가장 첫 번째 단계에 배치하는 것**이 일반적인 모범 사례입니다. 파이프라인 초기에 데이터의 양을 최대한 줄여야, 이어지는 `$group`이나 `$sort` 같은 더 복잡한 스테이지의 계산 부담을 덜어줄 수 있기 때문입니다. 만약 `$match` 조건에 해당하는 필드에 인덱스가 있다면, MongoDB는 인덱스를 사용하여 이 필터링 작업을 매우 빠르게 수행합니다.

**이커머스 예시: 2025년 9월 한 달간 발생한 주문 데이터만 필터링**

```javascript
db.orders.aggregate([
  {
    $match: {
      orderDate: {
        $gte: ISODate("2025-09-01T00:00:00Z"),
        $lt: ISODate("2025-10-01T00:00:00Z")
      },
      status: "COMPLETED" // 완료된 주문만 대상으로 함
    }
  }
  // ... 다음 스테이지
])
```

-----

### `$group`: 데이터를 요약하고 집계하는 두뇌

`$group` 스테이지는 파이프라인의 심장부로, 여러 도큐먼트를 특정 기준에 따라 그룹화하고, 각 그룹에 대해 합계, 평균 등의 집계 연산을 수행합니다. SQL의 `GROUP BY` 절과 집계 함수에 해당합니다.

  * **구문:** `$group` 스테이지는 그룹화의 기준이 되는 `_id` 필드를 반드시 포함해야 합니다.
      * `_id`: 그룹화할 키를 지정합니다. 필드명을 `$` 접두사와 함께 사용하여 (`"$customerId"`) 해당 필드의 값으로 그룹화하거나, `null`을 사용하여 전체 도큐먼트를 하나의 그룹으로 묶을 수 있습니다.
      * **집계 연산자(Accumulators):** 각 그룹 내의 도큐먼트들을 대상으로 계산을 수행합니다.
          * `$sum`: 숫자 값의 합계를 구합니다.
          * `$avg`: 숫자 값의 평균을 구합니다.
          * `$min`/`$max`: 최소값/최대값을 찾습니다.
          * `$push`: 그룹에 속한 모든 도큐먼트의 특정 필드 값을 배열로 만듭니다.

**이커머스 예시: 위에서 필터링된 9월 주문을 고객(`customerId`)별로 그룹화하여, 각 고객의 총 주문 금액과 주문 횟수 계산**

```javascript
// ... $match 스테이지 이후
{
  $group: {
    _id: "$customerId", // 고객 ID를 기준으로 그룹화
    totalAmountSpent: { $sum: "$totalAmount" }, // 각 고객의 totalAmount 합계
    orderCount: { $sum: 1 } // 각 그룹의 문서 수를 세어 주문 횟수 계산
  }
}
```

-----

### `$project`: 결과의 형태를 재구성하는 조각가

`$project` 스테이지는 파이프라인을 통과하는 도큐먼트의 구조를 변경하는 역할을 합니다. 필드를 추가하거나, 제거하거나, 이름을 바꾸거나, 기존 필드를 조합하여 새로운 값을 가진 필드를 만들 수 있습니다. SQL의 `SELECT` 절과 가장 유사합니다.

  * **구문:** 필드 포함/제외 규칙은 `find()`의 프로젝션과 유사하지만, 다양한 \*\*표현식(Expressions)\*\*을 사용하여 새로운 필드를 동적으로 생성할 수 있다는 점이 강력합니다.

**이커머스 예시: 위 `$group` 스테이지의 결과를 더 보기 좋은 형태로 가공. `_id` 필드 이름을 `customer`로 바꾸고, 주문 횟수에 따라 고객 등급(`tier`) 필드 추가**

```javascript
// ... $group 스테이지 이후
{
  $project: {
    _id: 0, // 기존 _id 필드는 제거
    customer: "$_id", // _id 필드의 값을 customer라는 새 이름으로 지정
    totalSpent: "$totalAmountSpent",
    count: "$orderCount",
    tier: {
      $switch: { // 조건에 따라 다른 값을 부여
        branches: [
          { case: { $gte: ["$orderCount", 10] }, then: "VIP" },
          { case: { $gte: ["$orderCount", 5] }, then: "Gold" }
        ],
        default: "Silver"
      }
    }
  }
}
```

-----

### `$sort`: 결과를 정렬하는 정리 전문가

`$sort` 스테이지는 이전 스테이지에서 넘어온 도큐먼트들을 특정 필드 값을 기준으로 정렬합니다. SQL의 `ORDER BY` 절에 해당합니다.

  * **구문:** 정렬할 필드와 순서를 지정합니다. `1`은 오름차순(Ascending), `-1`은 내림차순(Descending)입니다.

**이커머스 예시: 최종 결과를 고객의 총 주문 금액(`totalSpent`)이 높은 순으로 정렬**

```javascript
// ... $project 스테이지 이후
{
  $sort: {
    totalSpent: -1 // 총 주문 금액을 기준으로 내림차순 정렬
  }
}
```

이 네 가지 핵심 스테이지를 조합하면, "지난달 우수 고객 목록을 총 구매액 순으로 뽑아줘"와 같은 복잡한 비즈니스 요구사항을 단 하나의 데이터베이스 쿼리로 해결할 수 있습니다. 다음 절에서는 배열 데이터를 효과적으로 다루는 `$unwind`와 다른 컬렉션의 데이터를 결합하는 `$lookup` 스테이지에 대해 알아보겠습니다.