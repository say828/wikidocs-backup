## 01\. 단일 필드, 복합 필드, 멀티키 인덱스의 내부 구조

B-Tree라는 기본 원리를 바탕으로, MongoDB는 다양한 쿼리 패턴에 대응하기 위해 여러 종류의 인덱스를 제공합니다. 가장 기본이 되면서도 핵심적인 세 가지 인덱스 유형인 **단일 필드**, **복합 필드**, 그리고 **멀티키** 인덱스의 구조와 사용법을 이해하는 것은 최적의 인덱스를 설계하기 위한 필수 과정입니다.

-----

### 단일 필드 인덱스 (Single Field Index)

가장 기본적인 형태의 인덱스로, 이름 그대로 **단 하나의 필드**에 대해 생성됩니다. B-Tree는 해당 필드의 값을 기준으로 정렬됩니다.

  * **용도:** 특정 필드 하나를 조건으로 하는 조회나 정렬 작업의 성능을 향상시킵니다.
  * **구문:** `createIndex()` 메소드에 인덱스를 생성할 필드를 지정하고, 정렬 순서로 오름차순(`1`) 또는 내림차순(`-1`)을 부여합니다.
    ```javascript
    // orders 컬렉션의 customerId 필드에 대해 오름차순 인덱스 생성
    db.orders.createIndex({ customerId: 1 })
    ```
  * **내부 동작:** 위 인덱스가 생성되면, B-Tree의 리프 노드들은 `customerId` 값으로 정렬된 항목들을 갖게 됩니다. 각 항목은 `["user001", <문서A의 포인터>]`, `["user001", <문서B의 포인터>]`, `["user002", <문서C의 포인터>]` 와 같은 형태가 됩니다. 이를 통해 특정 고객의 주문을 매우 빠르게 찾을 수 있습니다.
  * **정렬 순서의 의미:** 단일 필드 인덱스에서 정렬 순서는 동등 조건(`{ customerId: "user001" }`) 검색 시 성능에 영향을 주지 않습니다. MongoDB는 어느 방향으로든 인덱스를 효율적으로 탐색할 수 있기 때문입니다. 하지만, 쿼리에 `sort()`가 포함될 경우 중요해집니다. `sort({ customerId: 1 })` 쿼리는 위 인덱스를 사용하여 별도의 정렬 과정 없이 결과를 즉시 반환할 수 있어 매우 효율적입니다.

-----

### 복합 필드 인덱스 (Compound Index)

**두 개 이상의 필드를 지정된 순서대로 결합**하여 하나의 인덱스로 만드는, 매우 강력하고 중요한 인덱스입니다.

  * **핵심 원리 (필드 순서):** 복합 인덱스에서 필드의 순서는 절대적입니다. 전화번호부를 생각하면 쉽습니다. 전화번호부는 '성(Last Name)'으로 먼저 정렬된 후, 동일한 성 내에서 '이름(First Name)'으로 다시 정렬됩니다. 이 전화번호부로 '김씨'를 찾는 것은 매우 빠르지만, 이름이 '민준'인 사람을 찾는 것은 처음부터 끝까지 뒤져야 하므로 매우 비효율적입니다.
  * 마찬가지로 `{ a: 1, b: 1, c: 1 }` 순서로 생성된 복합 인덱스는 다음의 쿼리들을 효율적으로 지원합니다.
      * `a` 필드에 대한 쿼리
      * `a` 필드와 `b` 필드에 대한 쿼리
      * `a`, `b`, `c` 필드 모두에 대한 쿼리
  * 하지만 인덱스의 **접두사(prefix)** 에 해당하지 않는 `b` 필드 단독, `c` 필드 단독, 또는 `b`와 `c` 필드에 대한 쿼리는 이 인덱스를 효율적으로 사용할 수 없습니다.

**이커머스 예시:** 특정 고객(`customerId`)의 완료된(`status`) 주문을 최신순(`orderDate`)으로 자주 조회해야 하는 경우.

```javascript
// 고객ID(오름차순), 주문상태(오름차순), 주문일(내림차순) 순서로 복합 인덱스 생성
db.orders.createIndex({ customerId: 1, status: 1, orderDate: -1 })
```

  * **이 인덱스의 최적 활용 사례:**
    ```javascript
    // 인덱스 순서와 완벽하게 일치하는 쿼리
    db.orders.find({
      customerId: "user001",
      status: "COMPLETED"
    }).sort({ orderDate: -1 })
    ```
    위 쿼리는 B-Tree에서 `user001`을 찾고, 그 안에서 `COMPLETED`를 찾은 뒤, 이미 `orderDate`로 역정렬된 항목들을 순서대로 읽기만 하면 됩니다. 이는 MongoDB가 수행할 수 있는 가장 빠른 작업 중 하나입니다.

-----

### 멀티키 인덱스 (Multikey Index)

멀티키 인덱스는 우리가 직접 생성하는 특별한 타입의 인덱스가 아닙니다. **인덱스를 생성하는 필드의 값이 배열일 경우, MongoDB가 자동으로 생성하는 인덱스의 동작 방식**을 의미합니다.

  * **동작 방식:** 인덱싱 대상 필드가 배열이면, MongoDB는 그 배열의 **모든 요소를 위한 개별 인덱스 항목**을 생성합니다. 이 모든 항목들은 동일한 원본 도큐먼트를 가리킵니다.

**이커머스 예시:** 상품의 `tags` 배열 필드를 통해 특정 태그가 포함된 상품을 빠르게 검색해야 하는 경우.

```javascript
// tags 필드는 ["developer", "office", "mug"]와 같은 배열임
db.products.createIndex({ tags: 1 })
```

  * **내부 동작:** `tags`가 `["developer", "office"]`인 상품 도큐먼트가 있다면, MongoDB는 B-Tree에 아래 두 개의 항목을 만듭니다.
      * `["developer", <해당 상품 문서의 포인터>]`
      * `["office", <해당 상품 문서의 포인터>]`
  * **효과:** 이 덕분에 `db.products.find({ tags: "developer" })` 와 같이 배열 내 특정 요소를 찾는 쿼리가 인덱스를 활용하여 매우 빠르게 실행될 수 있습니다. 멀티키 인덱스가 없다면, 이 쿼리는 모든 상품을 스캔하며 `tags` 배열을 일일이 확인해야 했을 것입니다.

이 세 가지 기본 인덱스 유형의 특성과 동작 방식을 이해하는 것은, 애플리케이션의 다양한 쿼리 요구사항에 맞춰 가장 효율적인 인덱스를 설계하는 능력의 기초가 됩니다. 다음 절에서는 이렇게 설계한 인덱스를 쿼리가 실제로 잘 사용하고 있는지 과학적으로 분석하는 방법을 알아보겠습니다.