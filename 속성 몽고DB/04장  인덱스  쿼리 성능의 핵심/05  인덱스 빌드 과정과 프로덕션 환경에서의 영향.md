## 05. 인덱스 빌드 과정과 프로덕션 환경에서의 영향

인덱스를 생성하는 `createIndex()` 명령은 단순해 보이지만, 그 이면에서는 상당한 작업이 이루어집니다. 특히 이미 수억 건의 데이터가 저장된 프로덕션(운영) 환경의 컬렉션에 새로운 인덱스를 추가하는 작업은, 애플리케이션의 성능과 안정성에 직접적인 영향을 미칠 수 있는 매우 신중한 접근이 필요한 과정입니다.

---

### 인덱스 빌드 방식의 변천: 포그라운드 vs. 백그라운드

과거 MongoDB 버전(4.2 이전)에서는 인덱스 생성이 기본적으로 **포그라운드(Foreground)** 방식으로 동작했습니다. 이는 인덱스 생성이 완료될 때까지 해당 데이터베이스에 대한 모든 쓰기(write) 작업이 중단(blocking)되는 것을 의미했습니다. 대용량 컬렉션의 경우 인덱스 생성에 수십 분에서 수 시간이 걸릴 수 있었고, 이는 곧 서비스 장애로 직결되는 심각한 운영상의 문제였습니다.

이러한 문제를 해결하기 위해, 최신 MongoDB는 모든 인덱스 빌드를 기본적으로 **백그라운드(Background)** 방식으로 수행합니다.

* **백그라운드 빌드 동작 방식:**
    1.  애플리케이션은 인덱스가 생성되는 동안에도 해당 컬렉션에 대한 읽기/쓰기 작업을 계속 수행할 수 있습니다.
    2.  `mongod`는 백그라운드에서 컬렉션의 모든 도큐먼트를 스캔하여 인덱스 구조(B-Tree)를 만듭니다.
    3.  인덱스가 빌드되는 동안 발생하는 모든 쓰기 작업의 내용을 기록해 둡니다.
    4.  초기 스캔이 완료되면, 기록해 둔 변경분(delta)을 인덱스에 마저 적용하여 최신 상태를 맞춥니다.
    5.  빌드의 시작과 끝 아주 짧은 순간에만 컬렉션에 대한 배타적 락(exclusive lock)을 걸어 인덱스 상태를 최종적으로 동기화합니다.

이 방식 덕분에 서비스 중단 없이 인덱스를 추가할 수 있게 되었지만, 그렇다고 해서 프로덕션 환경에 아무런 영향이 없는 것은 아닙니다.

---

### 프로덕션 환경에서의 영향과 관리 전략

백그라운드 인덱스 빌드는 '무중단'을 보장할 뿐, '무부하'를 의미하지는 않습니다. 인덱스 빌드는 여전히 시스템 자원을 많이 소모하는 무거운 작업입니다.

* **서버 자원 사용량 급증:** `mongod` 프로세스는 컬렉션 전체를 스캔하고 새로운 인덱스 파일을 디스크에 쓰기 위해 상당한 양의 **CPU와 디스크 I/O**를 사용합니다. 이는 애플리케이션의 일반적인 쿼리 성능을 저하시켜 응답 시간을 늘릴 수 있습니다.

* **복제 지연 (Replication Lag) 발생:** 인덱스 생성 작업은 레플리카 셋의 프라이머리뿐만 아니라 모든 세컨더리 멤버에서도 동일하게 수행됩니다. 이 무거운 작업으로 인해 세컨더리 멤버들이 프라이머리의 데이터 변경 속도를 따라잡지 못하고 뒤처지는 **복제 지연**이 발생할 수 있습니다. 복제 지연이 심해지면 장애 상황 시 페일오버(failover) 시간이 길어지고, 세컨더리 읽기의 데이터 정합성에 문제가 생길 수 있어 매우 위험합니다.

#### 안전한 프로덕션 인덱스 빌드를 위한 모범 사례

1.  **오프피크(Off-Peak) 시간에 실행:** 가장 기본적이고 중요한 전략입니다. 사용자의 트래픽이 가장 적은 시간대(예: 주말 새벽)에 작업을 예약하여 애플리케이션에 미치는 영향을 최소화해야 합니다.

2.  **철저한 모니터링:** 인덱스를 빌드하는 동안 CPU, 디스크 I/O, 그리고 **특히 복제 지연**과 같은 핵심 지표를 지속적으로 모니터링해야 합니다. 이상 징후가 보이면 즉시 인덱스 빌드 작업을 중단(`db.killOp()`)할 준비가 되어 있어야 합니다.

3.  **롤링 인덱스 빌드 (Rolling Index Build):** 어떠한 성능 저하도 허용할 수 없는 매우 중요한 시스템을 위한 고급 기법입니다. 레플리카 셋 멤버를 하나씩 순회하며 인덱스를 생성하는 방식입니다.
    * 세컨더리 멤버 하나를 중지시키고, 독립 모드로 재시작하여 인덱스를 생성합니다.
    * 인덱스 생성이 완료되면 다시 레플리카 셋에 합류시켜 최신 데이터를 동기화합니다.
    * 모든 세컨더리에 대해 이 과정을 반복한 후, 마지막으로 프라이머리를 스텝다운(step down)시켜 세컨더리로 만든 뒤 동일한 작업을 수행합니다.
    * 이 방식은 운영이 매우 복잡하지만, 프라이머리의 성능에 전혀 영향을 주지 않고 인덱스를 생성할 수 있습니다. **MongoDB Atlas와 같은 완전 관리형 서비스는 이러한 복잡한 과정을 자동화하여 안전하게 인덱스를 빌드하는 기능을 제공합니다.**

인덱스는 쿼리 성능의 핵심이지만, 그 생성 과정은 섬세한 관리가 필요한 작업입니다. 이제 우리는 인덱스를 설계하고, 분석하며, 프로덕션 환경에 안전하게 배포하는 방법에 대한 모든 지식을 갖추었습니다. 이로써 데이터베이스의 읽기 성능을 책임지는 4장을 마무리하고, 다음 장에서는 데이터의 정합성을 보장하는 트랜잭션과 동시성 제어의 세계로 넘어가겠습니다.