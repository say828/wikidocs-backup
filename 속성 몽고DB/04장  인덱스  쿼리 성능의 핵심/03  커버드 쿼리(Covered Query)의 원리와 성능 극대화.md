## 03\. 커버드 쿼리(Covered Query)의 원리와 성능 극대화

`IXSCAN`을 통해 쿼리 속도를 높이는 것을 넘어, 읽기 성능을 극한까지 끌어올리는 최적화 기법이 있습니다. 바로 **커버드 쿼리(Covered Query)** 입니다. 커버드 쿼리는 쿼리에 필요한 모든 정보를 **오직 인덱스만으로** 충족시키는 쿼리를 의미합니다. 즉, MongoDB가 실제 도큐먼트가 저장된 디스크를 전혀 쳐다볼 필요 없이, 인덱스만 읽어서 쿼리를 완전히 끝낼 수 있는 상태입니다.

### 커버드 쿼리의 원리 📖

이해를 돕기 위해 도서관 비유를 다시 들어보겠습니다.

  * **일반적인 `IXSCAN`:** "MongoDB 저자의 책들이 어디 있는지 알려주세요." -\> 사서가 색인(인덱스)을 보고 책들의 위치(포인터)를 찾은 뒤, 서가로 직접 가서(`FETCH`) 책들(도큐먼트)을 가져와 건네줍니다.
  * **커버드 쿼리:** "MongoDB 저자의 책 제목과 출판 연도를 알려주세요." -\> 만약 도서관의 색인 카드(인덱스)에 책의 위치뿐만 아니라 **제목과 출판 연도 정보까지 이미 기록되어 있다면?** 사서는 서가에 갈 필요 없이, 색인 카드만 보고도 당신의 질문에 바로 답할 수 있습니다. 이것이 바로 커버드 쿼리입니다.

디스크에서 도큐먼트를 가져오는 `FETCH` 단계는 랜덤 I/O를 유발하는, 상대적으로 비용이 비싼 작업입니다. 커버드 쿼리는 이 단계를 완전히 생략함으로써, 메모리 내에서 인덱스 정보만으로 응답할 수 있기 때문에 읽기 성능을 극적으로 향상시킵니다.

### 커버드 쿼리의 조건

쿼리가 커버되려면 다음 두 가지 엄격한 조건을 모두 만족해야 합니다.

1.  쿼리에 사용된 **모든 필터 조건**이 인덱스에 포함되어 있어야 합니다.
2.  쿼리가 요청하는 \*\*모든 결과 필드(프로젝션)\*\*가 **동일한 인덱스**에 포함되어 있어야 합니다.

여기에 한 가지 중요한 함정이 있습니다. MongoDB는 기본적으로 모든 쿼리 결과에 `_id` 필드를 포함시킵니다. 따라서 만약 사용하는 인덱스에 `_id` 필드가 포함되어 있지 않다면, 쿼리가 커버되기 위해서는 **반드시 프로젝션에서 `{ _id: 0 }`을 통해 `_id` 필드를 명시적으로 제외**해야 합니다.

### 실전 예시: 상품 랭킹보드 만들기

**요구사항:** "electronics" 카테고리의 상품들을 판매량(`sales_count`)이 높은 순으로 정렬하여, 상품의 이름과 판매량만 빠르게 조회하고 싶습니다.

1.  **최적의 인덱스 생성:** 쿼리의 필터(`category`), 정렬(`sales_count`), 그리고 프로젝션(`name`)에 필요한 모든 필드를 포함하는 복합 인덱스를 생성합니다.

    ```javascript
    db.products.createIndex({ category: 1, sales_count: -1, name: 1 })
    ```

    (성능을 위해 일반적으로 동등 비교 필드(`category`) -\> 정렬 필드(`sales_count`) -\> 기타 프로젝션 필드(`name`) 순으로 구성합니다.)

2.  **커버드 쿼리 작성:**

    ```javascript
    db.products.find(
        // 1. 필터 조건은 인덱스에 포함됨
        { category: "electronics" },
        // 2. 결과 필드도 인덱스에 포함되며, _id는 명시적으로 제외
        { name: 1, sales_count: 1, _id: 0 }
    ).sort(
        // 정렬 조건도 인덱스에 포함됨
        { sales_count: -1 }
    )
    ```

### `explain()`으로 커버드 쿼리 확인하기

이 쿼리가 정말 커버되었는지는 `explain("executionStats")`를 통해 증명할 수 있습니다.

```javascript
db.products.find(...).sort(...).explain("executionStats")
```

**`explain()` 결과에서 확인해야 할 핵심 지표:**

  * **`totalDocsExamined`**: 이 값이 **`0`** 이어야 합니다. 이는 MongoDB가 쿼리를 처리하면서 실제 도큐먼트를 단 하나도 읽지 않았다는 가장 확실한 증거입니다.
  * **`winningPlan.stage`**: `IXSCAN`은 표시되지만, 그 상위 단계에 도큐먼트를 가져오는 **`FETCH` 스테이지가 없어야 합니다.**

만약 `totalDocsExamined`가 0이고 `FETCH` 스테이지가 없다면, 여러분은 성공적으로 커버드 쿼리를 만들어낸 것입니다.

### 성능 극대화와 트레이드오프

커버드 쿼리는 읽기 성능을 위한 최고의 최적화 기술입니다. 특히 대시보드, 리더보드, 실시간 통계 등 반복적으로 대량의 데이터를 읽어야 하는 기능에 적용하면 그 효과를 톡톡히 볼 수 있습니다.

하지만 트레이드오프도 존재합니다. 쿼리를 커버하기 위해 인덱스에 필드를 추가할수록 인덱스의 크기는 커집니다. 커진 인덱스는 더 많은 RAM을 소모하고, 쓰기(insert, update) 작업 시 더 많은 인덱스를 수정해야 하므로 쓰기 성능에 약간의 부하를 줄 수 있습니다. 따라서 모든 쿼리를 커버하려고 하기보다는, **애플리케이션에서 가장 중요하고 빈번하게 호출되는 읽기 쿼리**를 선별하여 전략적으로 커버드 쿼리를 적용하는 것이 현명합니다.