## 02\. 인덱스 선택성(Selectivity)과 쿼리 플랜 분석 (explain())

인덱스를 생성하는 것은 쿼리 성능 향상의 첫걸음일 뿐입니다. 우리는 '좋은' 인덱스를 만들어야 하고, 우리의 쿼리가 그 인덱스를 '올바르게' 사용하고 있는지 반드시 확인해야 합니다. 이 두 가지 목표를 달성하기 위한 핵심 개념이 바로 \*\*인덱스 선택성(Selectivity)\*\*과 \*\*쿼리 플랜 분석 도구(`explain()`)\*\*입니다.

-----

### 인덱스 선택성: '좋은' 인덱스의 조건 🎯

**인덱스 선택성**이란, 인덱스가 얼마나 효율적으로 데이터를 걸러낼 수 있는지를 나타내는 척도입니다. 선택성이 높다는 것은 인덱싱된 필드가 가진 고유한 값(Cardinality)이 많다는 의미이며, 이는 쿼리 결과의 범위를 매우 효과적으로 좁힐 수 있음을 뜻합니다.

  * **높은 선택성 (High Selectivity):** `_id`, `userId`, `email`, `orderId` 와 같이 거의 모든 값이 고유한 필드. 이런 필드에 생성된 인덱스는 특정 문서를 찾는 데 매우 효율적입니다. 마치 주민등록번호로 사람을 찾는 것과 같습니다. 단 한 번의 조회로 정확히 원하는 대상을 찾을 수 있습니다.

  * **낮은 선택성 (Low Selectivity):** `gender` (남/여), `is_deleted` (true/false), `status` (주문완료/배송중/배송완료) 와 같이 몇 안 되는 값만 반복되는 필드. 이런 필드에 단독으로 인덱스를 생성하는 것은 비효율적인 경우가 많습니다. "성별이 남성인 회원"을 인덱스로 찾으면, 전체 회원의 절반가량을 가리키게 됩니다. 이런 경우 MongoDB 쿼리 플래너는 인덱스를 사용하는 것보다 차라리 컬렉션 전체를 스캔(`COLLSCAN`)하는 것이 더 빠르다고 판단할 수 있습니다.

**핵심 전략:** 인덱스는 선택성이 높은 필드에 우선적으로 생성해야 합니다. 선택성이 낮은 필드는 단독으로 인덱싱하기보다는, 선택성이 높은 다른 필드와 함께 **복합 인덱스**의 일부로 만드는 것이 훨씬 효과적입니다.

-----

### 쿼리 플랜 분석 (`explain()`): MongoDB의 속마음 들여다보기 🕵️‍♂️

`explain()` 메소드는 우리가 작성한 쿼리를 MongoDB가 **어떻게 실행할 것인지**에 대한 상세한 계획(Query Plan)을 보여주는 강력한 진단 도구입니다. 이 도구를 통해 쿼리가 인덱스를 사용하고 있는지, 사용한다면 어떤 인덱스를 어떻게 사용하고 있는지, 비효율적인 부분은 없는지 등을 명확하게 확인할 수 있습니다.

  * **사용법:** `find()`나 `aggregate()` 쿼리 끝에 `.explain()`을 붙여 실행합니다. 상세한 실행 통계를 보려면 `"executionStats"` 모드를 사용하는 것이 좋습니다.

    ```javascript
    db.orders.find({ customerId: "user001" }).explain("executionStats")
    ```

#### `explain()` 결과의 핵심 분석 포인트

`explain()` 결과는 복잡한 JSON 문서이지만, 다음 몇 가지만 집중해서 보면 됩니다.

1.  **`queryPlanner.winningPlan.stage`**: MongoDB가 채택한 최종 실행 계획의 종류입니다.

      * **`COLLSCAN` (악당 👿):** **컬렉션 스캔**. 적절한 인덱스를 찾지 못해 컬렉션 전체를 스캔했다는 의미입니다. 대용량 컬렉션에서 `COLLSCAN`이 발견되면 즉시 해결해야 할 심각한 성능 문제입니다.
      * **`IXSCAN` (영웅 🦸):** **인덱스 스캔**. 쿼리가 인덱스를 성공적으로 사용했다는 의미입니다. 어떤 인덱스를 사용했는지(`indexName`)도 함께 표시됩니다. 이것이 우리가 원하는 결과입니다.
      * **`FETCH`**: `IXSCAN` 이후, 인덱스 포인터를 따라 디스크에서 실제 도큐먼트를 읽어오는 단계입니다.
      * **`SORT`**: 인덱스를 사용하지 못하고, 메모리에서 별도의 정렬 작업을 수행했다는 의미입니다.

2.  **`executionStats`**: 실제 쿼리 실행 통계입니다.

      * **`nReturned`**: 쿼리가 반환한 최종 도큐먼트의 수.
      * **`totalKeysExamined`**: 쿼리를 처리하기 위해 스캔한 인덱스 키의 수.
      * **`totalDocsExamined`**: 쿼리를 처리하기 위해 스캔한 도큐먼트의 수.

**이상적인 시나리오:** 완벽하게 최적화된 쿼리에서는 **`nReturned`**, **`totalKeysExamined`**, **`totalDocsExamined`** 세 값의 차이가 거의 없습니다. 이는 인덱스가 불필요한 데이터는 거의 쳐다보지도 않고, 원하는 문서로 정확하게 안내했음을 의미합니다. 만약 `totalDocsExamined`가 `nReturned`보다 현저히 높다면, 인덱스가 있더라도 선택성이 낮아 비효율적으로 동작하고 있다는 신호입니다.

### 실전 분석

`{ customerId: 1, status: 1 }` 복합 인덱스가 있다고 가정해 봅시다.

  * **좋은 쿼리:** `db.orders.find({ customerId: "user001", status: "SHIPPED" }).explain()`
      * **예상 결과:** `winningPlan.stage`는 `IXSCAN`이 되고, `totalKeysExamined`와 `nReturned` 값이 비슷하게 나옵니다.
  * **나쁜 쿼리:** `db.orders.find({ status: "SHIPPED" }).explain()`
      * **예상 결과:** `winningPlan.stage`는 `COLLSCAN`이 될 가능성이 높습니다. 복합 인덱스의 접두사(prefix)인 `customerId`가 쿼리에 없기 때문에, 인덱스를 효율적으로 사용할 수 없기 때문입니다.

`explain()`은 추측이 아닌 데이터에 기반하여 성능을 분석하고 개선할 수 있게 해주는 필수 도구입니다. "인덱스를 만들었으니 빠를 거야"라고 가정하지 마십시오. **항상 `explain()`으로 증명해야 합니다.**