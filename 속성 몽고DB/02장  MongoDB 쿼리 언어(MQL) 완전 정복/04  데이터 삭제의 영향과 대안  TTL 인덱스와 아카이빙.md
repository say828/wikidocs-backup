## 04\. 데이터 삭제의 영향과 대안: TTL 인덱스와 아카이빙

MQL의 `deleteOne()`과 `deleteMany()`는 데이터를 제거하는 직관적인 방법을 제공하지만, 대규모 프로덕션 시스템에서 데이터를 삭제하는 행위는 신중한 접근이 필요합니다. 특히 수백만 건의 도큐먼트에 영향을 미치는 `deleteMany` 연산은 데이터베이스에 상당한 부하를 주어 애플리케이션 전체의 성능에 영향을 미칠 수 있습니다.

이번 절에서는 물리적 데이터 삭제가 시스템에 미치는 영향을 분석하고, 모든 경우에 물리적 삭제가 최선은 아님을 인지하며, 더 안전하고 효율적인 대안인 **TTL 인덱스**와 **소프트 삭제/아카이빙** 전략에 대해 알아봅니다.

-----

### 물리적 삭제(`deleteMany`)의 성능 영향

대량의 도큐먼트를 물리적으로 삭제할 때, MongoDB는 내부적으로 다음과 같은 작업을 수행합니다.

1.  **삭제 대상 탐색:** 쿼리 조건에 맞는 도큐먼트를 찾기 위해 인덱스를 스캔합니다.
2.  **데이터 파일에서 제거:** 컬렉션 데이터 파일에서 해당 도큐먼트가 차지하던 공간을 제거합니다.
3.  **모든 인덱스에서 제거:** 해당 도큐먼트를 가리키던 **모든** 인덱스 항목들을 찾아 제거합니다.

이 과정, 특히 3번 작업은 상당한 I/O와 CPU 자원을 소모합니다. 컬렉션에 인덱스가 많을수록 삭제에 따르는 부하는 기하급수적으로 증가합니다. 이로 인해 라이브 서비스의 다른 쿼리들이 지연되거나, 최악의 경우 시스템 전체가 불안정해질 수 있습니다. 따라서 "데이터를 지운다"는 결정은 기술적 전략을 동반해야 합니다.

-----

### 대안 1: TTL 인덱스 - 시간에 따라 자동 소멸되는 데이터

**TTL(Time-To-Live) 인덱스**는 특정 시간이 지나면 데이터가 자동으로 삭제되어야 하는 경우를 위한 가장 우아하고 효율적인 해결책입니다. 이는 MongoDB의 백그라운드 프로세스가 주기적으로 만료된 도큐먼트를 삭제해주는 '설정하고 잊어버리는(set-and-forget)' 방식입니다.

**💡 언제 사용하는가?**
그 자체로 유효기간이 정해져 있는 데이터에 이상적입니다.

  * 웹 애플리케이션의 세션 정보
  * 비밀번호 재설정용 인증 토큰
  * IoT 센서의 시계열 데이터 (예: 최근 30일치만 보관)
  * 애플리케이션 로그 (예: 최근 7일치만 보관)

**이커머스 예시: 30분 동안만 유효한 '타임딜' 참여 자격 캐시**

```javascript
// 1. 타임딜 참여 자격을 부여할 때, 만료 시간을 기록할 필드(expireAt)를 추가합니다.
db.hotdeal_session.insertOne({
    userId: "user001",
    dealId: "DEAL_1234",
    createdAt: new Date(),
    expireAt: new Date(Date.now() + 30 * 60 * 1000) // 현재 시간 + 30분
});

// 2. expireAt 필드에 TTL 인덱스를 생성합니다.
// expireAfterSeconds를 0으로 설정하면, expireAt 필드에 명시된 시간에 정확히 만료됩니다.
db.hotdeal_session.createIndex(
    { "expireAt": 1 },
    { expireAfterSeconds: 0 }
);
```

이제 `mongod`의 TTL 스레드가 주기적으로 `hotdeal_session` 컬렉션을 스캔하여 `expireAt` 시간이 지난 도큐먼트들을 자동으로, 그리고 시스템 부하를 최소화하는 방식으로 삭제해줍니다.

-----

### 대안 2: 소프트 삭제와 아카이빙 - 비즈니스 데이터 보존

소프트 삭제(Soft Delete)는 데이터를 물리적으로 삭제하는 대신, **삭제된 것처럼 보이게 만드는 상태 플래그를 추가**하는 방식입니다.

**💡 언제 사용하는가?**
회원, 주문, 상품 등 비즈니스적으로 중요하고, 삭제 기록의 추적이 필요하며, 다른 데이터와 관계를 맺고 있는 데이터에 필수적입니다.

**이커머스 예시: 회원이 탈퇴를 요청한 경우**
물리적으로 `users` 도큐먼트를 삭제하면 이 회원이 남긴 주문, 리뷰, 문의 내역과의 관계가 끊어져 데이터 무결성에 심각한 문제가 발생합니다.

**소프트 삭제 적용:**

```javascript
// db.users.deleteOne({ _id: "user001" }) 대신...
db.users.updateOne(
    { _id: "user001" },
    { $set: { status: "DEACTIVATED", deactivatedAt: new Date() } }
);
```

**✅ 장점:**

  * **데이터 복구 및 감사:** 언제든 사용자를 복구할 수 있으며, 탈퇴 시점 등 모든 기록을 추적할 수 있습니다.
  * **안정성:** `deleteOne`보다 훨씬 빠르고 시스템 부하가 적은 `updateOne` 연산만 사용합니다.
  * **관계 유지:** 기존 주문 내역 등에서 사용자 정보를 조회할 때 "탈퇴한 사용자"로 정상적으로 표시할 수 있습니다.

**아카이빙(Archiving) 전략:**
소프트 삭제된 데이터가 많아져 활성 컬렉션(`users`)의 크기가 비대해지면, 성능에 영향을 줄 수 있습니다. 이 경우, 주기적으로 `status: "DEACTIVATED"`인 도큐먼트를 `users_archive`와 같은 별도의 '차가운(cold)' 컬렉션으로 옮기는 아카이빙 작업을 수행할 수 있습니다. 이를 통해 활성 컬렉션은 작고 빠르게 유지하면서, 모든 기록 데이터는 안전하게 보존할 수 있습니다.

결론적으로, 데이터 삭제는 비즈니스와 시스템의 특성을 모두 고려한 전략적 판단이 필요합니다. 정말 필요 없는 임시 데이터는 TTL 인덱스로 자동화하고, 중요한 비즈니스 데이터는 소프트 삭제와 아카이빙을 통해 안정적으로 관리하는 것이 성숙한 데이터 라이프사이클 관리의 핵심입니다.