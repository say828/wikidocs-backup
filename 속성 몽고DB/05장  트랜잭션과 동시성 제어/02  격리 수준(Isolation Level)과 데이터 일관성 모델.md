## 02. 격리 수준(Isolation Level)과 데이터 일관성 모델

**격리성(Isolation)**은 ACID 원칙의 'I'에 해당하며, 여러 트랜잭션이 동시에 실행될 때 서로에게 미치는 영향을 제어하는 수준을 정의합니다. 완벽한 격리는 마치 모든 트랜잭션이 순서대로 하나씩 실행되는 것처럼 보이게 하여, 동시성으로 인해 발생할 수 있는 데이터 부정합 문제를 막아줍니다. 하지만 격리 수준을 높일수록 시스템의 동시 처리 성능은 저하되는 트레이드오프가 존재합니다.

### 동시성 문제: 왜 격리가 필요한가?

격리 수준이 낮을 때 발생할 수 있는 대표적인 데이터 부정합 현상(Read Phenomena)은 세 가지가 있습니다.

1.  **더티 리드 (Dirty Read):**
    * **상황:** 트랜잭션 A가 상품의 재고를 10개에서 5개로 수정했지만, 아직 **커밋(Commit)하지 않았습니다.** 이때 트랜잭션 B가 이 상품의 재고를 읽어 '5개'라는 값을 얻어갑니다. 그 직후, 트랜잭션 A가 어떤 이유로 **롤백(Rollback)** 되어 재고는 다시 10개로 돌아갑니다.
    * **문제:** 트랜잭션 B는 **결코 존재한 적 없는 임시 데이터(재고 5개)**를 읽고 그에 기반한 결정을 내리게 됩니다.

2.  **반복 불가능한 읽기 (Non-Repeatable Read):**
    * **상황:** 트랜잭션 A가 상품의 재고를 읽었을 때 '10개'였습니다. 트랜잭션 A가 아직 끝나지 않은 상태에서, 트랜잭션 B가 이 상품의 재고를 '5개'로 수정하고 **커밋**했습니다. 이후 트랜잭션 A가 동일한 상품의 재고를 **다시 읽었더니** 이번에는 '5개'가 조회됩니다.
    * **문제:** 하나의 트랜잭션 내에서 동일한 데이터를 두 번 읽었음에도 불구하고 다른 결과가 나옵니다. 데이터의 일관성이 깨진 것입니다.

3.  **팬텀 리드 (Phantom Read):**
    * **상황:** 트랜잭션 A가 'electronics' 카테고리의 상품 수를 조회했더니 '50개'였습니다. 트랜잭션 A가 아직 끝나지 않은 상태에서, 트랜잭션 B가 'electronics' 카테고리에 속하는 **새로운 상품을 추가**하고 **커밋**했습니다. 이후 트랜잭션 A가 동일한 조건으로 상품 수를 **다시 조회**했더니 이번에는 '51개'가 나옵니다.
    * **문제:** 이전에 없던 유령(Phantom) 같은 데이터가 나타나, 범위 쿼리의 결과가 일관되지 않게 됩니다.

### MongoDB의 격리 수준과 Read Concern

MongoDB는 이러한 동시성 문제들을 제어하기 위해, 앞서 배운 **읽기 우려(Read Concern)**를 통해 표준 SQL 데이터베이스의 격리 수준에 해당하는 보장을 제공합니다.

* **Read Committed (커밋된 읽기 보장):**
    * **설명:** 더티 리드를 방지합니다. 즉, 커밋된 데이터만 읽을 수 있음을 보장합니다.
    * **MongoDB 구현:** `readConcern: "local"` 또는 `"majority"` 수준이 이 격리 수준을 보장합니다. MongoDB는 어떤 경우에도 다른 트랜잭션의 커밋되지 않은 데이터를 읽는 것을 허용하지 않으므로, **기본적으로 Read Committed 수준의 격리성을 제공**합니다.

* **Snapshot Isolation (스냅샷 격리):**
    * **설명:** 더티 리드, 반복 불가능한 읽기, 팬텀 리드를 **모두 방지**하는 매우 높은 수준의 격리성입니다.
    * **MongoDB 구현:** **멀티-도큐먼트 트랜잭션** 내에서 `readConcern: "snapshot"`을 사용할 때 이 격리 수준이 보장됩니다.
    * **동작 원리:** 트랜잭션이 `snapshot` 격리 수준으로 시작되면, MongoDB는 해당 시점에 과반수 노드에 커밋된 데이터에 대한 **포인트-인-타임 스냅샷(point-in-time snapshot)**을 생성합니다. 해당 트랜잭션 내에서 발생하는 모든 읽기 작업은 실제 데이터가 아닌 이 고정된 스냅샷을 대상으로 수행됩니다. 따라서 트랜잭션이 진행되는 동안 다른 트랜잭션이 데이터를 수정하거나 추가하고 커밋하더라도, 현재 트랜잭션은 전혀 영향을 받지 않아 완벽한 읽기 일관성을 유지할 수 있습니다.

#### 쓰기 충돌 (Write Conflict)

만약 스냅샷 격리 수준에서 실행되는 두 개의 트랜잭션 A와 B가 **동일한 도큐먼트**를 수정하려고 시도하면 어떻게 될까요? 먼저 커밋을 시도하는 트랜잭션은 성공합니다. 하지만 뒤이어 커밋을 시도하는 트랜잭션은, 자신이 데이터를 읽었던 스냅샷 시점 이후에 데이터가 이미 변경되었음을 감지하고 **쓰기 충돌(Write Conflict)** 오류를 발생시키며 실패합니다. 이 경우, 애플리케이션은 이 오류를 감지하여 트랜잭션 전체를 재시도하는 로직을 구현해야 합니다.

### 요약

| 격리 수준 | Dirty Read | Non-Repeatable Read | Phantom Read | MongoDB Read Concern |
| :--- | :---: | :---: | :---: | :--- |
| Read Uncommitted | 허용 | 허용 | 허용 | (지원 안 함) |
| Read Committed | **방지** | 허용 | 허용 | `local`, `majority` (트랜잭션 외부) |
| Snapshot | **방지** | **방지** | **방지** | `snapshot` (트랜잭션 내부) |

결론적으로, 일반적인 단일 쿼리는 MongoDB의 기본 설정만으로도 충분히 안정적인 Read Committed 수준을 보장합니다. 그리고 가장 높은 수준의 데이터 정합성과 격리성이 요구되는 복잡한 비즈니스 로직을 위해서는, 멀티-도큐먼트 트랜잭션과 `snapshot` 읽기 우려를 사용하여 동시성 관련 문제를 완벽하게 차단할 수 있습니다.