## 01. 읽기 우려(Read Concern)와 쓰기 우려(Write Concern)의 작동 원리

MongoDB와 같은 분산 데이터베이스 시스템에서 '데이터를 쓴다'거나 '읽는다'는 행위는 단일 서버에서처럼 단순하지 않습니다. 여러 서버로 구성된 레플리카 셋(Replica Set) 환경에서는 다음과 같은 질문에 답해야 합니다.

* **쓰기(Write):** "내 쓰기 작업이 **몇 대의 서버에** 복제되었을 때 '성공'으로 간주할 것인가?"
* **읽기(Read):** "내가 읽는 데이터는 **어떤 수준의 일관성**을 보장하는 데이터인가?"

이 질문들에 대한 답을 제어하는 것이 바로 **쓰기 우려(Write Concern)**와 **읽기 우려(Read Concern)**입니다. 이 두 설정은 애플리케이션의 요구사항에 맞춰 데이터의 내구성과 일관성을 성능과 맞바꾸는 중요한 튜닝 노브(tuning knob) 역할을 합니다.

---

### 쓰기 우려 (Write Concern): 데이터 내구성을 위한 보증서 💾

**쓰기 우려**는 쓰기 작업에 대해 MongoDB로부터 어느 수준의 확인(acknowledgment)을 받을지를 결정합니다. 즉, 내 데이터가 얼마나 안전하게 저장되었는지에 대한 보증 수준입니다.

택배 발송에 비유해 봅시다.

* `w: 0` (사용 금지): 택배를 우체통에 넣고 그냥 가버립니다. 접수됐는지, 분실됐는지 확인하지 않습니다. 가장 빠르지만, 데이터 유실 위험이 매우 큽니다.
* `w: 1` (기본값): 접수 창구(프라이머리) 직원에게 택배를 건네고 접수증을 받습니다. 최소한 프라이머리 서버에는 데이터가 기록되었음을 보장합니다. 빠르지만, 직원이 접수증을 주자마자 지점에 불이 나면(프라이머리 서버 장애) 택배는 분실될 수 있습니다.
* `w: "majority"` (가장 안전): 직원이 접수증을 줄 뿐만 아니라, "이 택배의 정보가 과반수 이상의 지역 물류센터(레플리카 셋 멤버 과반수) 전산망에 등록되었습니다"라는 확인까지 해주는 것을 기다립니다. 이제 본 지점에 불이 나더라도 다른 지점에 기록이 남아있으므로 택배는 절대 분실되지 않습니다.

**주요 쓰기 우려 수준:**

| 수준 | 설명 | 장점 | 단점 |
| --- | --- | --- | --- |
| `w: 1` | **기본값.** 프라이머리 노드의 메모리에 기록되면 즉시 성공으로 응답합니다. | 빠른 쓰기 속도 | 프라이머리 장애 시, 아직 세컨더리로 복제되지 않은 데이터는 롤백되어 유실될 수 있음 |
| `w: "majority"` | 레플리카 셋의 **투표 가능 멤버 중 과반수**의 저널에 기록되었을 때 성공으로 응답합니다. | 최고의 데이터 내구성. 프라이머리 장애 및 새로운 리더 선출 후에도 데이터가 유실되지 않음을 보장. **트랜잭션의 필수 조건.** | 프라이머리가 과반수 멤버들의 응답을 기다려야 하므로 쓰기 지연 시간(latency) 증가 |

---

### 읽기 우려 (Read Concern): 데이터 일관성을 위한 스냅샷 📸

**읽기 우려**는 읽기 작업이 어떤 버전의 데이터를 반환해야 하는지를 지정합니다. 즉, "내가 지금 읽는 데이터가 얼마나 '확정된' 데이터인가?"를 결정합니다.

회사의 재무 보고서 열람에 비유해 봅시다.

* `"local"`: CFO의 책상 위에 있는 보고서 초안(프라이머리의 최신 데이터)을 바로 읽습니다. 가장 최신 정보이지만, 아직 이사회 승인을 받지 않아 수정될 수 있는 '더티(dirty)' 데이터일 수 있습니다.
* `"majority"`: 이사회 과반수의 승인을 거친 확정된 버전의 보고서(과반수 노드에 복제된 데이터)를 읽습니다. CFO가 방금 수정했지만 아직 승인되지 않은 내용은 보이지 않을 수 있지만, 이 보고서의 내용은 절대 번복되지 않습니다.
* `"snapshot"`: 내가 보고서를 열람하기 시작한 시점에 과반수 승인을 받은 버전을 복사하여, 그 복사본(스냅샷)만 계속 봅니다. 내가 읽는 동안 이사회에서 새로운 버전을 승인하더라도, 내 보고서의 내용은 처음부터 끝까지 일관되게 유지됩니다.

**주요 읽기 우려 수준:**

| 수준 | 설명 | 장점 | 단점 |
| --- | --- | --- | --- |
| `"local"` | **기본값.** 프라이머리가 가진 가장 최신 버전의 데이터를 반환합니다. | 가장 빠른 읽기 속도 | 드물지만, 프라이머리 장애 시 롤백될 가능성이 있는 데이터를 읽을 수 있음 |
| `"available"` | 샤딩 환경에서 사용되며, 어떤 데이터든 가장 가깝고 가능한 노드에서 읽습니다. | 빠른 속도, 낮은 일관성 | 데이터가 과반수에 복제되었는지 보장하지 않음 |
| `"majority"` | 과반수 멤버에 복제된 것이 확인된 데이터만 반환합니다. | '더티 리드'를 방지. 롤백되지 않을 데이터임을 보장하여 데이터 정합성이 중요한 읽기에 사용. | 프라이머리가 데이터의 과반수 복제 여부를 확인해야 하므로 약간의 지연 시간 발생 가능 |
| `"snapshot"` | **멀티-도큐먼트 트랜잭션 내에서만** 사용 가능. 특정 시점의 데이터 스냅샷을 제공하여, 트랜잭션 내의 모든 읽기가 완벽하게 일관된 데이터를 보도록 보장. | 최고 수준의 일관성과 격리성(Isolation)을 제공. **ACID의 'I'를 보장.** | 트랜잭션 오버헤드 발생 |

### 트랜잭션과의 관계

앞 절에서 살펴본 멀티-도큐먼트 트랜잭션이 완벽한 ACID를 보장하기 위해서는, 이 두 가지 우려 수준이 반드시 특정 레벨 이상으로 설정되어야 합니다.

* `writeConcern: { w: "majority" }`는 트랜잭션의 **지속성(Durability)**을 보장합니다.
* `readConcern: { level: "snapshot" }`은 트랜잭션의 **고립성(Isolation)**을 보장합니다.

결론적으로, 쓰기 우려는 **내가 쓴 데이터의 안전**에 대한 것이고, 읽기 우려는 **내가 읽는 데이터의 신뢰**에 대한 것입니다. 애플리케이션의 각 기능이 요구하는 내구성과 일관성의 수준을 정확히 파악하고, 그에 맞는 우려 수준을 선택하는 것이 신뢰할 수 있는 시스템을 구축하는 핵심입니다.