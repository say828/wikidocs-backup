## 04\. 트랜잭션 대안: 두 단계 커밋(Two-Phase Commits) 패턴 구현

이제 MongoDB는 네이티브 ACID 트랜잭션을 완벽하게 지원하지만, 이 기능이 도입되기 전까지 개발자들은 데이터 정합성을 보장하기 위해 애플리케이션 레벨에서 다양한 창의적인 패턴을 고안해 사용했습니다. 그중 가장 대표적인 것이 바로 **두 단계 커밋(Two-Phase Commit, 2PC) 패턴**입니다.

이 애플리케이션 수준의 패턴은 MongoDB가 샤드 클러스터에서 사용하는 내부 분산 트랜잭션 프로토콜과 이름은 같지만, 구현의 주체가 데이터베이스가 아닌 애플리케이션이라는 점에서 다릅니다. 이 패턴은 네이티브 트랜잭션이 적합하지 않은 특정 시나리오, 특히 외부 시스템과의 연동이 필요할 때 여전히 유용한 대안이 될 수 있습니다.

-----

### 두 단계 커밋 패턴의 개념

이 패턴의 핵심 아이디어는, 최종 데이터 변경을 즉시 실행하는 대신, 작업을 \*\*준비(Prepare)\*\*와 \*\*실행(Commit)\*\*의 두 단계로 나누고, 중앙의 '트랜잭션 문서'를 통해 전체 과정의 상태를 추적하는 것입니다.

1.  **1단계: 준비 (Pending 상태)**

      * 먼저, `transactions`와 같은 별도 컬렉션에 현재 작업의 상태를 `pending`으로 기록하는 트랜잭션 문서를 생성합니다.
      * 실제 데이터를 변경하는 대신, 변경을 위한 '예약' 또는 '보류' 조치를 취합니다. 예를 들어, 상품 재고를 직접 차감하는 대신, 해당 수량만큼을 '판매 보류' 상태로 설정합니다. 사용자의 장바구니에서 상품을 삭제하는 대신, 상태를 '결제 진행 중'으로 변경합니다.
      * 이 모든 보류 조치에 대한 참조를 트랜잭션 문서에 기록합니다.

2.  **2단계: 커밋 (Applied/Committed 상태)**

      * 모든 '준비' 작업이 성공적으로 완료되면, 트랜잭션 문서의 상태를 `pending`에서 `applied`로 **원자적으로 변경**합니다. 이 상태 변경이 바로 되돌릴 수 없는 '커밋 포인트'가 됩니다.
      * 이 커밋이 완료되면, 별도의 백그라운드 작업자(worker)가 `applied` 상태의 트랜잭션 문서를 찾아, 보류되었던 모든 조치를 실제 데이터에 최종적으로 반영합니다. (예: '판매 보류'된 재고를 실제 차감하고, '결제 진행 중'인 장바구니 아이템을 삭제합니다.)

**실패와 복구:** 만약 1단계 '준비' 과정 중 어느 한 곳에서라도 실패가 발생하면, 트랜잭션은 `pending` 상태에 머무르게 됩니다. 별도의 복구 프로세스(주기적으로 실행되는 배치 잡 등)가 오랫동안 `pending` 상태에 머물러 있는 트랜잭션들을 찾아, 트랜잭션 문서에 기록된 참조를 따라 모든 '보류' 조치를 원상 복구(예: '판매 보류' 해제)하고, 트랜잭션의 상태를 `canceled`로 변경합니다.

-----

### 실전 예시: 외부 결제 시스템 연동

이 패턴은 특히 네이티브 트랜잭션이 포괄할 수 없는 **외부 시스템 API 호출**이 포함된 작업에서 진가를 발휘합니다. 예를 들어, 사용자가 주문을 생성하고 외부 PG(Payment Gateway)사를 통해 결제하는 시나리오입니다.

1.  **주문 생성 및 '준비':** 사용자가 '결제하기' 버튼을 누르면, 애플리케이션은 `orders` 컬렉션에 `status: "pending"` 상태의 주문 문서를 생성하고, 관련 상품의 재고를 '보류' 상태로 바꿉니다.
2.  **외부 시스템 호출:** 애플리케이션은 이 `orderId`를 가지고 외부 PG사에 결제를 요청합니다.
3.  **결제 결과 수신 및 '커밋':** PG사로부터 결제 성공 웹훅(webhook) 알림을 받으면, `orders` 문서의 상태를 `pending`에서 `confirmed`로 원자적으로 변경합니다. **이것이 커밋 포인트입니다.**
4.  **최종 처리:** 백그라운드 작업자가 `status: "confirmed"`인 주문들을 찾아 재고를 최종 차감하고, 배송 준비를 시작합니다.

만약 2번 단계에서 PG사 결제가 실패하거나, 웹훅 알림이 오지 않으면 주문은 계속 `pending` 상태로 남아있게 되고, 복구 프로세스가 이를 감지하여 보류했던 재고를 원상 복구하고 주문 상태를 `canceled`로 변경합니다.

### 네이티브 트랜잭션 vs. 두 단계 커밋 패턴

| 구분 | 네이티브 트랜잭션 | 두 단계 커밋 패턴 (애플리케이션) |
| :--- | :--- | :--- |
| **장점** | ㆍ데이터베이스가 ACID를 완벽 보장<br>ㆍ상대적으로 간단한 애플리케이션 코드 | ㆍ외부 시스템 연동 가능<br>ㆍ락(Lock) 점유 시간이 짧거나 없음<br>ㆍ장시간 실행되는 작업에 적용 가능 |
| **단점** | ㆍ외부 시스템을 포함할 수 없음<br>ㆍ락으로 인한 성능 저하 가능성<br>ㆍ장시간 실행 시 타임아웃 위험 | ㆍ애플리케이션 로직이 매우 복잡해짐<br>ㆍ상태 관리를 위한 추가 컬렉션 필요<br>ㆍ복구/정리 로직을 직접 구현해야 함 |
| **일관성** | 강력한 일관성 (Strong Consistency) | 결과적 일관성 (Eventual Consistency) |

결론적으로, 현대의 MongoDB 환경에서는 데이터베이스 **내부의** 원자성 보장이 필요할 경우 **네이티브 트랜잭션**을 사용하는 것이 표준이자 가장 권장되는 방법입니다. 애플리케이션 레벨의 두 단계 커밋 패턴은 외부 시스템 연동과 같이 네이티브 트랜잭션의 범위를 벗어나는 특수한 고급 시나리오를 위한 대안적인 아키텍처 패턴으로 이해해야 합니다. 이로써 데이터의 정합성을 보장하는 5장을 마무리합니다.