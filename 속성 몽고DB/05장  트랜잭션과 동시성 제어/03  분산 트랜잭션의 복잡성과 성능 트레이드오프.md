## 03. 분산 트랜잭션의 복잡성과 성능 트레이드오프

MongoDB가 강력한 멀티-도큐먼트 ACID 트랜잭션을 제공한다는 사실은 데이터 정합성이 중요한 애플리케이션에 큰 이점입니다. 하지만 "그렇다면 모든 작업을 트랜잭션으로 감싸면 가장 안전하지 않을까?"라고 생각한다면 큰 오산입니다. 트랜잭션, 특히 여러 서버(샤드)에 걸쳐 실행되는 **분산 트랜잭션**은 상당한 수준의 복잡성과 성능 비용을 수반합니다.

이번 절에서는 트랜잭션의 이면에 숨겨진 비용을 이해하고, 언제 트랜잭션을 사용해야 하며 또 언제 피해야 하는지에 대한 아키텍트 관점의 지침을 제시합니다.

---

### 분산 트랜잭션의 내부 동작: 2단계 커밋 (Two-Phase Commit)

하나의 레플리카 셋(단일 샤드) 내에서 실행되는 트랜잭션도 오버헤드가 있지만, 트랜잭션이 여러 샤드에 분산된 도큐먼트들을 수정해야 할 때 그 복잡성은 배가됩니다. MongoDB는 이러한 분산 트랜잭션의 원자성을 보장하기 위해 **2단계 커밋(Two-Phase Commit, 2PC)** 이라는 표준 프로토콜을 사용합니다.

이 과정을 여러 사람이 함께 계약서에 서명하는 것에 비유할 수 있습니다.

1.  **1단계: 준비 (Prepare / Voting Phase)**
    * 트랜잭션 코디네이터(변호사 역할, 보통 `mongos`가 담당)가 트랜잭션에 관련된 모든 샤드(계약 참여자)에게 묻습니다. "이 계약 내용대로 서명할 준비가 되었습니까? 만약 내가 최종 사인을 요청하면 반드시 이행할 수 있음을 보장합니까?"
    * 각 샤드는 요청받은 작업을 실제로 수행할 수 있는지 확인하고, 필요한 리소스에 락(lock)을 겁니다. 그리고 코디네이터에게 "네, 준비되었습니다" 또는 "아니오, 불가능합니다" 라고 응답합니다.

2.  **2단계: 커밋 또는 중단 (Commit / Abort Phase)**
    * **만약 모든 샤드**가 "준비됨"이라고 응답했다면, 코디네이터는 모든 샤드에게 "최종 커밋(서명) 하시오"라는 명령을 내립니다. 각 샤드는 변경 사항을 영구적으로 적용하고 락을 해제합니다. 트랜잭션은 성공적으로 완료됩니다.
    * **만약 단 하나의 샤드라도** "불가능"이라고 응답하거나 시간 초과가 발생하면, 코디네이터는 모든 샤드에게 "이 계약은 무효이니 모두 중단(파기) 하시오"라는 명령을 내립니다. 각 샤드는 모든 변경 사항을 롤백하고 락을 해제합니다. 트랜잭션은 실패합니다.

이처럼 2단계 커밋은 모든 참여자가 만장일치로 동의해야만 트랜잭션을 성공시키는 보수적인 방식입니다. 하지만 이 과정에서 코디네이터와 모든 샤드 간에 여러 번의 네트워크 통신이 발생하므로, 단일 샤드 트랜잭션이나 일반적인 쓰기 작업에 비해 상당한 **지연 시간(Latency)** 증가를 유발합니다.

---

### 성능 트레이드오프

트랜잭션을 사용하면 다음과 같은 성능 비용을 감수해야 합니다.

* **지연 시간 (Latency) 증가:** 앞서 설명한 2단계 커밋의 통신 오버헤드로 인해 쓰기 작업의 응답 시간이 길어집니다.
* **처리량 (Throughput) 감소:** 트랜잭션은 실행되는 동안 수정 대상 도큐먼트에 락을 유지합니다. 트랜잭션이 길어질수록 락이 유지되는 시간도 길어져, 다른 동시 작업들이 대기해야 하는 상황이 늘어납니다. 이는 단위 시간당 처리할 수 있는 전체 작업의 수를 감소시킵니다.
* **리소스 소모 증가:** 트랜잭션의 상태를 관리하고, 락을 유지하며, 노드 간 통신을 처리하기 위해 서버의 CPU와 메모리 자원을 추가로 소모합니다.

### 언제 트랜잭션을 사용해야 하는가?

MongoDB 데이터 아키텍처의 황금률은 다음과 같습니다.

> **"트랜잭션이 필요 없는 데이터 모델을 최우선으로 고려하라."**

1장에서 배운 임베딩 모델 등을 적극적으로 활용하여, 가급적 단일 도큐먼트의 원자성을 통해 비즈니스 로직을 해결하는 것이 가장 좋습니다. **최고의 트랜잭션은 애초에 필요 없는 트랜잭션입니다.**

그럼에도 불구하고 트랜잭션이 반드시 필요한 경우는 다음과 같습니다.

✅ **트랜잭션이 적합한 경우:**
* 비즈니스 로직상 여러 개의 독립된 도큐먼트에 대한 **'전부 아니면 전무(All-or-Nothing)' 방식의 원자성이 반드시 요구될 때.**
* 이러한 데이터 정합성 요구사항이 성능 비용보다 더 중요할 때.
* **예시:** 은행 계좌 이체(A 계좌 차감, B 계좌 증액), 주문 생성(재고 차감, 주문서 생성).

❌ **트랜잭션 안티패턴 (피해야 할 경우):**
* 단일 도큐먼트를 수정하면서 습관적으로 트랜잭션으로 감싸는 경우. (불필요한 오버헤드)
* 장시간 실행되는 대규모 배치(Batch) 작업. 트랜잭션은 짧게 실행되도록 설계되었습니다. 장기 트랜잭션은 락 경합과 타임아웃을 유발할 가능성이 매우 높습니다.

결론적으로, 멀티-도큐먼트 트랜잭션은 복잡한 작업의 데이터 정합성을 보장하는 강력한 최후의 보루와 같은 기능입니다. 하지만 그에 따르는 비용을 명확히 이해하고, 데이터 모델링을 통해 사용을 최소화하며, 꼭 필요한 핵심 경로에만 신중하게 적용하는 것이 전문가의 접근 방식입니다.