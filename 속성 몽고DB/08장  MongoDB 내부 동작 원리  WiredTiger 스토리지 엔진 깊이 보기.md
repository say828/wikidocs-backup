# 08장: MongoDB 내부 동작 원리: WiredTiger 스토리지 엔진 깊이 보기

지금까지 우리는 MongoDB를 사용하여 확장성과 가용성이 뛰어난 시스템을 '어떻게 구축하는가'에 집중했습니다. 8장에서는 시선을 더 깊은 곳으로 옮겨, MongoDB가 데이터를 디스크에 쓰고 메모리에서 관리하는 가장 근본적인 방식, 즉 **스토리지 엔진(Storage Engine)**의 내부를 들여다봅니다. 자동차의 성능이 엔진에 의해 결정되듯, 데이터베이스의 성능 특성은 스토리지 엔진에 의해 좌우됩니다.

이 장에서는 현대 MongoDB의 심장인 **WiredTiger 스토리지 엔진**의 아키텍처를 해부하고, 메모리와 디스크의 상호작용, 동시성 제어 메커니즘, 데이터 압축 및 복구 원리를 이해함으로써, MongoDB 성능의 근원을 파악하고 전문가 수준의 튜닝을 위한 통찰력을 얻게 될 것입니다.

---

## 00. 스토리지 엔진의 역할과 WiredTiger의 아키텍처

**스토리지 엔진**은 데이터베이스 서버 내에서 데이터의 물리적 저장과 검색을 담당하는 핵심 소프트웨어 컴포넌트입니다. 애플리케이션이 보낸 `find()`나 `updateOne()` 같은 논리적인 명령을, 실제 디스크 파일의 바이트(byte)를 읽고 쓰는 물리적인 작업으로 변환하는 역할을 수행합니다.

* **주요 책임:**
    * **데이터 CRUD:** 디스크 상에서 도큐먼트를 생성, 읽기, 수정, 삭제하는 모든 물리적 작업을 처리합니다.
    * **동시성 제어 (Concurrency Control):** 여러 클라이언트가 동시에 데이터에 접근할 때 데이터가 깨지지 않도록 제어합니다. (예: 잠금(Locking) 메커니즘)
    * **캐싱 (Caching):** 빠른 응답을 위해 자주 사용하는 데이터를 디스크가 아닌 메모리에 보관하고 관리합니다.
    * **데이터 내구성 (Durability):** 서버가 갑자기 다운되어도 데이터가 유실되지 않도록 보장합니다. (예: 저널링, 체크포인트)
    * **데이터 압축 (Compression):** 디스크 공간을 절약하기 위해 데이터를 압축하여 저장합니다.

MongoDB는 스토리지 엔진을 교체할 수 있는 플러그형(pluggable) 아키텍처를 가지고 있으며, 3.2 버전부터 **WiredTiger**가 기본 스토리지 엔진으로 채택되었습니다. WiredTiger는 이전의 MMAPv1 엔진에 비해 동시성과 처리량 측면에서 비약적인 발전을 이루었습니다.

### WiredTiger 아키텍처 조감도

WiredTiger는 고성능 동시 다중 사용자 환경을 위해 설계된 현대적인 스토리지 엔진이며, 그 핵심 아키텍처는 다음과 같은 요소들로 구성됩니다.



#### 1. 문서 레벨 동시성 제어 (Document-Level Concurrency Control)
WiredTiger의 가장 큰 특징 중 하나입니다. 이전 MMAPv1 엔진이 컬렉션 전체에 락(lock)을 걸었던 것과 달리, WiredTiger는 **문서 레벨**에서만 락을 사용합니다. 이는 한 클라이언트가 특정 문서를 수정하는 동안, 다른 클라이언트들은 동일한 컬렉션의 **다른 문서들**에 자유롭게 읽기/쓰기 작업을 수행할 수 있음을 의미합니다. 이 덕분에 다중 코어 CPU 환경에서 쓰기 처리량이 극적으로 향상되었습니다. 이 메커니즘의 기반에는 **MVCC(Multi-Version Concurrency Control)**라는 기술이 있습니다. (다음 절에서 자세히 다룹니다.)

#### 2. 내부 캐시 (In-Memory Cache)
WiredTiger는 운영체제(OS)의 파일 시스템 캐시와는 별개로, 자신만의 적극적인 **내부 캐시**를 메모리에 유지하고 관리합니다. 서버 RAM의 상당 부분(기본적으로 `(RAM - 1GB)의 50%`)을 이 캐시로 사용하여, 디스크 I/O를 최소화하고 대부분의 읽기 작업을 메모리 내에서 처리하려고 시도합니다. MongoDB 서버의 RAM이 많을수록 성능이 좋아지는 가장 직접적인 이유입니다.

#### 3. 저널링 (Journaling / Write-Ahead Log, WAL)
데이터의 내구성을 보장하기 위한 안전장치입니다. 쓰기 작업이 발생하면, WiredTiger는 데이터를 실제 데이터 파일에 쓰기 전에, 그 변경 내역을 먼저 디스크 상의 **저널 파일**에 순차적으로 기록합니다. 이를 WAL(Write-Ahead Logging)이라고 부릅니다. 저널에 대한 쓰기는 매우 빠릅니다.
만약 서버가 갑작스럽게 다운되더라도, 재시작 시 이 저널 파일을 읽어 마지막으로 성공했던 작업 이후의 기록들을 재현(replay)함으로써 데이터를 일관된 상태로 복구할 수 있습니다.

#### 4. 체크포인트 (Checkpoint)
메모리(내부 캐시)에만 반영된 '더티(dirty)' 데이터들을 실제 영구적인 디스크 데이터 파일에 기록하는 과정입니다. WiredTiger는 기본적으로 60초마다, 또는 저널 데이터가 일정량 이상 쌓였을 때 **체크포인트**를 생성합니다. 체크포인트가 생성되면, 그 이전의 데이터는 디스크에 안전하게 기록되었음이 보장되므로, 오래된 저널 파일들을 삭제할 수 있게 됩니다.

**쓰기 작업의 전체 흐름 요약:**
1.  쓰기 요청 발생
2.  변경 내역을 **저널(WAL)** 파일에 기록 (내구성 확보)
3.  변경 사항을 **내부 캐시**의 도큐먼트에 적용 (빠른 읽기 지원)
4.  클라이언트에 성공 응답 전송
5.  (백그라운드에서) 주기적인 **체크포인트**가 내부 캐시의 내용을 최종 **데이터 파일**에 기록

이처럼 WiredTiger는 메모리 캐시를 적극적으로 활용하여 성능을 극대화하는 동시에, 저널링과 체크포인트를 통해 예기치 않은 장애 상황에서도 데이터의 내구성을 보장하는 정교한 아키-텍처를 가지고 있습니다.