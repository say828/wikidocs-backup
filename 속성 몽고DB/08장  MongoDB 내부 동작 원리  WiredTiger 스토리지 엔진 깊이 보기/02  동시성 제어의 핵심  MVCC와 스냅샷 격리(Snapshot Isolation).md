## 02. 동시성 제어의 핵심: MVCC와 스냅샷 격리(Snapshot Isolation)

수백, 수천 개의 클라이언트가 동시에 데이터베이스에 읽고 쓰는 고성능 시스템에서, 어떻게 데이터의 일관성을 유지하면서도 서로의 작업을 방해하지 않고 빠르게 처리할 수 있을까요? 이 어려운 동시성 제어(Concurrency Control) 문제를 해결하는 것이 스토리지 엔진의 핵심 역할 중 하나입니다.

전통적인 데이터베이스는 '잠금(Locking)'을 통해 이 문제를 해결했습니다. 한 쓰레드가 데이터를 수정하는 동안 다른 쓰레드가 접근하지 못하도록 문을 잠그는 방식입니다. 하지만 이 방식은 내가 작업을 마칠 때까지 다른 모두가 기다려야 하므로, 동시성이 높은 환경에서는 성능 저하의 주된 원인이 됩니다.

WiredTiger는 이 문제를 훨씬 더 우아하고 효율적으로 해결하기 위해 **MVCC(Multi-Version Concurrency Control, 다중 버전 동시성 제어)**라는 현대적인 기법을 사용합니다.

---

### MVCC의 작동 원리: 시간을 여행하는 데이터

MVCC의 핵심 아이디어는 **"데이터를 덮어쓰지 않고, 새로운 버전을 만든다"**는 것입니다.

**Google Docs 문서 공동 작업**을 상상해 봅시다.
* 내가 문서를 읽기 시작한 시점(오전 10:00)에, 시스템은 나에게 '오전 10:00 버전'의 문서 스냅샷을 제공합니다.
* 내가 이 문서를 읽는 동안, 다른 동료가 들어와 문서를 수정하고 저장합니다.
* 동료의 수정 사항은 내가 보고 있는 '오전 10:00 버전'에 영향을 주지 않습니다. 대신 시스템은 '오전 10:01 버전'이라는 새로운 버전을 만들어 동료의 변경 사항을 저장합니다.
* 나는 다른 사람의 작업에 전혀 방해받지 않고, 처음부터 끝까지 일관된 '오전 10:00 버전'의 문서를 읽을 수 있습니다.

MVCC는 바로 이 원리를 데이터베이스에 적용한 것입니다. 어떤 데이터에 대한 업데이트가 발생하면, WiredTiger는 기존 데이터를 직접 수정하는 대신, 변경 사항이 적용된 데이터의 **새로운 버전**을 생성하고 내부적으로 타임스탬프를 기록합니다.



이 방식의 가장 큰 장점은 **"읽기는 쓰기를 막지 않고, 쓰기는 읽기를 막지 않는다"**는 것입니다.
* **읽기 작업:** 특정 시점의 스냅샷을 읽기 때문에, 동시에 진행되는 쓰기 작업의 잠금(lock)을 기다릴 필요가 없습니다.
* **쓰기 작업:** 새로운 버전을 만들기만 하면 되므로, 해당 데이터를 읽고 있는 다른 작업이 끝날 때까지 기다릴 필요가 없습니다.

이러한 특성 덕분에 WiredTiger는 매우 높은 수준의 동시성을 달성할 수 있습니다.

---

### 스냅샷 격리 (Snapshot Isolation)와의 관계

MVCC는 메커니즘이고, 이 메커니즘을 통해 구현되는 격리 수준이 바로 5장에서 배웠던 **스냅샷 격리(Snapshot Isolation)**입니다.

1.  읽기 작업이 시작되면, WiredTiger는 해당 작업에 대한 '읽기 타임스탬프'를 할당합니다.
2.  데이터를 읽을 때, WiredTiger는 여러 버전의 데이터 중에서 이 '읽기 타임스탬프'보다 앞서면서, 가장 최신인 버전을 찾아서 반환합니다.
3.  결과적으로, 해당 읽기 작업은 특정 과거 시점의 일관된 데이터 스냅샷을 보게 되는 것입니다. 트랜잭션 내에서 `readConcern: "snapshot"`이 동작할 수 있는 것도 바로 이 MVCC 메커니즘 덕분입니다.

물론, 데이터베이스가 모든 과거 버전을 무한정 저장할 수는 없습니다. WiredTiger의 백그라운드 프로세스는 더 이상 어떤 활성 트랜잭션도 참조하지 않는 오래된 버전의 데이터들을 주기적으로 정리하는 **가비지 컬렉션(Garbage Collection)**을 수행하여 디스크 공간을 재활용합니다.

### 쓰기 충돌 (Write Conflicts)과 낙관적 동시성 제어

MVCC 환경에서는 두 개의 트랜잭션이 동일한 데이터를 동시에 수정하려고 할 때 **쓰기 충돌**이 발생할 수 있습니다.

1.  트랜잭션 A와 B가 둘 다 오전 10:00 시점의 스냅샷을 기반으로 작업을 시작하고, '상품 X'의 재고가 100개임을 읽습니다.
2.  트랜잭션 B가 먼저 재고를 90개로 수정하고 커밋합니다. 이제 '상품 X'의 최신 버전은 B가 만든 버전입니다.
3.  그 후 트랜잭션 A가 자신이 읽었던 100개를 기반으로 재고를 80개로 수정하고 커밋을 시도합니다.
4.  이때, WiredTiger는 트랜잭션 A가 수정하려는 데이터의 기반 버전(100개짜리 버전)이 더 이상 최신 버전이 아님을 감지합니다.

이러한 '업데이트 유실'을 방지하기 위해, WiredTiger는 트랜잭션 A를 **쓰기 충돌 오류**와 함께 실패시키고 롤백합니다. 이는 먼저 락을 거는 비관적 동시성 제어와 달리, "충돌은 드물게 발생할 것이니 일단 진행시키고, 문제가 생기면 그때 처리하자"라는 **낙관적 동시성 제어(Optimistic Concurrency Control)** 방식입니다. 이 경우, 애플리케이션은 쓰기 충돌 오류를 예외 처리하여 해당 트랜잭션을 재시도하는 로직을 구현해야 합니다.

결론적으로, MVCC는 WiredTiger의 고성능 동시 처리 능력의 근간을 이루는 핵심 기술입니다. 이 메커니즘을 이해함으로써 우리는 MongoDB가 어떻게 수많은 동시 요청 속에서도 데이터의 일관성을 유지하며 높은 처리량을 달성하는지에 대한 깊은 통찰을 얻을 수 있습니다.