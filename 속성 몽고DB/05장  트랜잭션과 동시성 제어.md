# 05장: 트랜잭션과 동시성 제어

지금까지 우리는 데이터의 구조(모델링)와 활용(쿼리, 애그리게이션, 인덱싱)에 초점을 맞춰 MongoDB의 유연성과 성능을 탐구했습니다. 이제 데이터베이스 시스템의 또 다른 핵심 축인 **일관성**과 **신뢰성**의 영역으로 넘어갑니다. 여러 개의 데이터 변경 작업이 하나의 논리적인 단위로 묶여, 모두 성공하거나 모두 실패해야만 하는 비즈니스 로직은 어떻게 보장할 수 있을까요?

이번 장에서는 이러한 데이터 정합성을 보장하는 기술인 **트랜잭션(Transaction)** 의 개념을 이해하고, 분산 시스템 환경에서 데이터의 일관성 수준을 제어하는 읽기/쓰기 우려(Read/Write Concern)의 내부 동작 원리를 깊이 있게 살펴봅니다.

-----

## 00\. ACID 준수: MongoDB 멀티-도큐먼트 트랜잭션의 이해

MongoDB를 이야기할 때 가장 먼저 강조했던 것은 **단일 도큐먼트에 대한 작업은 원자적(atomic)** 이라는 사실입니다. 사용자의 프로필 정보와 주소 목록을 하나의 `user` 도큐먼트에 임베딩했다면, 사용자의 이름과 기본 주소를 한 번의 `updateOne` 명령으로 수정하는 작업은 그 자체로 완벽한 원자성을 보장합니다. 이처럼 훌륭한 도큐먼트 모델링은 복잡한 트랜잭션의 필요성을 상당 부분 줄여주는 MongoDB의 핵심적인 장점입니다.

하지만 비즈니스 로직이 단일 도큐먼트를 넘어 **여러 도큐먼트, 심지어 여러 컬렉션에 걸쳐** 원자적인 변경을 요구하는 경우는 반드시 존재합니다.

**전형적인 이커머스 '주문 생성' 시나리오:**

1.  `products` 컬렉션에서 주문된 상품들의 재고(`stock`)를 줄인다.
2.  `orders` 컬렉션에 새로운 주문 도큐먼트를 생성한다.
3.  `carts` 컬렉션에서 해당 사용자의 장바구니를 비운다.

만약 1번(재고 감소)은 성공했는데, 2번(주문 생성) 단계에서 네트워크 오류가 발생해 실패한다면 어떻게 될까요? 시스템에는 실제 주문 없이 재고만 사라진, 데이터 정합성이 깨진 '유령 재고'가 발생하게 됩니다. 이러한 상황을 방지하기 위해, 위 1, 2, 3번의 모든 작업이 하나의 묶음처럼 모두 성공하거나 모두 실패하도록 보장하는 메커니즘이 바로 **멀티-도큐먼트 트랜잭션**입니다.

### ACID 원칙의 귀환

트랜잭션은 데이터베이스의 신뢰성을 보장하는 네 가지 원칙, **ACID**를 반드시 준수해야 합니다.

  * **원자성 (Atomicity):** 트랜잭션 내의 모든 작업은 전부 성공하거나 전부 실패해야 한다. ('All or Nothing')
  * **일관성 (Consistency):** 트랜잭션은 데이터를 하나의 일관된 상태에서 또 다른 일관된 상태로 이전시켜야 한다.
  * **고립성 (Isolation):** 여러 트랜잭션이 동시에 실행되더라도, 서로의 작업에 영향을 주지 않고 독립적으로 실행되는 것처럼 보여야 한다.
  * **지속성 (Durability):** 성공적으로 완료(커밋)된 트랜잭션의 결과는 시스템 장애가 발생하더라도 영구적으로 보존되어야 한다.

과거 많은 NoSQL 데이터베이스가 확장성에 집중하느라 ACID를 포기했던 것과 달리, MongoDB는 버전 4.0(레플리카 셋) 및 4.2(샤드 클러스터)부터 **멀티-도큐먼트 ACID 트랜잭션**을 전면적으로 지원하게 되었습니다.

### MongoDB 트랜잭션 사용법 (Kotlin 기준)

MongoDB에서 트랜잭션을 사용하려면, 먼저 드라이버를 통해 **세션(Session)** 을 시작해야 합니다. 모든 트랜잭션 연산은 이 세션 위에서 실행됩니다.

Kotlin Coroutine 드라이버를 예로, 앞선 '주문 생성' 로직을 트랜잭션으로 구현해 보겠습니다. `session.withTransaction { ... }` 블록을 사용하면 정형화된 구조로 안전하게 구현할 수 있습니다.

```kotlin
import com.mongodb.ReadConcern
import com.mongodb.ReadPreference
import com.mongodb.TransactionOptions
import com.mongodb.WriteConcern
import com.mongodb.kotlin.client.coroutine.MongoClient
import org.bson.Document

// ... MongoClient(client)가 초기화되어 있다고 가정 ...
// ... Coroutine Scope 내에서 실행된다고 가정 ...

// 1. 클라이언트로부터 세션을 시작합니다.
val session = client.startSession()

try {
    val txnOptions = TransactionOptions.builder()
        .readPreference(ReadPreference.primary())
        .readConcern(ReadConcern.SNAPSHOT)
        .writeConcern(WriteConcern.MAJORITY)
        .build()

    // 2. withTransaction이 트랜잭션의 시작, 커밋, 에러 시 롤백(abort)을 자동으로 관리합니다.
    session.withTransaction(txnOptions) {
        val productsCollection = client.getDatabase("ecommerce").getCollection<Document>("products")
        val ordersCollection = client.getDatabase("ecommerce").getCollection<Document>("orders")
        val cartsCollection = client.getDatabase("ecommerce").getCollection<Document>("carts")

        // 작업 1: products 컬렉션의 재고 감소
        productsCollection.updateOne(this,
            Filters.and(Filters.eq("_id", "MDB_MUG_01"), Filters.gte("stock", 1)),
            Updates.inc("stock", -1)
        )

        // 작업 2: orders 컬렉션에 주문 생성
        val newOrder = Document("customerId", "user001")
            .append("items", listOf(/*...*/))
            .append("status", "PENDING")
        ordersCollection.insertOne(this, newOrder)
        
        // 작업 3: carts 컬렉션에서 장바구니 삭제
        cartsCollection.deleteOne(this, Filters.eq("userId", "user001"))

        // 이 블록 내에서 예외가 발생하면 withTransaction이 모든 변경 사항을 자동으로 롤백합니다.
        // 예외 없이 블록이 끝나면 모든 변경 사항을 커밋합니다.
    }
    println("주문이 성공적으로 완료되었습니다.")

} catch (e: Exception) {
    println("주문 처리 중 에러가 발생하여 트랜잭션이 롤백되었습니다: ${e.message}")
} finally {
    // 3. 사용이 끝난 세션을 종료합니다.
    session.close()
}
```

**핵심:** `withTransaction` 람다 블록 내에서 수행되는 모든 데이터베이스 작업(`updateOne`, `insertOne` 등)의 **첫 인자로** 컨텍스트 세션(`this`)을 전달하여, 이 작업들이 동일한 트랜잭션에 속해 있음을 MongoDB에 알려주는 것이 가장 중요합니다.

트랜잭션은 데이터 정합성을 위한 강력한 도구이지만, 성능상의 오버헤드를 수반합니다. 따라서 모든 곳에 트랜잭션을 남용하기보다는, 도큐먼트 모델링을 통해 트랜잭션의 필요성을 최소화하고, 비즈니스 로직상 반드시 여러 도큐먼트의 원자성이 보장되어야 하는 핵심적인 부분에만 신중하게 사용하는 것이 바람직합니다.