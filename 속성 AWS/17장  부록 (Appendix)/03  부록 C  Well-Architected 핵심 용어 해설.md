# 부록 C: Well-Architected 핵심 용어 해설

클라우드 아키텍처의 세계는 미묘한 뉘앙스를 가진 수많은 전문 용어로 가득 차 있다. 이 용어들을 피상적으로 이해하고 혼용하는 것은, 아키텍처 설계의 가장 중요한 과정인 트레이드오프 분석에서 치명적인 오판을 내리는 지름길이 된다. 예를 들어, '가용성'과 '내구성'은 비슷하게 들리지만, 이 둘은 전혀 다른 차원의 문제를 다루며 완전히 다른 설계 결정을 요구한다.

이 부록은 단순한 용어 사전이 아니다. 여기서는 실무 아키텍트들이 가장 흔하게 혼동하거나 오용하는 핵심 개념들의 본질적인 차이를 명확하게 가르고, 그 차이가 실제 아키텍처 설계에 어떤 의미를 갖는지 설명한다. 이 미묘한 차이를 꿰뚫어 보는 통찰력이야말로 당신을 평범한 기술자에서 위대한 아키텍트로 성장시키는 마지막 한 조각의 퍼즐이 될 것이다.

---

## 00. 가용성(Availability) vs 내구성(Durability) vs 안정성(Reliability)

이 세 가지 용어는 안정적인 시스템을 논할 때 가장 기본이 되면서도 가장 깊은 이해를 요구하는 개념이다. 이들은 서로 밀접하게 관련되어 있지만, 절대로 동일한 의미가 아니다.

### 가용성 (Availability) - 시스템이 살아있는가?

* **정의:** **시스템이 정상적으로 작동하여 사용자의 요청에 응답할 수 있는 시간의 비율.** 주로 '퍼센트(%)'로 표현되며, "파이브 나인(Five Nines)"은 99.999%의 가용성을 의미한다. 이는 1년 동안 약 5.26분의 다운타임만을 허용한다는 뜻이다.
* **핵심 질문:** "시스템이 지금 당장 사용 가능한가?" (Is the system up?)
* **관련 개념:** **업타임(Uptime)**, 장애 조치(Failover), MTTR(Mean Time To Repair).
* **AWS 예시:** **다중 AZ(Multi-AZ)** 설계는 가용성을 높이기 위한 가장 대표적인 전략이다. 하나의 AZ에 장애가 발생하더라도 다른 AZ의 리소스가 서비스를 계속 이어가도록 하여, 시스템의 전체 업타임을 보장한다.
* **아날로그:** **24시간 연중무휴 편의점.** 이 편의점은 언제 가더라도 문이 열려있고 계산을 할 수 있다. 즉, **가용성**이 매우 높다.

### 내구성 (Durability) - 데이터가 사라지지 않는가?

* **정의:** **저장된 데이터가 시간이 지나도 손실되거나 손상되지 않을 확률.** 이 역시 '퍼센트(%)'로 표현되며, Amazon S3의 "일레븐 나인(Eleven Nines)"은 99.999999999%의 내구성을 의미한다. 이는 100억 개의 객체를 저장했을 때, 1만 년에 하나 정도의 객체가 유실될 수 있다는, 거의 영원에 가까운 데이터 보존을 약속하는 것이다.
* **핵심 질문:** "내 데이터가 안전하게 보존되는가?" (Is my data safe?)
* **관련 개념:** **데이터 유실(Data Loss)**, 백업, 복제(Replication).
* **AWS 예시:** **Amazon S3**는 객체를 업로드하는 즉시 여러 가용 영역에 걸쳐 물리적으로 분리된 여러 디바이스에 중복 저장한다. 이는 디스크 장애나 AZ 재해 상황에서도 데이터가 유실되지 않도록 보장하는 **내구성** 중심의 설계다.
* **아날로그:** 편의점의 모든 거래 기록이 위조 불가능한 특수 종이에 기록되어, 화재나 홍수에도 견딜 수 있는 티타늄 금고에 **여러 부 복사되어** 보관된다. 어젯밤 편의점에 불이 나서 오늘 영업을 못 하더라도(**가용성**은 0), 지난 10년간의 거래 기록은 단 하나도 사라지지 않았다(**내구성**은 100%).

**가용성과 내구성의 결정적 차이:** 시스템이 다운되어 **사용할 수 없는 상태(낮은 가용성)**이더라도, 그 안의 데이터가 **손실되지 않았다면(높은 내구성)**, 시스템 복구 후 비즈니스를 재개할 수 있다. 하지만 시스템이 24시간 내내 작동하더라도(**높은 가용성**), 저장된 데이터가 손상되거나 영구적으로 사라졌다면(**낮은 내구성**), 그 비즈니스는 회복 불가능한 타격을 입는다.

### 안정성 (Reliability) - 시스템을 믿을 수 있는가?

* **정의:** **시스템이 주어진 시간 동안 의도된 기능을 '올바르게' 수행하는 종합적인 능력.** 안정성은 **가용성**과 **내구성**을 모두 포함하는 상위 개념이며, 여기에 더해 시스템이 버그 없이 정확한 결과를 반환하는 **정확성(Correctness)**까지 포괄한다.
* **핵심 질문:** "이 시스템은 내가 기대하는 대로, 내가 필요할 때, 문제없이 작동하는가?" (Can I trust this system?)
* **관련 개념:** Well-Architected Framework 전체. 안정성은 하나의 기술이 아닌, 장애 처리, 변경 관리, 테스트 등 모든 아키텍처 원칙과 운영 규율의 총합이다.
* **아날로그:** 우리의 편의점은 24시간 문을 열고(**가용성**), 거래 기록을 절대 잃어버리지 않으며(**내구성**), **추가적으로** 계산대의 바코드 스캐너는 항상 정확한 상품을 인식하고, POS 시스템은 거스름돈을 틀리는 법이 없으며, 재고 관리 시스템은 실제 재고와 완벽하게 일치한다(**정확성**). 이 모든 것이 합쳐졌을 때, 우리는 비로소 이 편의점을 **안정적**이라고 말할 수 있다.

결론적으로, 아키텍트는 고객과 비즈니스의 요구사항에 따라 이 세 가지를 전략적으로 트레이드오프해야 한다. 극단적인 가용성이 필요한 실시간 거래 시스템과, 극단적인 내구성이 필요한 데이터 아카이브 시스템의 아키텍처는 완전히 달라야 한다. 이 용어들의 정확한 의미를 이해하는 것이 바로 그 첫걸음이다.

## 01. 수직 확장(Scale-Up) vs 수평 확장(Scale-Out)

애플리케이션의 트래픽이 증가하여 더 많은 처리 용량이 필요할 때, 아키텍트는 '확장(Scaling)'이라는 중대한 갈림길에 서게 된다. 이 갈림길은 두 방향으로 나뉜다: **수직 확장(Scale-Up)**과 **수평 확장(Scale-Out)**. 이 둘은 단순히 리소스를 추가하는 방식의 차이가 아니다. 이것은 시스템의 탄력성, 가용성, 그리고 비용 모델을 근본적으로 결정하는 아키텍처의 핵심 철학에 대한 선택이다.

### 수직 확장 (Scale-Up) - 더 큰 엔진으로 교체하기

* **정의:** **단일 서버(인스턴스) 자체의 성능을 높이는 것.** 이는 마치 기존 자동차의 4기통 엔진을 더 강력한 8기통 엔진으로 교체하는 것과 같다. 자동차의 수는 그대로 한 대이지만, 그 한 대가 더 강력해진다.
* **AWS에서의 의미:** EC2 인스턴스의 유형을 `t3.large`에서 `m5.2xlarge`로 변경하거나, RDS 데이터베이스의 인스턴스 클래스를 더 높은 사양으로 업그레이드하는 행위다. 즉, CPU 코어의 수, 메모리의 크기, 네트워크 대역폭 등을 증가시키는 것이다.
* **장점:**
    * **단순함:** 애플리케이션 코드를 변경할 필요가 없는 경우가 많다. 데이터베이스와 같이 상태를 저장(Stateful)하며 분산이 어려운 전통적인 워크로드의 성능을 향상시키는 가장 빠르고 간단한 방법일 수 있다.
* **치명적인 단점:**
    * **비용과 한계:** 성능은 선형적으로 증가하지 않지만, 비용은 기하급수적으로 증가한다. 가장 강력한 사양의 인스턴스는 엄청나게 비싸며, 결국에는 더 이상 업그레이드할 수 없는 물리적 한계에 부딪힌다.
    * **다운타임(Downtime):** 인스턴스 유형을 변경하려면 일반적으로 인스턴스를 중지하고 재시작하는 과정이 필요하며, 이는 서비스 중단을 의미한다.
    * **단일 장애점 (SPOF):** 가장 결정적인 문제다. 아무리 강력한 엔진을 장착하더라도, 자동차는 여전히 한 대다. 그 자동차가 고장 나면 서비스는 완전히 멈춘다. 즉, 수직 확장은 **단일 장애점 문제를 해결해주지 못하며, 오히려 강화시킨다.**

### 수평 확장 (Scale-Out) - 더 많은 차량을 추가하기

* **정의:** **동일한 사양의 서버(인스턴스) 수를 늘려서 전체 처리 용량을 높이는 것.** 이는 한 대의 대형 트럭 대신, 여러 대의 소형 밴을 추가하여 운송 능력을 늘리는 것과 같다.
* **AWS에서의 의미:** Application Load Balancer 뒤에 연결된 Auto Scaling Group의 인스턴스 수를 2개에서 10개로 늘리거나, Aurora 데이터베이스에 읽기 전용 복제본(Read Replica)을 추가하는 행위다.
* **장점:**
    * **높은 가용성과 내결함성:** 여러 대의 밴 중 하나가 고장 나더라도, 나머지 밴들이 계속해서 짐을 나를 수 있다. 즉, 단일 인스턴스의 장애가 전체 서비스의 중단으로 이어지지 않으므로 **단일 장애점이 자연스럽게 제거**된다.
    * **탄력성과 비용 효율성:** 교통량(트래픽)에 따라 밴의 수를 실시간으로 늘리거나 줄일 수 있다. 필요한 만큼만 리소스를 사용하고 비용을 지불하는 클라우드의 핵심 가치인 **탄력성(Elasticity)**을 완벽하게 구현할 수 있다.
    * **이론상 무한한 확장:** 물리적 한계에 부딪히는 수직 확장과 달리, 이론적으로는 필요한 만큼 인스턴스를 계속해서 추가할 수 있다.

* **고려사항:**
    * **아키텍처 요구사항:** 애플리케이션이 반드시 **상태 비저장(Stateless)**으로 설계되어야 한다. 어떤 밴(인스턴스)이 요청을 처리하더라도 동일한 결과를 반환할 수 있어야 하며, 상태 정보는 ElastiCache나 DynamoDB와 같은 외부의 공유 저장소에서 관리되어야 한다.

**[도표: 수직 확장 vs 수평 확장 비교]**

| 구분 | 수직 확장 (Scale-Up) | 수평 확장 (Scale-Out) |
| :--- | :--- | :--- |
| **핵심 개념** | 더 강력한 단일 서버 | 더 많은 수의 서버 |
| **장점** | 구현의 단순함 | 높은 가용성, 탄력성, 비용 효율성 |
| **단점** | 높은 비용, 물리적 한계, 다운타임, **SPOF** | 아키텍처의 복잡성 (상태 비저장 요구) |
| **주요 기술** | 인스턴스 유형 변경 | Auto Scaling, Load Balancing, 컨테이너 |
| **최적 사용 사례**| 단일 RDBMS 마스터 노드, 분산이 어려운 레거시 | **모든 클라우드 네이티브 웹 애플리케이션** |

결론적으로, **클라우드 네이티브 아키텍처의 기본 철학은 수평 확장이다.** 우리는 개별 인스턴스가 실패할 수 있다는 사실을 받아들이고, 그럼에도 불구하고 전체 시스템은 살아남을 수 있도록 처음부터 여러 인스턴스로 분산하는 것을 전제로 설계해야 한다. 수직 확장은 데이터베이스의 주 노드(Primary Node) 성능을 강화하는 등 제한적인 경우에 사용될 수 있지만, 애플리케이션 계층은 언제나 수평 확장을 목표로 해야 한다.

---

## 02. 복구 시간 목표(RTO) vs 복구 지점 목표(RPO)

장애 복구(Disaster Recovery, DR) 계획을 수립할 때, "얼마나 빠르고 완벽하게 복구해야 하는가?"라는 질문은 비즈니스의 언어로 번역되어야 한다. RTO와 RPO는 바로 이 질문에 대한 구체적인 답을 제시하는, 모든 DR 전략의 가장 근간이 되는 두 가지 핵심 지표다. 이 두 지표를 비즈니스 이해관계자와 명확하게 합의하지 않고 수립된 DR 계획은, 실제 재해 상황에서 아무런 쓸모가 없는 값비싼 문서 조각에 불과하다.

### 복구 시간 목표 (Recovery Time Objective, RTO) - 얼마나 빨리 복구해야 하는가?

* **정의:** **장애가 발생한 시점부터 서비스가 다시 정상적으로 작동하기까지 허용되는 최대 시간.** 즉, **허용 가능한 최대 다운타임**을 의미한다.
* **핵심 질문:** "얼마나 오랫동안 시스템이 멈춰 있어도 괜찮은가?"
* **관련 개념:** **다운타임(Downtime)**, 장애 조치(Failover) 시간.
* **예시:** 'NextGen Commerce'의 결제 시스템 RTO가 **15분**이라면, 이는 데이터베이스에 장애가 발생하더라도 15분 이내에 반드시 백업 데이터베이스로 전환하여 결제 기능을 복구해야 함을 의미한다.
* **아키텍처에 미치는 영향:** RTO가 짧을수록(Zero RTO에 가까울수록), **더 비싸고 복잡한 고가용성 아키텍처**가 필요하다. 예를 들어, 수 시간의 RTO가 허용된다면 백업에서 수동으로 복구하는 전략(Backup and Restore)도 가능하지만, 수 분 이내의 RTO를 요구한다면 여러 리전에 걸쳐 실시간으로 복제되는 다중 리전 활성-활성(Multi-Region Active-Active)과 같은 매우 정교한 아키텍처가 필요하다.

### 복구 지점 목표 (Recovery Point Objective, RPO) - 얼마나 많은 데이터를 잃어도 괜찮은가?

* **정의:** **장애 발생 시, 유실이 허용되는 최대 데이터의 양.** 이는 주로 '시간' 단위로 표현되며, 마지막으로 유효한 데이터 백업 시점과 장애 발생 시점 사이의 데이터 손실량을 의미한다.
* **핵심 질문:** "최악의 경우, 얼마만큼의 데이터를 잃는 것까지 감수할 수 있는가?"
* **관련 개념:** **데이터 유실(Data Loss)**, 백업 주기.
* **예시:** 결제 시스템의 RPO가 **1분**이라면, 이는 어떤 경우에도 최대 1분 이내의 거래 데이터만 유실될 수 있음을 의미한다. 즉, 최소 1분마다 데이터가 백업 또는 복제되고 있어야 한다.
* **아키텍처에 미치는 영향:** RPO가 짧을수록(Zero RPO에 가까울수록), **더 빈번하고 비용이 많이 드는 데이터 복제 방식**이 필요하다. 예를 들어, 24시간의 RPO가 허용된다면 매일 밤 한 번씩 스냅샷 백업을 하는 것으로 충분하지만, 수 초 이내의 RPO를 요구한다면 다른 가용 영역이나 리전으로 데이터를 **동기식(Synchronous)**으로 복제하는 매우 비싼 기술이 필요하다.

**[도표: RTO vs RPO]**

| 구분 | 복구 시간 목표 (RTO) | 복구 지점 목표 (RPO) |
| :--- | :--- | :--- |
| **관심사** | **시간 (Time)** - 서비스 중단 시간 | **데이터 (Data)** - 데이터 손실량 |
| **질문** | "얼마나 빨리 복구할 것인가?" | "어느 시점의 데이터로 복구할 것인가?" |
| **영향** | 비즈니스 연속성, 다운타임 비용 | 데이터 무결성, 거래 손실 |
| **기술** | 고가용성, 장애 조치, 로드 밸런싱 | 백업 주기, 데이터 복제(동기/비동기) |

**결론:** RTO와 RPO는 기술팀이 임의로 정하는 숫자가 아니다. 이것은 **"다운타임 1분당 우리 비즈니스는 얼마의 손실을 보는가?"**, **"거래 데이터 1건의 가치는 얼마인가?"**와 같은 비즈니스적인 질문에 대한 답을 기반으로, **비즈니스와 기술이 함께 합의해야 하는 목표**다. 이 두 목표를 명확히 정의하는 것이야말로, 과잉 투자도 과소 투자도 아닌, 비즈니스에 꼭 맞는 합리적인 안정성 전략을 수립하는 첫걸음이다.

---

## 03. 최종 일관성(Eventual Consistency) vs 강력한 일관성(Strong Consistency)

분산 시스템, 특히 NoSQL 데이터베이스와 메시징 시스템의 세계로 들어서는 순간, 우리는 '일관성(Consistency)'이라는 개념이 우리가 상상했던 것만큼 단순하지 않다는 사실을 깨닫게 된다. 모든 데이터베이스가 은행 계좌처럼 항상 모든 사람에게 동일한 최신 잔고를 보여주는 것은 아니다. 분산 시스템은 성능과 가용성을 얻는 대가로, 일관성이라는 약속의 수준을 조절하는 트레이드오프를 감수한다. 이 트레이드오프의 양 극단에 바로 **강력한 일관성**과 **최종 일관성**이 존재한다.

### 강력한 일관성 (Strong Consistency)

* **정의:** **데이터에 대한 쓰기 작업이 완료되는 즉시, 그 이후의 모든 읽기 작업은 반드시 그 최신 데이터를 반환할 것을 보장**하는 가장 엄격한 일관성 모델이다. 쓰기 작업이 시스템의 모든 복제본에 전파되고 확인될 때까지 쓰기 요청은 완료되지 않는다.
* **핵심 철학:** **정확성**과 **예측 가능성**이 최우선이다.
* **아날로그:** **은행 창구.** 당신이 계좌에 10만 원을 입금하는 즉시, 지구 반대편에 있는 배우자가 ATM에서 잔고를 조회해도 정확히 10만 원이 늘어난 잔액이 표시된다. 중간 상태는 절대 존재하지 않는다.
* **장점:** 개발자가 애플리케이션 로직을 작성하기 매우 쉽다. 데이터는 항상 우리가 기대하는 최신 상태이므로 복잡한 예외 처리를 할 필요가 없다.
* **단점:** 모든 복제본에 쓰기가 완료될 때까지 기다려야 하므로, **쓰기 지연 시간(Write Latency)이 길어지고 가용성(Availability)이 저하**될 수 있다. 복제본 중 하나라도 응답하지 않으면 쓰기 작업 전체가 실패할 수 있기 때문이다.
* **대표적인 시스템:** **관계형 데이터베이스(RDS, Aurora)**는 기본적으로 강력한 일관성을 보장하도록 설계되었다.

### 최종 일관성 (Eventual Consistency)

* **정의:** **데이터에 대한 쓰기 작업이 발생하면, 시스템 내의 모든 복제본이 '결국에는(Eventually)' 그 최신 데이터 상태로 수렴될 것을 보장**하지만, 그 중간 과정에서는 잠시 동안 서로 다른 복제본이 다른 버전의 데이터를 반환할 수 있음을 허용하는 완화된 일관성 모델이다.
* **핵심 철학:** **가용성**과 **성능(낮은 지연 시간)**이 최우선이다.
* **아날로그:** **DNS(Domain Name System).** 당신이 웹사이트의 IP 주소를 변경하면, 그 변경 사항이 전 세계의 모든 DNS 서버에 전파되는 데에는 수 분에서 수 시간이 걸릴 수 있다. 이 시간 동안, A 지역의 사용자는 새로운 IP 주소로, B 지역의 사용자는 여전히 이전 IP 주소로 접속하게 될 수 있다. 하지만 '결국에는' 모든 DNS 서버가 동일한 새 IP 주소를 갖게 될 것이다.
* **장점:** 쓰기 요청은 주 복제본에만 기록되면 즉시 완료되므로, **쓰기 지연 시간이 매우 짧고 가용성이 극도로 높다.** 네트워크 장애로 일부 복제본과 통신이 끊어지더라도 시스템은 계속해서 작동할 수 있다.
* **단점:** 개발자는 애플리케이션이 잠시 동안 **오래된 데이터(Stale Data)**를 읽을 수 있다는 가능성을 항상 염두에 두고 코드를 작성해야 한다. 이는 애플리케이션 로직을 더 복잡하게 만들 수 있다.
* **대표적인 시스템:** **Amazon S3**(오버라이트 PUT 및 DELETE의 경우)와 **DynamoDB**(기본 읽기 모드)는 최종 일관성 모델을 기반으로 설계되어 엄청난 규모의 확장성과 가용성을 달성했다. (물론 DynamoDB는 추가 비용을 지불하고 강력한 일관성 읽기 옵션을 선택할 수도 있다.)

**결론:** 'NextGen Commerce' 플랫폼에서, **주문 및 결제**와 같이 단 1원의 오차도 허용되지 않는 금융 트랜잭션은 반드시 **강력한 일관성**을 제공하는 **Aurora**를 사용해야 한다. 반면, **상품 리뷰**나 **사용자 프로필 사진**처럼, 방금 작성한 리뷰가 다른 사용자에게 몇 초 늦게 보이는 것이 비즈니스에 치명적이지 않은 데이터는 **최종 일관성**을 제공하는 **DynamoDB**나 **S3**를 사용하여 확장성과 비용 효율성을 극대화하는 것이 현명한 아키텍처적 선택이다.

일관성 모델의 선택은 기술적 취향의 문제가 아니라, 데이터의 성격과 비즈니스의 요구사항을 깊이 이해하고 내리는 정교한 트레이드오프의 결과물이다. 이 미묘한 차이를 이해하는 것이야말로 분산 시스템을 성공적으로 설계하는 아키텍트의 핵심 역량이다.