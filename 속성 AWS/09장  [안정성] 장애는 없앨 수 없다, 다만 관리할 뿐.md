# 09장: [안정성] 장애는 없앨 수 없다, 다만 관리할 뿐

우리는 8장에서 제로 트러스트라는 현대적인 갑옷을 입고, 외부와 내부의 악의적인 위협으로부터 시스템을 보호하는 정교한 보안 체계를 완성했다. 우리의 성은 이제 그 어떤 침입자도 쉽게 뚫을 수 없는 요새가 되었다. 하지만 성의 가장 큰 위협이 항상 외부에만 있는 것은 아니다. 성벽의 돌 하나가 예고 없이 무너져 내리거나, 성 안의 우물에 갑자기 물이 마르는 것처럼, 시스템은 외부의 공격 없이도 스스로의 결함이나 인프라의 문제로 인해 언제든지 멈춰 설 수 있다. 아무리 안전한 시스템이라도, 사용할 수 없다면 아무런 가치가 없다.

이것이 바로 AWS Well-Architected Framework의 세 번째 원칙, **안정성(Reliability)**이 필요한 이유다. 안정성은 "워크로드가 주어진 시간 동안 의도된 기능을 올바르게 수행하는 능력"으로 정의된다. 클라우드 네이티브의 세계에서 안정성은 '장애를 예방하는 것'이 아니라, **"장애는 반드시 발생한다는 사실을 인정하고, 그 장애에도 불구하고 서비스 전체는 중단되지 않도록 시스템을 설계하는 것"**을 의미한다. 개별 부품의 고장은 막을 수 없지만, 자동차 전체는 계속해서 달려야 한다.

이 장의 목표는 장애로부터 시스템을 보호하는 것이 아니라, 장애를 겪고도 살아남는 **회복탄력성(Resilience)**을 아키텍처에 내장하는 것이다. 우리는 안정성을 저해하는 가장 큰 적인 **단일 장애점(SPOF)**을 식별하고 제거하는 것부터 시작할 것이다. 그리고 **다중 AZ(Multi-AZ)** 설계를 통해 지리적 중복성을 확보하고, **Auto Scaling**과 **Load Balancing**을 결합하여 시스템이 스스로를 치유하고 수요에 맞춰 확장하도록 만들 것이다. 마지막으로, 우리는 마이크로서비스 환경에서 하나의 장애가 전체 시스템으로 퍼져나가는 것을 막는 강력한 방화벽, **서킷 브레이커(Circuit Breaker)** 패턴을 구현하게 될 것이다. 이 장을 통해 당신은 더 이상 장애를 두려워하는 관리자가 아닌, 실패를 예상하고 그것을 우아하게 관리하는 진정한 분산 시스템 아키텍트로 거듭날 것이다.

---

## 00. 단일 장애점(SPOF) 식별 및 제거

안정적인 시스템을 향한 여정은 어디서부터 시작해야 하는가? 그 첫걸음은 우리 아키텍처에 숨어있는 가장 치명적인 적, **단일 장애점(Single Point of Failure, SPOF)**을 찾아내 제거하는 것이다. 단일 장애점이란, 말 그대로 **'그 구성 요소 하나가 실패하면 전체 시스템 또는 주요 기능이 중단되는'** 모든 지점을 의미한다. 이는 도미노의 첫 번째 블록과 같아서, 이 블록이 쓰러지는 순간 연쇄적인 붕괴가 시작된다.



하나의 다리로만 연결된 섬을 상상해 보라. 그 다리가 보수 공사로 폐쇄되거나, 태풍으로 무너지는 순간, 섬은 외부 세계와 완전히 고립된다. 이 다리가 바로 이 섬의 SPOF다. 클라우드 아키텍처에서 이러한 '다리'는 다양한 형태로 존재한다.

* **단 하나의 EC2 인스턴스:** 웹 서버를 단 하나의 EC2 인스턴스 위에서 운영하고 있다면, 그 인스턴스의 하드웨어에 문제가 생기거나 OS가 멈추는 순간 당신의 웹사이트는 즉시 다운된다.
* **단 하나의 EBS 볼륨:** 중요한 데이터를 단 하나의 EBS 볼륨에 저장하고 있다면, 그 볼륨에 장애가 발생하는 드문 경우에 데이터는 유실될 수 있다.
* **단 하나의 가용 영역 (Availability Zone, AZ):** 모든 리소스(EC2, RDS, ElastiCache 등)를 서울 리전의 `ap-northeast-2a`라는 단일 가용 영역에만 배치했다고 가정해 보자. 만약 이 AZ 전체에 정전이나 네트워크 장애와 같은 재해가 발생한다면, 당신의 애플리케이션 전체는 한순간에 마비될 것이다. 가용 영역 그 자체가 SPOF가 되는 것이다.
* **단 한 명의 전문가:** 특정 시스템의 구조와 운영 방법을 오직 한 사람만이 알고 있다면, 그 사람의 휴가나 퇴사 자체가 비즈니스의 SPOF가 될 수 있다. (Human SPOF)

SPOF를 제거하기 위한 가장 근본적인 해결책은 **중복성(Redundancy)**이다. 즉, 중요한 기능을 수행하는 구성 요소를 절대로 하나만 두지 않는 것이다. 섬으로 들어가는 다리를 두 개, 세 개 건설하여 하나가 무너지더라도 다른 다리를 통해 통행이 가능하도록 만드는 것과 같은 원리다.

클라우드 네이티브 아키텍처에서 중복성을 구현하는 것은 단순히 똑같은 것을 두 개 만드는 행위를 넘어선다.

1.  **장애 감지 (Failure Detection):** 구성 요소 중 하나에 문제가 생겼다는 사실을 어떻게 자동으로 알아챌 것인가? (예: Load Balancer의 헬스 체크)
2.  **트래픽 재라우팅 (Traffic Rerouting):** 장애가 감지되었을 때, 어떻게 사용자 트래픽을 자동으로 건강한 다른 구성 요소로 보낼 것인가? (예: Load Balancer의 트래픽 분배)
3.  **자동 복구 (Auto-remediation):** 장애가 난 구성 요소를 어떻게 자동으로 정상 상태로 되돌리거나, 새로운 건강한 구성 요소로 교체할 것인가? (예: Auto Scaling의 인스턴스 교체)

이 세 가지 메커니즘이 유기적으로 결합될 때, 우리는 비로소 진정한 의미의 SPOF를 제거하고 고가용성(High Availability)을 갖춘 시스템을 만들 수 있다. 단일 장애점을 식별하고 제거하는 것은 일회성 활동이 아니다. 시스템이 진화하고 새로운 기능이 추가될 때마다, "만약 이것이 실패하면 어떻게 될까?"라는 질문을 끊임없이 던져야 하는 아키텍트의 핵심적인 규율이다.

이제, 이 중복성의 원칙을 물리적인 인프라 수준에서 구현하는 가장 기본적인 패턴인 다중 AZ(Multi-AZ) 설계에 대해 깊이 있게 알아보자.