# 04장: 데이터 아키텍처 설계: 목적에 맞는 데이터베이스 선택

우리는 3장에서 IaC라는 단단한 대지 위에 컴퓨팅이라는 심장을 성공적으로 이식했다. EC2, ECS, EKS, Lambda라는 각기 다른 박동을 가진 심장들은 이제 비즈니스 로직을 실행할 준비를 마쳤다. 그러나 심장만으로는 생명체가 살아 움직일 수 없다. 심장이 펌프질하여 온몸으로 보내야 할 가장 중요한 것, 바로 **데이터**라는 혈액이 필요하다. 데이터는 현대 비즈니스의 생명선이며, 이 데이터를 어떻게 저장하고, 관리하며, 접근할 것인지를 결정하는 데이터 아키텍처 설계는 전체 시스템의 성패를 좌우하는 가장 중대한 의사결정 중 하나다.

과거 온프레미스 시대에는 선택지가 많지 않았다. 강력하고 값비싼 상용 관계형 데이터베이스(RDBMS) 하나가 애플리케이션의 모든 데이터—사용자 정보, 상품 목록, 실시간 로그, 분석 데이터까지—를 도맡아 처리하는 것이 일반적이었다. 하지만 클라우드 네이티브 시대에 이러한 '만능 데이터베이스(One-size-fits-all)' 접근 방식은 모놀리식 애플리케이션이 그랬던 것처럼, 시스템의 발목을 잡는 거대한 족쇄가 될 뿐이다.

이 장의 목표는 특정 데이터베이스의 API를 배우는 것이 아니다. 우리는 한 걸음 더 나아가, 데이터의 '성격'을 파악하고 그 성격에 가장 적합한 '집'을 찾아주는 데이터 건축가의 관점을 익힐 것이다. 관계형 데이터베이스의 트랜잭션과 일관성이 왜 여전히 중요한지, NoSQL의 폭발적인 확장성과 유연성은 어떤 대가를 요구하는지, 그리고 캐시가 어떻게 성능과 비용 사이의 아슬아슬한 줄타기를 가능하게 하는지 그 본질을 파헤칠 것이다. 이 장을 마치고 나면, 당신은 더 이상 익숙함에 기대어 데이터베이스를 선택하는 기술자가 아닌, 데이터의 가치를 극대화하는 최적의 아키텍처를 설계하는 전략가로 거듭날 것이다.

---

## 00. 하나의 데이터베이스가 모든 것을 지배하던 시대의 종말

"우리 회사의 모든 데이터는 Oracle 데이터베이스에 저장되어 있습니다."

10년, 15년 전만 해도 이 말은 기술적 자부심의 표현이었다. 값비싸고, 강력하며, 신뢰할 수 있는 중앙 집중형 관계형 데이터베이스(RDBMS) 하나가 기업의 모든 데이터를 수용하고 통제했다. 개발자들은 데이터의 종류나 접근 패턴에 상관없이 모든 것을 정규화된 테이블에 꾸역꾸역 밀어 넣었고, 데이터베이스 관리자(DBA)는 이 거대한 단일 진실 공급원(Single Source of Truth)을 지키는 막강한 문지기 역할을 했다.

이러한 **모놀리식 데이터베이스(Monolithic Database)** 아키텍처는 데이터의 일관성을 유지하고 관리 포인트를 단일화하는 데에는 분명한 장점이 있었다. 그러나 비즈니스가 클라우드 속도로 움직이기 시작하면서, 이 거대한 데이터 저장소는 혁신의 가장 큰 병목 구간으로 전락했다.

* **스키마의 경직성 (Schema Rigidity):** 비즈니스 요구사항이 바뀌어 상품 테이블에 새로운 속성을 하나 추가하려고 해도, 엄격한 스키마 변경 절차와 다른 서비스에 미칠 잠재적 영향을 분석하느라 수 주가 걸렸다. 빠른 이터레이션(iteration)은 불가능했다.
* **상충하는 워크로드의 충돌:** 사용자의 결제 트랜잭션을 처리하는 OLTP(Online Transaction Processing) 워크로드와, 전체 매출 데이터를 분석하는 OLAP(Online Analytical Processing) 워크로드가 동일한 데이터베이스 리소스를 두고 경쟁했다. 분석 쿼리 하나가 전체 시스템을 마비시키는 악몽이 현실이 되었다.
* **확장성의 한계 (Scalability Limits):** 사용자가 폭증하여 더 많은 읽기/쓰기 용량이 필요할 때, 모놀리식 데이터베이스가 선택할 수 있는 주된 방법은 더 크고 비싼 서버로 교체하는 **수직 확장(Scale-up)**뿐이었다. 이는 비용이 기하급수적으로 증가할 뿐만 아니라, 물리적 한계에 부딪히면 더 이상 확장할 수 없는 막다른 길이었다.
* **비용의 비효율성:** 관계형 데이터베이스는 데이터의 종류를 가리지 않고 최고 수준의 일관성(ACID)과 내구성을 보장하기 위해 설계되었다. 이는 엄청난 오버헤드를 수반한다. 잠깐 저장되었다 사라질 사용자 세션 데이터나, 몇 초 늦게 처리되어도 상관없는 단순 로그 데이터까지 값비싼 RDBMS에 저장하는 것은 마치 슈퍼카를 동네 마트에 장 보러 가는 데 사용하는 것과 같은 극심한 낭비였다.

클라우드 네이티브와 마이크로서비스의 등장은 이러한 획일적인 접근 방식에 종언을 고했다. 각 마이크로서비스는 자신만의 데이터를 소유하고, 자신의 기능적 요구사항에 가장 최적화된 데이터 스토어를 선택할 권리와 책임을 갖게 되었다. 이것이 바로 **다중 저장소 지속성(Polyglot Persistence)**이라는 개념이다.



**다중 저장소 지속성**은 마치 잘 갖춰진 연장통과 같다. 망치 하나로 모든 못을 박고, 나사를 조이고, 파이프를 자르려 하지 않는다. 못을 박을 땐 망치를, 나사를 조일 땐 드라이버를, 파이프를 자를 땐 톱을 쓰는 것이 당연하다. 데이터도 마찬가지다.

* 금융 거래와 같이 **강력한 일관성**이 필요하다면 **관계형 데이터베이스(RDS, Aurora)**를 사용한다.
* 사용자 프로필이나 상품 카탈로그처럼 **유연한 스키마와 수평 확장성**이 중요하다면 **NoSQL 문서 데이터베이스(DynamoDB)**를 선택한다.
* 소셜 네트워크의 친구 관계처럼 **데이터 간의 복잡한 관계**를 빠르게 탐색해야 한다면 **그래프 데이터베이스(Neptune)**가 정답이다.
* 리더보드나 실시간 순위처럼 **극도로 빠른 응답 속도**가 필요하다면 **인메모리 데이터베이스(ElastiCache for Redis)**를 활용한다.

하나의 데이터베이스가 모든 것을 지배하던 시대는 끝났다. 이제 아키텍트의 임무는 데이터베이스 벤더의 이름이나 익숙함이 아니라, **데이터의 본질적인 특성과 비즈니스가 요구하는 접근 패턴**을 깊이 이해하고, 그 목적에 맞는(Purpose-built) 최적의 도구를 선택하는 것이다. 이제 그 첫 번째 도구, 여전히 현대 애플리케이션의 근간을 이루는 관계형 데이터베이스의 세계를 탐험해 보자.