## 03. 서킷 브레이커(Circuit Breaker) 패턴을 이용한 장애 전파 방지

우리는 Auto Scaling과 Load Balancing을 통해 개별 인스턴스의 장애나 트래픽 급증에 대응하는 강력한 메커니즘을 갖추었다. 하지만 마이크로서비스 아키텍처의 안정성을 위협하는 또 다른 교활한 적이 있다. 바로 **의존하는 서비스의 실패**다. 'NextGen Commerce'의 주문 서비스는 재고 서비스, 결제 서비스, 알림 서비스 등 수많은 다른 서비스에 의존하여 자신의 기능을 완성한다. 만약 이 중 결제 서비스가 갑자기 느려지거나 응답하지 않는다면 어떻게 될까?

주문 서비스는 결제 서비스의 응답을 기다리며 하염없이 대기할 것이다. 이 대기 시간 동안 주문 서비스의 스레드(Thread)나 커넥션 풀과 같은 소중한 리소스는 고갈되어 버린다. 새로운 주문 요청이 들어와도, 주문 서비스는 더 이상 응답할 수 없는 '식물인간' 상태에 빠지게 된다. 결국, 상대적으로 덜 중요한 결제 서비스의 일시적인 장애가 시스템의 가장 핵심적인 기능인 주문 접수 자체를 마비시키는 **연쇄 장애(Cascading Failure)**로 이어진다.

이러한 재앙을 막기 위해, 우리는 전기 공학에서 영감을 받은 매우 우아한 패턴을 도입해야 한다. 바로 **서킷 브레이커(Circuit Breaker)**, 즉 **'회로 차단기'** 패턴이다.

### 회로 차단기의 작동 원리

집에 있는 전기 회로 차단기를 생각해 보자. 과부하가 걸리거나 합선이 되면, 차단기는 즉시 "툭"하고 내려가 전기 회로를 끊어버린다. 이는 더 큰 화재나 전기 기기의 손상을 막기 위한 자동 보호 장치다. 소프트웨어 아키텍처의 서킷 브레이커도 정확히 동일한 원리로 작동한다. 이것은 서비스 A가 서비스 B를 호출하는 모든 네트워크 요청을 감싸는 일종의 프록시(Proxy) 객체로, 다음과 같은 세 가지 상태를 오가며 작동한다.



1.  **닫힘 (Closed) 상태:**
    * 평상시의 정상적인 상태다. 모든 요청은 아무런 제약 없이 의존하는 서비스(서비스 B)로 전달된다.
    * 서킷 브레이커는 이때 조용히 실패 횟수를 계산한다. 만약 특정 시간 동안 실패 횟수가 미리 정해진 임계값(Threshold)을 초과하면, 서킷 브레이커는 "툭"하고 회로를 끊고 **'열림(Open)'** 상태로 전환된다.

2.  **열림 (Open) 상태:**
    * 이 상태에서 서킷 브레이커는 의존하는 서비스(서비스 B)로 **어떠한 요청도 보내지 않는다.** 대신, 즉시 **"서비스 B는 현재 사용할 수 없습니다"**라는 오류를 반환한다. 이를 **'빠른 실패(Fail Fast)'**라고 한다.
    * 이는 불필요한 대기 시간을 없애 서비스 A의 리소스를 보호하고, 동시에 문제가 생긴 서비스 B가 빗발치는 요청에 짓눌리지 않고 스스로 복구할 수 있는 시간을 벌어주는 매우 중요한 역할이다.
    * '열림' 상태가 되면, 미리 설정된 타임아웃(Timeout) 타이머가 시작된다.

3.  **반-열림 (Half-Open) 상태:**
    * 타임아웃이 만료되면, 서킷 브레이커는 **'반-열림'** 상태로 전환된다. 이 상태는 서비스 B가 복구되었는지 확인하기 위한 탐색 단계다.
    * 서킷 브레이커는 제한된 수의 테스트 요청(예: 단 하나의 요청)만을 서비스 B로 조심스럽게 보낸다.
    * **만약 이 테스트 요청이 성공하면,** 서킷 브레이커는 "서비스 B가 회복되었다"고 판단하고 다시 **'닫힘'** 상태로 돌아가 모든 트래픽을 정상적으로 통과시킨다.
    * **만약 테스트 요청이 또다시 실패하면,** 서킷 브레이커는 "아직 복구되지 않았다"고 판단하고 다시 **'열림'** 상태로 돌아가 타이머를 재설정한다.

### NextGen Commerce에 적용하기

'NextGen Commerce'의 주문 서비스가 결제 서비스를 호출하는 모든 코드 주변에 서킷 브레이커를 구현한다고 상상해 보자. 평상시에는 모든 결제 요청이 정상적으로 처리된다(닫힘). 그러다 외부 결제 게이트웨이의 문제로 결제 서비스의 응답이 5초 이상 지연되기 시작한다. 주문 서비스의 서킷 브레이커는 이 실패를 감지하고, 실패율이 임계값을 넘어서자마자 회로를 연다(열림). 이제 새로운 주문 요청이 들어오면, 주문 서비스는 5초를 기다리는 대신 즉시 "결제 시스템에 일시적인 문제가 발생했습니다. 잠시 후 다시 시도해 주세요."라는 메시지를 사용자에게 보여준다. 이 시간 동안 결제 서비스 팀은 문제를 해결하고, 몇 분 후 서킷 브레이커는 서비스가 복구되었음을 자동으로 감지하여 다시 정상 상태(닫힘)로 돌아간다.

이 패턴은 Resilience4j(Java), Polly(.NET)와 같은 잘 만들어진 라이브러리를 사용하여 애플리케이션 코드 레벨에서 직접 구현할 수도 있고, Istio나 AWS App Mesh와 같은 **서비스 메시(Service Mesh)**를 사용하면 코드 수정 없이 인프라 레벨에서 투명하게 적용할 수도 있다.

결론적으로, 안정성은 하나의 기술로 완성되지 않는다. 그것은 다층적인 방어 전략의 총합이다. **단일 장애점을 제거**하여 기초를 다지고, **다중 AZ 설계**로 물리적 재해에 대비하며, **Auto Scaling과 Load Balancing**으로 시스템에 자가 치유 능력을 부여하고, 마지막으로 **서킷 브레이커**로 서비스 간 장애 전파를 차단하는 것. 이 네 가지 기둥이 유기적으로 결합될 때, 우리는 비로소 장애를 두려워하지 않고 우아하게 관리할 수 있는 진정한 회복탄력성을 갖춘 시스템을 완성하게 된다.

이제 우리의 시스템은 안전하고(보안), 장애에도 살아남을 수 있게(안정성) 되었다. 하지만 아무리 안전하고 안정적이더라도, 거북이처럼 느린 시스템을 고객들은 외면할 것이다. 다음 장에서는 시스템의 반응 속도를 극대화하고 자원을 효율적으로 사용하여 비용을 절감하는 기술, 즉 **성능 효율성(Performance Efficiency)**의 세계로 깊이 들어갈 것이다.