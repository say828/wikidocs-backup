## 02. 데이터베이스 마이그레이션: 동질 및 이기종 전환의 어려움과 해법

스트랭글러 피그 패턴이 아무리 우아한 애플리케이션 현대화 전략이라 할지라도, 모든 아키텍트는 결국 피할 수 없는 거대한 장벽과 마주하게 된다. 바로 **모놀리식 데이터베이스**라는 이름의 장벽이다. 애플리케이션 로직은 상태가 없으므로(Stateless) 비교적 쉽게 분리하고 이전할 수 있지만, 데이터는 상태(State)와 함께 수년간 축적된 비즈니스의 역사를 담고 있는 무거운 중력의 중심이다. 모놀리식의 모든 기능은 이 단일 데이터베이스라는 심장에 거미줄처럼 얽혀있으며, 이 심장을 멈추지 않고 새로운 몸에 이식하는 것은 마이그레이션 전체 과정에서 가장 위험하고 복잡한 **심장 수술**과도 같다.

이 심장 수술은 크게 두 가지 유형으로 나눌 수 있다.

* **동질(Homogeneous) 마이그레이션:** 동일한 종류의 데이터베이스 엔진 간에 이전하는 것이다. (예: 온프레미스 Oracle에서 AWS RDS for Oracle로)
* **이기종(Heterogeneous) 마이그레이션:** 서로 다른 데이터베이스 엔진 간에 전환하는 것이다. (예: 온프레미스 Oracle에서 클라우드 네이티브인 Amazon Aurora PostgreSQL로). 이것이 진정한 의미의 기술 부채 청산이자 현대화다.

---

### 동질 마이그레이션: 다운타임과의 싸움

동질 마이그레이션의 가장 큰 과제는 **다운타임(Downtime)을 최소화**하는 것이다. 수 테라바이트에 달하는 데이터를 네트워크를 통해 복사하는 데는 수 시간, 혹은 수일이 걸릴 수 있다. 이 시간 동안 원본 데이터베이스를 중단시키는 것은 24시간 운영되는 비즈니스에게는 불가능한 선택이다. 우리는 데이터가 복사되는 동안에도 원본 데이터베이스에서 발생하는 모든 변경 사항(쓰기, 수정, 삭제)을 놓치지 않고 새로운 데이터베이스에 실시간으로 반영해야 한다.

이 문제를 해결하기 위한 AWS의 핵심 솔루션이 바로 **AWS Database Migration Service (DMS)**다. DMS는 살아있는 데이터베이스를 최소한의 다운타임으로 마이그레이션할 수 있도록 설계된 완전 관리형 서비스다.



**DMS의 작동 원리:**
1.  **초기 전체 로드 (Initial Full Load):** DMS는 먼저 마이그레이션 시작 시점의 원본 데이터베이스 스냅샷을 대상 데이터베이스로 그대로 복사한다.
2.  **지속적인 변경 데이터 캡처 (Ongoing CDC):** 전체 로드가 진행되는 동안, DMS는 원본 데이터베이스의 트랜잭션 로그에 기록되는 모든 변경 사항을 **실시간으로 캡처(Change Data Capture, CDC)**하여 대기시킨다.
3.  **변경 사항 적용:** 전체 로드가 완료되면, DMS는 그동안 쌓아두었던 변경 사항들을 대상 데이터베이스에 순서대로 적용하여 두 데이터베이스의 상태를 거의 동일하게 맞춘다.
4.  **전환 (Cutover):** 원본과 대상 데이터베이스가 완벽하게 동기화된 상태가 되면, 우리는 짧은 유지보수 시간 동안 애플리케이션의 데이터베이스 연결 문자열(Connection String)을 기존의 온프레미스 DB에서 새로운 클라우드 DB의 엔드포인트로 변경하기만 하면 된다. 이 전환에 걸리는 시간, 즉 실제 다운타임은 단 몇 분으로 단축될 수 있다.

---

### 이기종 마이그레이션: 단순한 이전을 넘어선 번역의 기술

이기종 마이그레이션은 차원이 다른 복잡성을 가진다. 이것은 단순히 데이터를 옮기는 이사가 아니라, 한국어로 쓰인 방대한 양의 대하소설을 영어로 번역하여 출판하는 것과 같다. 단어 대 단어로 번역할 수 없는 수많은 뉘앙스와 문화적 차이가 존재하듯, 데이터베이스 엔진 간에는 다음과 같은 근본적인 차이가 존재한다.

* **스키마와 데이터 타입의 불일치:** Oracle의 `NUMBER` 타입은 PostgreSQL의 `NUMERIC` 또는 `BIGINT`와 어떻게 매핑되어야 하는가?
* **프로시저와 함수의 비호환성:** 원본 데이터베이스에만 존재하는 수천 라인의 독점적인 저장 프로시저(Stored Procedure)와 함수들은 새로운 오픈소스 데이터베이스에서 어떻게 다시 구현해야 하는가?
* **애플리케이션 코드의 전면 수정:** 데이터베이스가 바뀌었으므로, 애플리케이션의 모든 SQL 쿼리, ORM 설정 등 데이터 접근 계층의 코드는 전부 새로 작성하거나 수정해야 한다.

이 고통스러운 '번역' 과정을 돕기 위해 AWS는 **AWS Schema Conversion Tool (SCT)**이라는 강력한 동반자를 제공한다. SCT는 마이그레이션을 시작하기 전에 원본 데이터베이스를 정밀하게 분석하여, 대상 데이터베이스의 스키마와 호환되도록 자동으로 변환해주는 데스크톱 애플리케이션이다.

* **SCT의 역할:** SCT는 스키마, 뷰, 저장 프로시저, 함수 등을 분석하여 대상 엔진에 맞는 코드로 자동 변환한다. 더 중요한 것은, 자동 변환이 불가능한 부분(예: 독점적인 기능에 크게 의존하는 복잡한 프로시저)을 식별하고, 수동으로 수정해야 할 작업의 양과 난이도를 평가하는 **상세한 평가 보고서**를 생성해준다는 점이다. 이 보고서는 전체 마이그레이션 프로젝트의 범위와 공수를 산정하는 데 결정적인 역할을 한다.

SCT로 스키마 '번역'의 청사진을 그리고, DMS를 사용하여 실제 데이터 '내용'을 이전하는 것. 이 두 가지 도구의 조합을 통해 우리는 이기종 마이그레이션이라는 가장 험난한 산을 넘을 수 있는 체계적인 등반 계획을 세울 수 있다.

데이터베이스 마이그레이션은 스트랭글러 피그 패턴을 적용하는 과정에서 가장 신중하고 점진적으로 접근해야 하는 영역이다. 새로운 마이크로서비스가 필요로 하는 데이터만을 위한 새로운 테이블 스키마를 먼저 만들고, 기존 모놀리식 데이터베이스와의 데이터 동기화를 위해 DMS나 애플리케이션 레벨의 이중 쓰기(Dual-write)와 같은 패턴을 활용하며, 서서히 데이터의 소유권을 새로운 서비스로 옮겨와야 한다.

이제 우리는 과거의 유산을 미래의 자산으로 전환하는 기술까지 손에 넣었다. 이 책의 마지막 장에서는 이 모든 지식의 기반 위에서, 앞으로 10년간 클라우드 세계를 이끌어갈 거대한 흐름—서버리스, AI/ML, 그리고 그 너머—을 조망하며, 끊임없이 학습하는 아키텍트가 되기 위한 마지막 조언을 나눌 것이다.