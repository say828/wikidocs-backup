# 10장: [성능 효율성] 병목을 찾고, 최적화하고, 진화하라

우리는 9장에서 장애라는 혼돈 속에서도 시스템의 연속성을 보장하는 안정성의 기술을 마스터했다. 우리의 아키텍처는 이제 웬만한 내우외환에도 쉽게 무너지지 않는 견고한 요새가 되었다. 하지만 아무리 견고한 요새라도, 명령을 전달하는 전령이 거북이처럼 느리다면 전쟁에서 승리할 수 없다. 고객들은 단 몇 초의 지연 시간도 참아주지 않고 경쟁사의 웹사이트로 떠나버리는 무자비한 시대에, **성능**은 더 이상 선택이 아닌 생존의 필수 조건이다.

이것이 바로 AWS Well-Architected Framework의 네 번째 원칙, **성능 효율성(Performance Efficiency)**이 필요한 이유다. 성능 효율성은 단순히 '시스템을 빠르게 만드는 것'을 넘어, **"변화하는 비즈니스 요구사항과 기술 발전에 맞춰, 컴퓨팅 자원을 가장 효율적인 방식으로 사용하여 최고의 성능을 지속적으로 유지하는 능력"**을 의미한다. 이는 가장 비싼 F1 머신을 사는 것이 아니라, 주어진 예산 안에서 최고의 엔진, 타이어, 공기역학 설계를 조합하여 가장 빠른 랩 타임을 기록하는 F1 팀의 엔지니어링 전략과 같다.

이 장에서는 우리 시스템의 속도를 저해하는 숨겨진 **병목(Bottleneck)**을 찾아내고 제거하는 체계적인 방법을 탐구한다. 우리는 워크로드의 특성에 맞는 최적의 **EC2 인스턴스 유형과 스토리지**를 선택하는 것부터 시작하여, **Amazon CloudFront(CDN)**라는 글로벌 네트워크를 통해 전 세계 사용자의 물리적 거리를 극복할 것이다. 또한, 시스템의 심장부인 **데이터베이스의 성능을 튜닝**하는 구체적인 기술들을 배우고, 마지막으로 **부하 테스트**라는 과학적인 실험을 통해 우리 시스템의 한계가 어디인지 명확히 파악하고 미래의 성장을 예측하는 능력을 갖추게 될 것이다. 이 장을 통해 당신은 단순히 빠른 코드를 작성하는 개발자를 넘어, 시스템 전체의 자원 흐름을 최적화하여 최소의 비용으로 최대의 성능을 이끌어내는 진정한 성능 아키텍트로 거듭날 것이다.

---

## 00. 올바른 인스턴스 유형과 스토리지 선택 전략

성능 효율성을 향한 여정은 아키텍처의 가장 기본적인 구성 요소, 즉 애플리케이션을 실행할 **서버(인스턴스)**와 데이터를 저장할 **디스크(스토리지)**를 선택하는 것에서부터 시작된다. AWS는 마치 거대한 뷔페처럼, 수백 가지 종류의 EC2 인스턴스 유형과 다양한 스토리지 옵션을 제공한다. 이 풍요로운 선택지 앞에서 많은 아키텍트들이 저지르는 실수는, 과거의 경험이나 막연한 감에 의존하여 '만능(General Purpose)' 옵션을 선택하고 보는 것이다. 이는 마치 모든 요리에 똑같은 만능 소스를 뿌리는 것과 같아서, 음식 본연의 맛을 해치고 최적의 미식 경험을 망치는 결과를 낳는다.

최적의 성능은 **'워크로드의 특성(Workload Characteristics)'**을 정확히 이해하고, 그 특성에 가장 부합하는 도구를 선택하는 **'매칭(Matching)'**의 예술이다. 당신의 애플리케이션은 CPU 연산이 많이 필요한가(CPU-bound)? 아니면 메모리에 많은 데이터를 올려놓고 써야 하는가(Memory-bound)? 혹은 디스크 입출력이 잦은가(I/O-bound)? 이 질문에 답하는 것이 성능 최적화의 첫걸음이다.

### EC2 인스턴스 유형: 목적에 맞는 엔진 선택하기

AWS EC2 인스턴스는 크게 몇 가지 패밀리로 나뉘며, 각 패밀리는 특정 워크로드에 최적화되어 있다.

* **범용 (General Purpose - M, T 시리즈):** CPU, 메모리, 네트워크 자원이 균형 있게 배분되어 있어, 웹 서버나 소규모 애플리케이션과 같이 다양한 종류의 워크로드를 무난하게 처리할 수 있다. **T 시리즈**는 평소에는 CPU 사용량이 낮다가 가끔 급증하는(Burstable) 워크로드에 적합하며, 비용 효율적이다.
* **컴퓨팅 최적화 (Compute Optimized - C 시리즈):** vCPU(가상 CPU)당 메모리 비율이 낮고, 가장 높은 클럭 속도의 프로세서를 탑재하고 있다. 배치 처리, 미디어 트랜스코딩, 고성능 컴퓨팅(HPC), 과학 모델링과 같이 CPU 집약적인 연산이 필요한 워크로드에 이상적이다.
* **메모리 최적화 (Memory Optimized - R, X 시리즈):** vCPU당 메모리 비율이 매우 높다. 인메모리 데이터베이스(Redis, Memcached), 대규모 데이터 분석(Spark, Presto), 또는 실시간으로 방대한 데이터를 처리하는 애플리케이션처럼, 거대한 데이터셋을 메모리에 올려놓고 작업해야 하는 워크로드에 최고의 성능을 제공한다.
* **스토리지 최적화 (Storage Optimized - I, D 시리즈):** 로컬 스토리지에 극도로 빠른 속도의 NVMe SSD를 탑재하고 있다. 대규모 NoSQL 데이터베이스(Cassandra, ScyllaDB), 데이터 웨어하우징, 분산 파일 시스템처럼, 초당 수십만 건의 무작위 I/O 작업(IOPS)과 높은 처리량(Throughput)을 요구하는 워크로드에 특화되어 있다.

**AWS Graviton 프로세서로의 전환:**
최근 몇 년간 성능 효율성 분야에서 가장 중요한 변화 중 하나는 **AWS Graviton** 프로세서의 등장이다. Arm 아키텍처 기반의 Graviton 프로세서는 기존의 x86 기반 인스턴스(Intel, AMD)에 비해 훨씬 뛰어난 **가격 대비 성능(Price-Performance)**과 **에너지 효율**을 제공한다. Java, Python, Node.js와 같이 인터프리터 언어로 작성된 대부분의 클라우드 네이티브 애플리케이션은 거의 또는 전혀 코드 수정 없이 Graviton 인스턴스로 이전할 수 있으며, 이를 통해 **최대 40%의 가격 대비 성능 향상**을 기대할 수 있다. 성능과 비용, 그리고 지속 가능성을 동시에 잡을 수 있는 Graviton으로의 전환은 더 이상 선택이 아닌 필수 전략이다.

### EBS 볼륨 유형: 데이터 접근 패턴에 맞는 타이어 선택하기

EC2 인스턴스에 연결되는 네트워크 스토리지인 **EBS(Elastic Block Store)** 역시 성능 특성에 따라 다양한 유형을 제공한다.

* **범용 SSD (gp2/gp3):** 대부분의 워크로드를 위한 기본 선택지다. 부팅 볼륨, 개발 및 테스트 환경, 그리고 대부분의 애플리케이션 서버에 적합한 비용과 성능의 균형을 제공한다. 특히 최신 **gp3**는 IOPS와 처리량을 볼륨 크기와 무관하게 독립적으로 프로비저닝할 수 있어, gp2에 비해 더 저렴한 비용으로 더 높은 성능을 유연하게 맞출 수 있다.
* **프로비저닝된 IOPS SSD (io1/io2):** 미션 크리티컬한 고성능 데이터베이스(RDS, NoSQL)와 같이, **지속적으로 높은 IOPS**와 **낮은 지연 시간**을 요구하는 I/O 집약적인 워크로드를 위해 설계되었다. `io2 Block Express` 볼륨은 서브 밀리초 수준의 지연 시간을 제공하여, 온프레미스 SAN 스토리지에 버금가는 최고 수준의 성능을 제공한다.
* **처리량 최적화 HDD (st1) & 콜드 HDD (sc1):** 빅데이터 분석, 로그 처리와 같이 **순차적인 대용량 데이터 처리(처리량, Throughput)**가 중요한 워크로드에 적합한 저비용 HDD 스토리지다. `sc1`은 더 낮은 비용으로 자주 접근하지 않는 데이터를 저장하는 데 최적화되어 있다.

'NextGen Commerce'의 아키텍처를 설계할 때, 우리는 이 지식을 바탕으로 다음과 같은 전략적 결정을 내릴 수 있다.
* **웹/애플리케이션 서버:** **Graviton 기반의 T4g 또는 M7g** 인스턴스와 **gp3** EBS 볼륨을 사용하여 최적의 가격 대비 성능을 확보한다.
* **Aurora 데이터베이스:** 데이터베이스 워크로드에 최적화된 **R 시리즈(예: r7g)** 인스턴스 유형을 선택한다. (Aurora는 자체 스토리지 아키텍처를 사용하므로 EBS 유형 선택은 필요 없다.)
* **Elasticsearch 클러스터:** 대량의 데이터를 색인하고 검색해야 하므로, 빠른 로컬 NVMe 스토리지를 제공하는 **I 시리즈(예: i4i)** 인스턴스를 선택한다.

올바른 인스턴스와 스토리지를 선택하는 것은 성능 효율성의 가장 중요한 첫 단추를 끼우는 일이다. 하지만 우리의 사용자가 전 세계에 흩어져 있다면, 서버가 아무리 빨라도 서울에서 뉴욕까지의 물리적 거리가 만들어내는 빛의 속도의 한계, 즉 **지연 시간(Latency)**은 극복할 수 없다. 다음 절에서는 이 물리적 거리의 장벽을 허무는 마법, CDN의 세계로 들어갈 것이다.