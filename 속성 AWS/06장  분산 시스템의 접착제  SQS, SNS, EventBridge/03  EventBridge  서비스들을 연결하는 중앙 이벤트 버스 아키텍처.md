## 03. EventBridge: 서비스들을 연결하는 중앙 이벤트 버스 아키텍처

SQS가 서비스 간의 신뢰성 있는 작업 전달을, SNS가 이벤트를 다수의 구독자에게 전파하는 역할을 훌륭하게 수행했지만, 시스템의 규모가 커지고 비즈니스 로직이 복잡해짐에 따라 우리는 더 높은 수준의 추상화를 갈망하게 된다. 수십 개의 마이크로서비스가 저마다 SNS 토픽을 발행하고 SQS 큐를 구독하는 구조는, 마치 여러 갈래의 도로가 복잡하게 얽힌 구시가지와 같아서 전체적인 트래픽의 흐름을 파악하고 제어하기가 점차 어려워진다.

만약 우리 시스템의 모든 '의미 있는 사건(Event)'들이 단 하나의 거대한 **중앙 고속도로(Bus)**를 통해 흐르고, 우리는 그 고속도로의 분기점(Junction)에 서서 지나가는 차량(이벤트)의 **내용물**을 보고 "이 차는 부산으로", "저 차는 광주로" 보내는 정교한 라우팅을 할 수 있다면 어떨까? 이것이 바로 **Amazon EventBridge**가 제공하는 패러다임이다. EventBridge는 단순한 메시징 서비스를 넘어, 애플리케이션, AWS 서비스, 그리고 외부 SaaS 파트너들의 이벤트를 하나로 연결하는 **서버리스 이벤트 버스(Serverless Event Bus)**다. 이것은 현대 클라우드 네이티브 아키텍처의 **중앙 신경망** 역할을 수행한다.

### EventBridge의 작동 방식: 지능형 교통 관제 시스템

EventBridge는 SNS와 유사한 발행/구독 모델을 기반으로 하지만, 훨씬 더 지능적이고 유연한 방식으로 동작한다.



1.  **이벤트 소스 (Event Source):** 이벤트를 생성하는 모든 주체다. 우리의 마이크로서비스(예: 주문 서비스), AWS 서비스(예: S3에 파일이 업로드되는 사건), 또는 외부 SaaS 파트너(예: Stripe에서의 결제 성공)가 모두 이벤트 소스가 될 수 있다.
2.  **이벤트 버스 (Event Bus):** 모든 이벤트가 수신되는 중앙 라우터다. 이벤트 소스는 그저 자신의 이벤트를 버스에 보낼 뿐, 누가 이 이벤트를 수신할지에 대해서는 전혀 알지 못한다.
3.  **규칙 (Rule):** EventBridge의 핵심 두뇌다. 규칙은 이벤트 버스를 지나가는 모든 이벤트를 검사하여, 자신이 찾고 있는 특정 **이벤트 패턴(Event Pattern)**과 일치하는지를 확인한다. 이 패턴 매칭은 SNS의 단순한 속성 필터링을 넘어, 이벤트의 내용물, 즉 **JSON 구조의 깊은 곳까지** 들여다보고 복잡한 조건을 설정할 수 있다.
4.  **대상 (Target):** 규칙의 이벤트 패턴과 일치하는 이벤트가 발견되었을 때, 해당 이벤트를 전달받아 실행되는 대상이다. 대상은 Lambda 함수, SQS 큐, Step Functions 워크플로우 등 20가지가 넘는 다양한 AWS 서비스가 될 수 있다.

### SNS를 넘어 EventBridge로: 무엇이 다른가?

SNS 팬아웃 패턴과 EventBridge는 언뜻 비슷해 보이지만, 그 철학과 능력에는 근본적인 차이가 있다.

* **결합도 (Coupling):** SNS에서는 발행자가 '어떤 토픽'에 발행할지 명시적으로 알아야 한다. 하지만 EventBridge에서는 발행자는 그저 '기본 이벤트 버스'라는 공용 공간에 이벤트를 던져 넣기만 하면 된다. 발행자와 구독자 사이의 논리적 연결 고리가 완전히 사라지면서 **궁극의 디커플링**을 달성한다.
* **라우팅 능력 (Routing):** SNS의 필터링은 메시지의 속성(Attribute)에 국한된다. 반면, EventBridge의 규칙은 이벤트의 **내용(Content)** 자체를 기반으로 라우팅할 수 있다. 예를 들어, 우리는 다음과 같은 매우 구체적인 규칙을 만들 수 있다.
    * `"source": ["nextgen.orders"]` 이고,
    * `"detail-type": ["OrderPlaced"]` 이며,
    * `"detail": { "totalAmount": [{ "numeric": [">=", 1000] }] }` 인 이벤트.
    즉, "주문 서비스에서 발생한, 100만 원 이상의 고액 주문 이벤트"만을 정확하게 집어내어 '사기 탐지 서비스'로 보낼 수 있다. 이런 종류의 콘텐츠 기반 라우팅은 SNS만으로는 불가능하다.
* **생태계 통합 (Ecosystem Integration):** EventBridge는 AWS 서비스뿐만 아니라, Zendesk, Stripe, Shopify와 같은 수많은 외부 SaaS 파트너들과 기본적으로 통합되어 있다. 파트너 애플리케이션에서 발생하는 이벤트를 별도의 연동 코드 없이 우리 시스템의 이벤트 버스에서 직접 수신하여 비즈니스 로직을 트리거할 수 있다.

### NextGen Commerce 아키텍처의 진화

EventBridge를 도입함으로써, 'NextGen Commerce'의 아키텍처는 훨씬 더 단순하고, 유연하며, 확장 가능한 구조로 진화한다.

1.  모든 마이크로서비스(주문, 재고, 사용자 등)는 자신의 도메인에서 발생하는 모든 의미 있는 이벤트를 표준화된 JSON 형식으로 중앙 이벤트 버스에 발행한다.
2.  재고 서비스는 `{"source": "nextgen.orders", "detail-type": "OrderPlaced"}` 패턴을 가진 규칙을 생성하고, 자신의 SQS 큐를 타겟으로 지정한다.
3.  알림 서비스는 동일한 패턴을 가진 규칙을 생성하고, 이메일 발송 Lambda 함수를 타겟으로 지정한다.
4.  데이터 분석팀은 모든 `nextgen.` 소스로부터 발생하는 모든 이벤트를 받아 Kinesis Firehose로 전달하는 포괄적인 규칙을 생성한다.

이 구조에서는 발행자와 구독자가 완전히 분리된다. 주문 서비스는 자신의 이벤트가 재고 관리나 알림 발송에 사용된다는 사실 자체를 알 필요가 없다. 미래에 어떤 새로운 요구사항이 생기더라도, 기존 서비스의 코드는 단 한 줄도 변경할 필요 없이, 단지 이벤트 버스에 새로운 '규칙'을 하나 추가하는 것만으로 시스템의 기능을 무한히 확장해 나갈 수 있다.

SQS, SNS, EventBridge. 이 세 가지 서비스는 각각 대기열, 팬아웃, 이벤트 버스라는 각기 다른 역할을 수행하는 분산 시스템의 필수 접착제다. 이들을 언제, 어떻게 조합하여 사용해야 하는지 이해하는 것은, 개별 마이크로서비스의 집합을 단순한 합계를 넘어 시너지를 내는 하나의 유기적인 시스템으로 만드는 아키텍트의 핵심 역량이다.

이제 우리는 Part 2를 통해 견고한 토대를 모두 구축했다. 코드로 인프라를 정의했고(IaC), 그 위에 올릴 컴퓨팅 엔진을 선택했으며, 데이터를 저장할 데이터베이스를 설계했고, 이 모든 것을 연결할 네트워크와 메시징 시스템까지 완성했다. 이제 우리는 이 모든 재료를 가지고, Part 3에서 AWS Well-Architected Framework의 6가지 원칙이라는 설계도에 따라 실제 아키텍처를 구축하고 최적화하는 본격적인 여정을 시작할 준비가 되었다.