## 02. SNS: 다수의 구독자에게 메시지를 전파하는 팬아웃(Fan-out) 패턴

SQS가 하나의 작업을 하나의 워커에게 안정적으로 전달하는 일대일 통신에 최적화되어 있다면, 우리 시스템에서는 종종 하나의 이벤트가 발생했을 때, 서로 다른 여러 서비스가 각자의 목적을 위해 그 사실을 동시에 알아야 하는 경우가 발생한다. 'NextGen Commerce'에서 고객이 주문을 생성("OrderPlaced")했을 때를 다시 생각해 보자.

* **재고 서비스**는 이 사실을 알고 상품 재고를 차감해야 한다.
* **알림 서비스**는 고객에게 주문 확인 이메일을 발송해야 한다.
* **데이터 분석팀**은 이 주문 데이터를 실시간으로 수집하여 매출 대시보드를 업데이트해야 한다.

만약 SQS를 사용한다면, 주문 서비스는 재고 서비스용, 알림 서비스용, 분석용으로 각각 별도의 SQS 큐에 동일한 메시지를 세 번 보내야 할 것이다. 이는 비효율적일 뿐만 아니라, 나중에 이 이벤트를 구독해야 할 새로운 서비스가 추가될 때마다 주문 서비스의 코드를 수정해야 하는 **강한 결합**을 다시 만들어낸다.

이러한 **일대다(One-to-Many)** 비동기 통신 문제를 우아하게 해결하는 것이 바로 **Amazon SNS(Simple Notification Service)**다. SNS는 발행/구독(Publish/Subscribe, Pub/Sub) 모델을 기반으로, 하나의 메시지를 여러 구독자에게 동시에, 그리고 병렬적으로 전파하는 **팬아웃(Fan-out)** 패턴을 구현하는 데 사용되는 완전 관리형 메시징 서비스다.

### SNS의 작동 방식: 방송국과 라디오 청취자

SNS의 작동 원리는 라디오 방송국에 비유할 수 있다.



1.  **토픽 (Topic) - 라디오 채널:** 메시지를 발행하는 중앙 통신 채널이다. 'OrderPlaced' 이벤트는 'order-events'라는 이름의 토픽으로 발행된다.
2.  **발행자 (Publisher) - 라디오 DJ:** 토픽으로 메시지를 보내는 주체다. 주문 서비스는 'OrderPlaced' 이벤트가 발생하면, 그 내용을 담은 메시지를 'order-events' 토픽으로 발행한다. 발행자는 누가 이 채널을 듣고 있는지 전혀 알 필요도, 신경 쓸 필요도 없다.
3.  **구독자 (Subscriber) - 라디오 청취자:** 특정 토픽을 '구독'하여 메시지를 수신하는 대상이다. 재고 서비스, 알림 서비스, 분석 파이프라인은 각각 'order-events' 토픽을 구독한다.

DJ(발행자)가 특정 채널(토픽)로 방송(메시지)을 내보내면, 그 채널에 주파수를 맞추고 있는 모든 청취자(구독자)가 동시에 그 방송을 듣게 되는 것이다.

### 강력한 팬아웃: SQS와 Lambda의 결합

SNS의 진정한 힘은 다양한 종류의 구독자를 지원하는 유연성에서 나온다. 구독자는 SQS 큐, Lambda 함수, HTTP/S 엔드포인트, 이메일, SMS 등 매우 다양할 수 있다. 이 중 가장 강력하고 일반적으로 사용되는 패턴은 **SNS 토픽에 여러 SQS 큐를 구독시키는 것**이다.



'NextGen Commerce' 시나리오에 이 패턴을 적용해 보자.

1.  'order-events'라는 SNS 토픽을 생성한다.
2.  재고 서비스는 `inventory-queue`라는 SQS 큐를 생성하고, 이 큐를 'order-events' 토픽에 구독시킨다.
3.  알림 서비스는 `notification-queue`라는 SQS 큐를 생성하고, 역시 'order-events' 토픽에 구독시킨다.
4.  주문 서비스는 'OrderPlaced' 이벤트 메시지를 오직 'order-events' 토픽으로 **단 한 번만** 발행한다.
5.  SNS는 이 메시지를 복제하여 `inventory-queue`와 `notification-queue` 양쪽에 모두 전달한다.
6.  각 서비스의 워커(소비자)는 다른 서비스의 상태와 상관없이 자신의 SQS 큐에서 메시지를 가져와 독립적으로, 그리고 자신의 처리 속도에 맞춰 안전하게 작업을 수행한다.

이 아키텍처는 놀라운 수준의 **회복탄력성**과 **확장성**을 제공한다. 만약 알림 서비스에 장애가 발생하더라도, `notification-queue`에 메시지가 계속 쌓일 뿐, 재고 서비스는 아무런 영향 없이 `inventory-queue`의 메시지를 계속 처리할 수 있다. 나중에 '사기 탐지 서비스'가 새로 추가되어야 한다면? 주문 서비스의 코드는 단 한 줄도 건드릴 필요 없이, 새로운 SQS 큐를 만들고 토픽에 구독시키기만 하면 된다. 이처럼 SNS는 새로운 기능을 시스템에 추가할 때 기존 시스템에 미치는 영향을 제로(zero-impact)로 만드는 강력한 디커플링(decoupling) 도구다.

또한, **메시지 필터링(Message Filtering)** 기능을 사용하면 구독자는 토픽에 발행된 모든 메시지를 받는 대신, 자신이 관심 있는 특정 조건의 메시지만을 선택적으로 수신할 수 있다. 예를 들어, VIP 고객의 주문에 대해서만 특별한 알림을 보내는 서비스는 `"customer_type": "vip"`라는 속성을 가진 메시지만 필터링하여 구독할 수 있다.

SNS가 SQS와 함께 사용될 때, 우리는 신뢰성 있는 일대다 비동기 통신을 위한 완벽한 조합을 갖게 된다. 하지만 시스템이 수십, 수백 개의 마이크로서비스로 성장함에 따라, 수많은 SNS 토픽과 SQS 큐의 관계를 관리하는 것 자체가 또 다른 복잡성이 될 수 있다. 만약 시스템의 모든 이벤트를 단 하나의 중앙 버스에서 관리하고, 더 정교한 규칙에 따라 라우팅할 수 있다면 어떨까? 이것이 바로 다음 절에서 다룰, 현대 이벤트 기반 아키텍처의 신경망, EventBridge의 역할이다.