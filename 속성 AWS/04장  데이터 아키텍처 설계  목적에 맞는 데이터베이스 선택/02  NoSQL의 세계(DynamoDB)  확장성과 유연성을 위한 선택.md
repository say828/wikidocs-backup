## 02. NoSQL의 세계(DynamoDB): 확장성과 유연성을 위한 선택

관계형 데이터베이스가 엄격한 규칙과 질서의 세계라면, **NoSQL**은 자유와 속도, 그리고 무한한 확장의 세계다. 'Not Only SQL'의 약자인 NoSQL은 관계형 모델의 한계를 극복하기 위해 탄생한 데이터베이스 패러다임의 총칭이다. 이들은 관계형 데이터베이스의 강점인 **엄격한 일관성**과 **정규화된 스키마**를 과감히 포기하는 대신, 현대 인터넷 애플리케이션이 요구하는 **폭발적인 확장성(Scalability)**과 **데이터 모델의 유연성(Flexibility)**을 얻었다.

NoSQL의 철학을 이해하기 위해서는 **CAP 이론(CAP Theorem)**을 먼저 알아야 한다. CAP 이론은 분산 데이터 시스템이 세 가지 속성—**일관성(Consistency), 가용성(Availability), 분할 허용성(Partition Tolerance)**—중 최대 두 가지만을 동시에 보장할 수 있다는 원칙이다. 네트워크 장애(Partition)는 언제든 발생할 수 있는 현실이므로, 아키텍트는 사실상 일관성과 가용성 사이에서 고통스러운 선택을 해야만 한다.
* **관계형 데이터베이스**는 주로 **일관성(C)**을 선택한다. 네트워크 문제로 데이터 복제에 문제가 생기면, 일관성이 깨질 위험을 감수하느니 차라리 쓰기 요청을 거부(가용성 저하)하는 쪽을 택한다.
* **대부분의 NoSQL 데이터베이스**는 **가용성(A)**을 선택한다. 일부 노드에 장애가 발생하더라도 시스템은 계속해서 읽기/쓰기 요청을 받아들인다. 그 대가로, 잠시 동안 데이터의 일관성이 깨질 수 있는 **'최종 일관성(Eventual Consistency)'** 모델을 감수한다.

'NextGen Commerce'의 상품 추천 목록을 생각해 보자. A 사용자에게 방금 업데이트된 추천 상품 B가 0.1초 늦게 보이는 것이 비즈니스에 치명적인 문제인가? 전혀 그렇지 않다. 하지만 블랙프라이데이에 트래픽이 폭증했을 때, 추천 시스템이 다운되어 아무것도 보여주지 못한다면(가용성 저하), 이는 엄청난 매출 손실로 이어진다. 바로 이런 워크로드에서 NoSQL은 빛을 발한다.

### Amazon DynamoDB: 클라우드 네이티브 NoSQL의 정수

AWS의 NoSQL 포트폴리오의 심장이자, 아마존닷컴이라는 거대한 이커머스 제국을 떠받치는 핵심 기술이 바로 **Amazon DynamoDB**다. DynamoDB는 키-값(Key-Value) 및 문서(Document) 데이터 모델을 지원하는 완전 관리형 서버리스 NoSQL 데이터베이스다. 그 어떤 데이터베이스보다 '클라우드 네이티브'라는 단어에 어울리는 DynamoDB의 특징은 다음과 같다.

* **무한에 가까운 수평 확장성:** DynamoDB는 테이블의 크기나 트래픽 양에 상관없이, 지속적으로 **한 자릿수 밀리초(single-digit millisecond)**의 응답 시간을 보장하도록 설계되었다. 데이터가 테라바이트, 페타바이트로 늘어나도 성능은 저하되지 않는다. 이는 내부적으로 데이터를 파티셔닝하여 수많은 서버에 자동으로 분산 저장하는 아키텍처 덕분이다.
* **완전 서버리스:** 사용자는 서버, 디스크, OS, 패치에 대해 전혀 신경 쓸 필요가 없다. 테이블을 생성하고, 읽기/쓰기 용량 모드를 선택(또는 사용한 만큼 지불하는 On-Demand)하면 나머지는 AWS가 모두 처리한다.
* **스키마의 유연성:** DynamoDB는 스키마가 없는(Schemaless) 데이터베이스다. 각 항목(Item)은 기본 키(Primary Key)만 가지고 있다면, 서로 다른 속성(Attribute)과 구조를 가질 수 있다. 이는 비즈니스 요구사항에 따라 데이터 모델이 끊임없이 진화하는 스타트업 환경에 완벽하게 부합한다. 어제는 없던 '한정판' 속성을 오늘 당장 상품 데이터에 추가하는 데 아무런 제약이 없다.

### DynamoDB 선택의 대가: 사고의 전환

이처럼 강력한 확장성과 유연성은 공짜로 얻어지지 않는다. DynamoDB를 제대로 사용하기 위해서는 관계형 데이터베이스에 익숙해진 우리의 뇌를 완전히 다른 방식으로 전환해야 한다.

가장 큰 차이점은 **쿼리 방식**이다. SQL에서는 `JOIN`, `GROUP BY`, `WHERE` 절의 복잡한 조합을 통해 어떤 방식으로든 데이터를 조회할 수 있다고 믿었다. DynamoDB에서는 그런 자유가 없다. 데이터를 어떻게 조회할 것인지, 즉 **애플리케이션의 접근 패턴(Access Pattern)**을 테이블 설계 단계에서 **미리** 완벽하게 예측하고 정의해야 한다. 기본 키(Primary Key)나 인덱스(Secondary Index)를 통하지 않는 쿼리는 극도로 비효율적이거나 불가능하다.

이는 마치 잘 정리된 도서관과 같다. 도서 분류 번호(기본 키)를 알고 가면 1분 안에 책을 찾을 수 있지만, "표지가 파랗고 두꺼운 책"을 찾아달라고 하면 사서는 당신을 도와줄 수 없다.

### NextGen Commerce를 위한 DynamoDB 활용 사례

이러한 특성을 고려할 때, 'NextGen Commerce'의 어떤 마이크로서비스가 DynamoDB의 완벽한 파트너가 될 수 있을까?

* **상품 카탈로그 서비스:** 상품의 속성은 의류, 전자제품 등 카테고리마다 천차만별이며, 마케팅 이벤트에 따라 수시로 바뀐다. DynamoDB의 유연한 스키마는 이러한 변화를 손쉽게 수용할 수 있다. `productId`를 기본 키로 하여 특정 상품을 빠르게 조회하는 접근 패턴이 대부분을 차지하므로 DynamoDB에 이상적이다.
* **장바구니 서비스:** 장바구니 데이터는 사용자의 활동에 따라 폭발적으로 늘어날 수 있으며, 데이터 구조도 간단하다. `userId`를 키로 하여 사용자의 장바구니 정보를 빠르게 읽고 쓰는 작업이 핵심이다.
* **사용자 세션 관리:** 사용자의 로그인 세션 정보는 수명이 짧고, 대규모 트래픽을 처리해야 하며, 강력한 일관성을 요구하지 않는다.

관계형 데이터베이스가 시스템의 '안정적인 뼈대' 역할을 한다면, DynamoDB는 변화에 민첩하게 반응하고 폭발적으로 성장하는 '근육과 피부' 역할을 한다. 주문 처리와 같은 핵심 트랜잭션은 Aurora의 일관성에 맡기고, 그 외의 역동적인 데이터는 DynamoDB의 확장성과 유연성에 맡기는 것. 이것이 바로 **목적에 맞는 데이터베이스를 선택하는 Polyglot Persistence의 지혜**다.

하지만 사용자가 상품을 검색하고 주문하는 과정에서 매번 데이터베이스를 직접 조회하는 것은 비효율적이고 비용도 많이 든다. 이제 우리는 성능과 비용 사이에서 아슬아슬한 줄타기를 하며 사용자 경험을 극적으로 향상시키는 기술, 캐싱의 세계로 들어갈 준비가 되었다.