# 06장: 분산 시스템의 접착제: SQS, SNS, EventBridge

우리는 VPC라는 견고한 혈관계 위에 마이크로서비스라는 개별 장기들을 성공적으로 배치했다. 각 서비스는 독립적으로 자신의 역할을 수행할 준비를 마쳤다. 하지만 이 장기들이 서로 어떻게 소통하고 협력하여 하나의 유기적인 생명체를 이룰 수 있을까? 만약 심장(주문 서비스)이 폐(재고 서비스)에게 산소를 요청할 때, 폐가 즉시 응답할 때까지 심장이 멈춰 서서 기다려야 한다면 어떻게 될까? 폐에 작은 문제가 생기는 순간, 심장마비로 이어져 생명체 전체가 위험에 빠질 것이다.

이것이 바로 마이크로서비스 아키텍처에서 **동기(Synchronous) 통신**이 가진 본질적인 위험이다. 서비스들이 서로를 직접 API로 호출하고 응답을 기다리는 강한 결합(Tight Coupling)은 하나의 서비스 장애가 시스템 전체로 퍼져나가는 **연쇄 장애(Cascading Failure)**의 주범이다.

이 장에서는 이 동기 호출의 저주에서 벗어나, 시스템의 회복탄력성(Resilience)과 확장성(Scalability)을 극대화하는 **비동기(Asynchronous) 통신**의 세계를 탐험한다. 우리는 서비스들을 느슨하게 결합(Loosely Coupled)하여 서로의 상태에 영향을 받지 않고 독립적으로 작동하게 만드는 세 가지 핵심 도구를 배울 것이다. 이들은 마치 강력한 접착제처럼, 흩어져 있는 마이크로서비스들을 하나의 견고하고 유연한 시스템으로 엮어준다. 신뢰성 있는 작업 큐를 위한 **SQS**, 다수의 구독자에게 메시지를 전파하는 **SNS**, 그리고 시스템의 중앙 신경망 역할을 하는 **EventBridge**가 바로 그 주인공이다. 이 장을 마치고 나면, 당신은 더 이상 불안정한 API 호출에 의존하는 대신, 장애를 스스로 격리하고 우아하게 처리하는 진정한 분산 시스템을 설계할 수 있게 될 것이다.

---

## 00. 동기(Synchronous) 호출의 저주와 비동기(Asynchronous)의 축복

클라우드 네이티브로의 여정을 막 시작한 많은 팀들이 저지르는 가장 흔한 실수는, 모놀리식 애플리케이션 내부에서 함수를 호출하던 방식을 마이크로서비스 환경에 그대로 가져오는 것이다. 즉, 서비스 A가 서비스 B의 기능이 필요할 때, 서비스 B의 REST API를 직접 호출하고 응답이 올 때까지 하염없이 기다리는 **동기(Synchronous) 호출**에 의존하는 것이다.

'NextGen Commerce'의 주문 처리 과정을 예로 들어보자. 사용자가 '주문하기' 버튼을 누르면, 주문 서비스(A)는 다음과 같은 일들을 순차적으로, 동기적으로 처리해야 할 수 있다.

1.  재고 서비스(B)를 호출하여 상품 재고를 확인하고 차감한다.
2.  결제 서비스(C)를 호출하여 사용자의 신용카드를 승인받는다.
3.  알림 서비스(D)를 호출하여 고객에게 주문 확인 이메일을 발송한다.



이 아키텍처는 표면적으로는 논리적이지만, 다음과 같은 **동기 호출의 저주**에 깊이 빠져있다.

* **연쇄 장애 (Cascading Failures):** 만약 알림 서비스(D)에 일시적인 장애가 발생하거나 응답이 느려지면 어떻게 될까? 주문 서비스(A)는 이메일 발송이 완료될 때까지 계속 기다리다가 결국 타임아웃에 빠지고, 사용자에게는 주문 실패 오류를 반환하게 된다. 실제로는 재고 처리와 결제라는 핵심 기능이 모두 성공했음에도 불구하고, 상대적으로 덜 중요한 부가 기능의 장애가 전체 시스템의 장애로 확산된 것이다. 이것이 바로 **강한 결합(Tight Coupling)**이 낳는 비극이다.
* **성능 병목 (Performance Bottlenecks):** 전체 주문 처리 시간은 각 서비스 호출 시간의 총합(`T_total = T_A + T_B + T_C + T_D`)이 된다. 이 중 가장 느린 서비스 하나가 전체 시스템의 응답 속도를 결정하게 된다.
* **낮은 회복탄력성 (Low Resilience):** 재고 서비스(B)가 잠시 다운되었다가 복구되었다고 가정해 보자. 그사이에 실패했던 모든 주문 요청은 영원히 사라진다. 개발자가 수동으로 재시도 로직을 정교하게 구현하지 않는 한, 시스템은 일시적인 장애로부터 스스로 회복할 능력이 없다.

이 저주를 풀기 위한 축복이 바로 **비동기(Asynchronous) 통신**이다. 비동기 통신은 서비스들이 서로에게 직접 말(API 호출)을 거는 대신, **메시지**나 **이벤트**라는 편지를 중간의 우체통에 넣어두고 자신의 다음 일로 넘어가는 방식이다. 편지를 받는 쪽은 자신이 편할 때 우체통에서 편지를 꺼내 읽고 처리하면 된다. 보내는 쪽과 받는 쪽은 서로의 존재나 상태에 대해 전혀 알 필요가 없다.

이 비동기 패러다임을 적용하여 주문 처리 과정을 재설계해 보자.

1.  사용자가 '주문하기' 버튼을 누르면, 주문 서비스는 가장 핵심적인 책임인 **주문 데이터를 데이터베이스에 기록**하는 일만 수행한다.
2.  그리고 **"OrderPlaced (주문 생성됨)"**이라는 **이벤트**를 발행한다.
3.  주문 서비스는 즉시 사용자에게 "주문이 성공적으로 접수되었습니다"라고 응답한다. 사용자는 1초도 안 되어 빠른 응답을 받는다.
4.  재고 서비스, 결제 서비스, 알림 서비스는 "OrderPlaced" 이벤트를 구독하고 있다가, 각자 독립적으로 이벤트를 받아 자신의 역할을 비동기적으로 수행한다.



이 아키텍처에서 알림 서비스에 장애가 발생하더라도, 주문 접수 자체에는 아무런 영향을 미치지 않는다. 알림 서비스가 복구되면, 그동안 쌓여있던 이벤트를 처리하여 이메일을 발송하면 그만이다. 각 서비스는 다른 서비스의 장애로부터 완벽하게 격리된다. 이것이 바로 **느슨한 결합(Loose Coupling)**이 가져다주는 **비동기의 축복**이다.

이제, 이 비동기 통신이라는 축복을 현실로 만들어 줄 AWS의 세 가지 핵심 도구—SQS, SNS, EventBridge—를 각각 어떻게 사용해야 하는지 구체적으로 살펴보자.