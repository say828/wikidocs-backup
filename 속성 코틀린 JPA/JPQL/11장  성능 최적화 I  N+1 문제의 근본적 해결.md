# 11장: 성능 최적화 I: N+1 문제의 근본적 해결

지금까지 우리는 JPA라는 강력한 도끼를 다루는 법을 배웠다. 객체를 테이블에 매핑하여 데이터라는 나무를 원하는 모양으로 깎고, JPQL과 스프링 데이터 JPA를 사용하여 필요한 나무를 정확하게 찾아내는 방법까지 마스터했다. 하지만 아무리 좋은 도끼라도 무작정 휘두르기만 하면 숲 전체를 망가뜨릴 수 있다. 진짜 장인은 최소한의 움직임으로 최대의 효율을 내는 법을 안다.

지금부터 시작될 두 개의 장(11장, 12장)은 바로 이 '효율', 즉 **성능 최적화**에 관한 이야기다. 지금까지 배운 모든 지식을 기반으로, 실제 운영 환경에서 마주하게 될 가장 치명적이고 흔한 성능 문제들을 진단하고 해결하는 실전 기술을 연마할 것이다.

그 첫 번째 관문은 바로 JPA 사용의 숙련도를 가늠하는 영원한 숙제, **N+1 문제**다. 우리는 7장에서 페치 조인을 통해 이 문제의 맛을 보았지만, 그것은 거대한 빙산의 일각에 불과했다. 이번 장에서는 N+1 문제가 발생하는 모든 시나리오를 낱낱이 해부하고, 페치 조인을 포함하여 `@BatchSize`, `@EntityGraph` 등 N+1 문제를 해결하는 모든 무기들의 사용법과 장단점을 완벽하게 마스터할 것이다. 이 장을 마치면, 여러분은 더 이상 N+1이라는 유령에 떨지 않고, 어떤 상황에서도 최적의 쿼리를 설계하는 성능 전문가로 거듭나게 될 것이다.

-----

## 00\. N+1 문제의 발생 원리: EAGER, LAZY 그리고 JPQL

N+1 문제는 JPA 성능의 알파이자 오메가다. 이 문제를 다시 한번 명확하게 정의하고, 어떤 상황에서 우리를 괴롭히는지 그 발생 원리를 유형별로 분석해 보자.

**N+1 문제란?**

> **1번의 쿼리로 N개의 엔티티를 조회했는데, 조회된 N개의 엔티티가 각자 연관된 데이터를 로딩하기 위해 N번의 추가 쿼리가 발생하는 현상.**

결과적으로 단 하나의 비즈니스 로직을 처리하기 위해 총 `1 + N`번의 SQL이 데이터베이스로 전송되어 심각한 성능 저하를 유발한다.

-----

### **발생 원인 1: JPQL과 즉시 로딩(EAGER)의 배신**

많은 개발자들이 연관관계의 페치 전략을 `FetchType.EAGER`로 설정하면 N+1 문제가 해결될 것이라고 착각한다. `entityManager.find()`를 사용할 때는 그 말이 맞다. JPA가 조인을 통해 연관된 엔티티를 함께 가져오기 때문이다. 하지만 **JPQL을 사용하는 순간, 이 믿음은 배신당한다.**

```kotlin
// Team.members는 FetchType.EAGER로 설정되어 있다고 가정
@OneToMany(mappedBy = "team", fetch = FetchType.EAGER)
var members: MutableList<Member> = mutableListOf()
```

```kotlin
// JPQL로 모든 팀을 조회한다.
val jpql = "SELECT t FROM Team t"
val teams = entityManager.createQuery(jpql, Team.class.java).resultList // 쿼리 1번
```

**JPQL은 작성된 쿼리 문자열을 우선적으로 존중**한다. 위 쿼리는 `Team`만 조회하라고 명시했으므로, JPA는 `Team`을 조회하는 SQL만 실행한다. `members` 필드가 EAGER인 것은 신경 쓰지 않는다.

문제는 그 다음이다.

1.  JPQL의 결과로 `Team` 엔티티들을 영속성 컨텍스트에 로드한다. (예: 10개의 팀)
2.  JPA는 각 `Team` 엔티티를 로드하면서, "어? `members` 필드가 `EAGER`네? 당장 로드해야겠다\!"라고 판단한다.
3.  결국 10개의 `Team` 각각에 대해 `members`를 로드하기 위한 `SELECT * FROM Member WHERE team_id = ?` 쿼리를 **10번** 추가로 실행한다.

**결과**: `EAGER`로 설정했음에도 불구하고, JPQL을 사용했다는 이유만으로 **1+N** 문제가 발생한다.

-----

### **발생 원인 2: 지연 로딩(LAZY)과 순회**

`FetchType.LAZY`는 N+1 문제의 가장 전형적인 원인이다. 7장에서 이미 살펴본 내용이지만, 다시 한번 복기해 보자.

1.  JPQL로 모든 팀을 조회한다. (쿼리 1번) `members`는 프록시 컬렉션이다.
2.  반복문을 돌며 각 팀의 `members` 컬렉션에 접근한다.
3.  `team.members.size()`처럼 컬렉션에 **최초로 접근하는 순간**, 해당 팀의 `members`를 로드하기 위한 추가 쿼리가 발생한다. 이 과정이 N개의 팀에 대해 N번 반복된다.

**결과**: EAGER와 동일하게 **1+N** 문제가 발생한다. 다만, EAGER는 JPQL 실행 시점에 즉시 발생하고, LAZY는 연관 데이터를 실제 사용하는 시점에 지연되어 발생한다는 차이만 있을 뿐이다.

-----

`EAGER`는 우리가 원하지 않는 데이터까지 조회하는 '과잉 조회'의 문제를 낳고, `LAZY`는 순회 시 N+1 문제를 피할 수 없다. 그렇다면 해결책은 무엇일까? 우리가 7장에서 배운 첫 번째 해결책, 페치 조인을 다시 한번 소환하여 그 원리와 한계를 명확히 짚어보자.