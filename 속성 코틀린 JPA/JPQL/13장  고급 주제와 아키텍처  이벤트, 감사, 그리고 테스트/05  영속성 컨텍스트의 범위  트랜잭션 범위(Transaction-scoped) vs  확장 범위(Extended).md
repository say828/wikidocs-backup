## 05. 영속성 컨텍스트의 범위: 트랜잭션 범위(Transaction-scoped) vs. 확장 범위(Extended)

우리가 지금까지 당연하게 여겨왔던 사실이 있다. 바로 "하나의 트랜잭션은 하나의 영속성 컨텍스트를 가진다"는 것이다. 스프링 환경에서 `@Transactional` 메서드가 시작될 때 영속성 컨텍스트가 생성되고, 메서드가 끝날 때 함께 사라지는 이 방식을 **트랜잭션 범위 영속성 컨텍스트(Transaction-scoped Persistence Context)**라고 부른다. 이것이 JPA를 사용하는 가장 일반적이고 표준적인 방식이다.

하지만 JPA는 이와 다른 범위의 영속성 컨텍스트도 지원하는데, 바로 **확장 범위 영속성 컨텍스트(Extended Persistence Context)**다. 이 둘의 차이를 이해하는 것은 우리가 작성하는 코드의 상태 관리(State Management) 방식을 결정하는 중요한 아키텍처적 선택이다.

---

### **1. 트랜잭션 범위 영속성 컨텍스트 (Transaction-scoped) - ⭐️ 표준, 권장**

이것이 우리가 계속 사용해 온 방식이다.
* **생명주기**: 트랜잭션의 시작과 생명주기를 같이한다. 서비스 계층의 `@Transactional` 메서드가 호출될 때 생성되고, 메서드가 종료될 때 함께 제거된다.
* **특징**: 트랜잭션이 다르면 영속성 컨텍스트도 다르다. 따라서 서로 다른 트랜잭션에서는 1차 캐시가 공유되지 않으며, 한 트랜잭션에서 조회한 엔티티는 다른 트랜잭션에서는 준영속 상태로 취급된다.
* **장점**:
    * **단순함**: 데이터 접근 로직이 트랜잭션 안에서 모두 끝나므로 상태를 예측하기 쉽다.
    * **안전함**: 트랜잭션 간의 데이터 격리가 확실하여 동시성 문제로부터 비교적 자유롭다.
    * **확장성**: 짧은 생명주기는 데이터베이스 커넥션을 빠르게 반환하여, 높은 트래픽 환경에서優れたスケーラビリティ(확장성)를 보인다.
* **적합한 환경**: 대부분의 웹 애플리케이션, REST API 등 상태 비저장(Stateless) 아키텍처에 완벽하게 부합한다.

---

### **2. 확장 범위 영속성 컨텍스트 (Extended)**

확장 범위 영속성 컨텍스트는 트랜잭션의 범위를 넘어, 여러 트랜잭션에 걸쳐 **동일한 영속성 컨텍스트 인스턴스가 유지**되는 방식이다. 보통 사용자의 '대화(Conversation)'나 '세션(Session)'과 같은 더 긴 생명주기를 가진 컴포넌트의 스코프에 맞춰 사용된다.

* **생명주기**: 보통 `@SessionScope`나 `@ConversationScope` 같은 특정 스코프를 가진 스프링 빈의 생명주기와 같이한다. 개발자가 영속성 컨텍스트를 수동으로 종료(`em.close()`)하기 전까지 계속 살아있다.
* **특징**: 여러 트랜잭션(메서드 호출)에 걸쳐 1차 캐시와 영속 상태가 유지된다. 첫 번째 트랜잭션에서 조회한 엔티티를 별도의 `merge` 없이 두 번째 트랜잭션에서 수정하면, 변경 감지가 그대로 동작한다.
* **단점**:
    * **데이터 불일치 위험**: 오랜 시간 살아있는 영속성 컨텍스트는 데이터베이스의 실제 상태와 달라질 위험(Stale Data)이 크다.
    * **메모리 누수**: 많은 엔티티를 조회한 채로 영속성 컨텍스트를 닫지 않으면 메모리 누수가 발생할 수 있다.
    * **복잡성**: 상태를 계속 유지해야 하므로 코드가 복잡해지고 예측하기 어려워진다.

> **결론: 확장(Extended) 범위는 사용하지 마라.**
>
> 확장 범위 영속성 컨텍스트는 과거 Java EE의 상태 유지 세션 빈(Stateful Session Bean)과 같은 특정 환경을 위해 고안된 기능이다. 현대적인 스프링 기반의 상태 비저장 웹 애플리케이션 아키텍처와는 잘 맞지 않으며, 오히려 수많은 부작용과 복잡성만 낳는 **안티패턴**에 가깝다.
>
> **'트랜잭션 범위 영속성 컨텍스트'**가 JPA를 사용하는 가장 올바르고 안전하며 효율적인 방법이다.

---

이것으로 JPA의 고급 주제와 아키텍처에 대한 탐험을 마쳤다. 우리는 엔티티의 생명주기 이벤트를 다루는 방법부터 시작하여, Auditing을 통한 공통 기능 자동화, `@DataJpaTest`를 이용한 견고한 테스트, 그리고 DDD 관점의 리포지토리 설계까지, JPA를 중심으로 애플리케이션을 더 성숙하게 만드는 방법을 배웠다.

지금까지의 여정은 'JPA'라는 표준 기술에 대한 깊은 이해를 쌓는 과정이었다. 이제 마지막으로, 이 강력한 JPA 기술을 '코틀린(Kotlin)'이라는 현대적인 언어와 어떻게 결합하여 시너지를 낼 수 있는지, 그 구체적인 기법들을 다음 14장에서 알아볼 것이다.