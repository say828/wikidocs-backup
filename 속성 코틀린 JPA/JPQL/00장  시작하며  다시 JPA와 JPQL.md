# 00장: 시작하며: 다시 JPA와 JPQL

객체지향 프로그래밍에 익숙한 우리에게 데이터베이스는 늘 어색한 존재였다. 객체는 상속, 다형성, 연관관계라는 유연한 무기를 갖추고 세상을 모델링하지만, 관계형 데이터베이스는 정규화된 테이블의 평면적인 세계에 모든 것을 구겨 넣어야 한다. `Member` 객체를 저장하기 위해 우리는 `INSERT`라는 SQL 구문을 배워야 했고, 객체 그래프를 탐색하는 대신 여러 테이블을 `JOIN`하는 복잡한 쿼리를 작성해야 했다. 이 근본적인 불일치, 바로 **패러다임 불일치(Paradigm Mismatch)**가 수많은 버그와 장황한 데이터 접근 코드(DAO)를 낳았다.

JPA(Java Persistence API)는 이 거대한 간극을 메우기 위해 탄생한 자바 진영의 표준 기술 명세(Standard Specification)다. 개발자가 SQL이 아닌 객체지향적인 코드로 데이터베이스를 다룰 수 있게 해줌으로써, 비즈니스 로직에 더 집중할 수 있는 환경을 만들어 주었다. `.save(member)` 한 줄이면 `INSERT` 쿼리가 만들어지고, `team.getMembers()`를 호출하면 `JOIN`이 처리되는 세상. JPA는 분명 개발자의 생산성을 극적으로 끌어올린 혁신적인 기술이다.

하지만 이 편리함 뒤에는 복잡한 내부 동작 원리가 숨어있다. 많은 개발자들이 JPA를 그저 "SQL을 대신 만들어주는 도구" 정도로만 여기고, 영속성 컨텍스트, N+1 문제, 페치 전략 같은 핵심 개념을 간과한 채 실무에 뛰어든다. 그 결과는 참담하다. 처음엔 잘 동작하는 것처럼 보이던 애플리케이션이 데이터가 조금만 쌓여도 `LazyInitializationException`을 뿜어내고, 간단한 조회 기능 하나가 수백, 수천 개의 쿼리를 발생시키며 서버를 마비시키는 상황을 마주하게 된다.

이 책은 바로 그 지점에서 시작한다. 단순한 API 사용법을 나열하는 것을 넘어, **JPA가 왜 그렇게 동작하는지** 그 근본 원리를 파헤친다. 영속성 컨텍스트의 심장부로 들어가보고, JPQL이 어떻게 객체지향 쿼리에서 SQL로 번역되는지 추적하며, 성능 저하의 주범들을 하나씩 해결해 나갈 것이다. 최신 코틀린과 스프링 생태계 위에서, 가장 실용적이고 최적화된 코드로 이 모든 여정을 함께한다. 이 책을 덮는 순간, 당신은 더 이상 JPA를 두려워하지 않고, 어떤 복잡한 데이터 요구사항 앞에서도 자신감 있게 최적의 아키텍처를 설계하는 전문가로 거듭나 있을 것이다.

## 00. 이 책의 특징 및 접근 방식

시중에는 이미 JPA에 관한 많은 자료가 있다. 이 책은 기존 자료들과 더불어, 다음과 같은 부분에 초점을 맞춰 독자들의 깊이 있는 학습을 돕고자 한다.

JPA를 학습하는 과정에서 많은 개발자가 겪는 어려움은 다음과 같이 요약할 수 있다.

1.  **'Why'에 대한 설명 부족:** API 사용법(How)은 알지만, 해당 기능이 왜 그렇게 설계되었는지(Why)에 대한 근본적인 이해가 부족하여 문제 해결에 어려움을 겪는 경우가 있다. 예를 들어 `@OneToMany` 관계에서 `FetchType.LAZY`가 기본값인 이유를 이해하면 N+1 문제를 더 효과적으로 예방할 수 있다.
2.  **이론과 실제 환경의 차이:** 영속성 컨텍스트의 1차 캐시, 쓰기 지연, 변경 감지 등의 개념을 이론적으로 학습하더라도, 스프링의 `@Transactional`과 같은 실제 트랜잭션 환경에서 이러한 개념이 어떻게 적용되고 성능에 영향을 미치는지 연결하기 어려울 수 있다.
3.  **최신 개발 환경의 예제 부족:** 다수의 예제가 전통적인 자바 문법을 기반으로 하고 있어, 코틀린의 데이터 클래스, 불변성 등 최신 언어의 장점을 JPA와 함께 활용하는 방법을 충분히 보여주지 못하는 아쉬움이 있었다.

이 책은 위와 같은 점들을 보완하여, 코틀린과 스프링 환경에서 JPA를 효과적으로 사용하려는 개발자들에게 실질적인 가이드를 제공하는 것을 목표로 하며, 다음과 같은 특징을 가진다.

* **원리 중심의 접근:** 각 기능이 어떤 문제를 해결하기 위해 고안되었는지 설계 배경과 철학을 함께 설명하여 근본적인 이해를 돕는다.
* **증명 기반의 실용적 예제:** 최적화 기법 등을 설명할 때, 개선 전(Before) 코드와 개선 후(After) 코드를 비교하고 실제 실행된 SQL 로그를 통해 성능 개선 효과를 명확히 보여준다. 이를 통해 독자들이 데이터에 기반하여 기술을 선택하는 능력을 기르도록 돕는다.
* **최신 코틀린과 스프링 생태계 반영:** 모든 예제는 최신 스프링 부트 3.x+, 하이버네이트 6.x+, 코틀린 1.9+ 환경을 기준으로 작성했다. 코틀린의 특성을 활용하여 생산성과 안정성을 높이는 숙련된(Idiomatic) 코드 작성법을 제시한다.
* **실무 문제 해결을 위한 깊이 있는 주제:** N+1 문제의 근본적인 해결책(패치 조인, `@BatchSize`, `@EntityGraph`), 동시성 제어를 위한 잠금(Locking) 메커니즘, 대용량 데이터 처리 기법 등 실무에서 마주칠 수 있는 복잡한 문제들을 해결하기 위한 심도 있는 주제를 다룬다.

이 책은 JPA의 내부 동작 원리를 체계적으로 이해하고, 이를 바탕으로 실제 프로젝트에서 발생하는 다양한 문제에 효과적으로 대응할 수 있는 역량을 기르는 데 도움을 주고자 한다. 이제 객체와 관계형 데이터베이스의 조화로운 공존을 위한 여정을 시작해보자.