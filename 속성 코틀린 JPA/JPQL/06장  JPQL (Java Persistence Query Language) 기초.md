# 06장: JPQL (Java Persistence Query Language) 기초

지금까지 우리는 JPA의 세계를 지탱하는 두 개의 큰 기둥, \*\*'영속성 관리'\*\*와 \*\*'객체-테이블 매핑'\*\*을 모두 세웠다. `EntityManager`가 영속성 컨텍스트를 통해 엔티티의 생명주기를 어떻게 관리하는지, 그리고 다양한 어노테이션을 통해 객체 모델을 데이터베이스 스키마에 어떻게 정교하게 반영하는지 모두 배웠다.

하지만 아직 한 가지 중요한 과제가 남아있다. 바로 우리가 원하는 데이터를 \*\*'검색'\*\*하는 것이다. `entityManager.find()`는 오직 기본 키(`@Id`)를 통한 단 건 조회만 가능하다. 만약 "나이가 20살 이상인 모든 회원을 찾아라" 또는 "특정 팀에 소속된 회원들을 이름순으로 정렬하라" 와 같은 복잡한 조건의 검색이 필요하다면 어떻게 해야 할까?

물론 순수한 SQL(Native SQL)을 사용할 수도 있지만, 이는 JPA가 애써 만들어 놓은 객체와 테이블 사이의 추상화 계층을 무너뜨리는 행위다. 이 문제를 해결하기 위해 JPA는 자체적인 표준 쿼리 언어를 제공하는데, 이것이 바로 \*\*JPQL(Java Persistence Query Language)\*\*이다.

이번 장에서는 JPQL의 탄생 배경과 SQL과의 결정적인 차이점부터 시작하여, 가장 기본이 되는 `SELECT`, `FROM`, `WHERE` 절의 사용법을 배운다. 더 나아가 엔티티 전체가 아닌 특정 필드만 조회하는 프로젝션(Projection), 조회 결과를 DTO(Data Transfer Object)로 직접 변환하는 실용적인 방법, 그리고 안전한 파라미터 바인딩과 페이징 API까지, JPQL의 기초를 탄탄하게 다져나갈 것이다. 이 장을 마치면, 여러분은 더 이상 `find()`에만 의존하지 않고, 원하는 데이터를 자유자재로 검색할 수 있는 강력한 무기를 손에 쥐게 될 것이다.

-----

## 00\. JPQL의 등장 배경: SQL과 Criteria의 중간점

JPA를 사용하면서 왜 그냥 익숙한 SQL을 쓰면 안 되고, JPQL이라는 새로운 언어를 배워야 하는 걸까? 여기에는 JPA의 설계 철학과 직결되는 중요한 이유가 있다.

### **SQL을 직접 사용할 수 없는 이유**

JPA의 가장 큰 목적은 개발자가 테이블이 아닌 **객체 중심**으로 사고하고 개발할 수 있도록 돕는 것이다. 그런데 만약 우리가 SQL을 직접 사용한다면 어떻게 될까?

```sql
-- 만약 SQL을 직접 쓴다면...
SELECT * FROM MBR_TBL WHERE USER_NM = 'Kim'
```

개발자는 `Member` 엔티티가 `MBR_TBL`이라는 테이블에, `username` 필드가 `USER_NM`이라는 컬럼에 매핑되어 있다는 사실을 모두 알고 있어야 한다. 이는 JPA가 제공하는 추상화의 이점을 포기하고 다시 데이터베이스 종속적인 코드로 회귀하는 것을 의미한다. 만약 테이블 이름이 바뀌거나, 특정 데이터베이스의 SQL 방언(Dialect)에 의존적인 코드를 작성했다면, 애플리케이션의 유연성과 이식성은 크게 저하될 것이다.

### **Criteria API의 한계**

이런 문제를 해결하기 위해 JPA는 SQL처럼 문자열로 쿼리를 작성하는 대신, 자바 코드로 쿼리를 조립해나가는 **Criteria API**라는 대안도 제공한다.

```java
// Criteria API 예시 (매우 장황하고 복잡하다)
CriteriaBuilder cb = em.getCriteriaBuilder();
CriteriaQuery<Member> query = cb.createQuery(Member.class);
Root<Member> m = query.from(Member.class);
query.select(m).where(cb.equal(m.get("username"), "Kim"));
List<Member> resultList = em.createQuery(query).getResultList();
```

Criteria는 컴파일 시점에 쿼리의 문법 오류를 잡을 수 있는 '타입 세이프(Type-Safe)'한 방식이라는 장점이 있지만, 보시다시피 코드가 매우 길고 장황하며 직관적이지 않다. 간단한 쿼리조차 작성하기가 고통스럽고 가독성이 떨어진다는 치명적인 단점이 있다. (이 때문에 실무에서는 Criteria 대신 QueryDSL이라는 라이브러리를 주로 사용한다.)

### **JPQL: 가장 실용적인 중간 지점**

**JPQL**은 바로 이 SQL과 Criteria의 장단점 사이에서 가장 실용적인 균형점을 찾은 해결책이다.

  * **SQL과 유사한 문법**: JPQL은 `SELECT`, `FROM`, `WHERE` 등 SQL과 매우 유사한 텍스트 기반의 문법을 사용하므로 개발자가 쉽게 배우고 읽을 수 있다.
  * **객체지향 쿼리**: JPQL은 SQL과 달리 데이터베이스 테이블이 아닌 **엔티티 객체와 그 필드를 대상**으로 쿼리한다. 개발자는 더 이상 테이블명이나 컬럼명을 신경 쓸 필요 없이, 오직 `Member`, `username`과 같은 객체 모델에만 집중하면 된다.
  * **데이터베이스 방언 독립성**: JPQL은 JPA의 표준 명세에 포함된 언어다. 따라서 우리가 JPQL로 쿼리를 작성하면, JPA 구현체(하이버네이트 등)가 이를 각 데이터베이스(MySQL, Oracle, PostgreSQL 등)의 고유한 SQL 방언에 맞춰 알아서 번역해준다.

결론적으로 JPQL은 SQL의 친숙함과 가독성을 유지하면서도, JPA의 객체지향적인 추상화와 데이터베이스 독립성이라는 장점을 모두 누릴 수 있게 해주는 가장 합리적이고 실용적인 데이터 검색 방법이다. 이제 SQL과는 미묘하게 다른 JPQL의 세계로 본격적으로 들어가 보자.