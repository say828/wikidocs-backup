## 01\. JPQL vs. SQL: 결정적인 차이 (테이블이 아닌 엔티티 객체 기준)

JPQL은 SQL과 매우 닮았지만, 둘은 근본적으로 다른 세상을 바라보고 있다. 이 차이점을 명확히 인지하는 것이 JPQL을 제대로 사용하는 첫걸음이다. **가장 결정적인 차이는 쿼리의 대상이 테이블이 아닌 엔티티 객체라는 점**이다.

SQL이 데이터베이스 스키마에 직접 말을 거는 언어라면, JPQL은 영속성 컨텍스트에 있는 객체 세상에 말을 거는 언어다.

| 구분 | SQL (Structured Query Language) | JPQL (Java Persistence Query Language) |
| :--- | :--- | :--- |
| **쿼리 대상** | 데이터베이스 **테이블**과 **컬럼** | **엔티티 객체**와 **필드(프로퍼티)** |
| **대소문자 구분**| 키워드는 구분 안함. 테이블/컬럼명은 DB에 따라 다름. | 키워드는 구분 안함. **엔티티와 필드 이름은 명확히 구분함.** |
| **별칭(Alias)**| `FROM` 절의 테이블 별칭은 **선택** 사항 | `FROM` 절의 엔티티 별칭은 **필수** 사항 |
| **상속 지원** | 상속 개념 없음 | 상속 관계를 이해하고 다형성 쿼리 지원 |

-----

### **1. 쿼리 대상: 테이블 vs. 엔티티**

이것이 가장 핵심적인 차이다. JPQL은 철저하게 엔티티 객체의 관점에서 쿼리를 수행한다.

**SQL**

```sql
-- MEMBER_TBL 테이블의 USER_NM 컬럼을 조회한다.
SELECT USER_NM FROM MEMBER_TBL WHERE ID = 1;
```

**JPQL**

```jpql
-- Member 엔티티의 username 필드를 조회한다.
SELECT m.username FROM Member m WHERE m.id = 1;
```

JPQL은 `MEMBER_TBL`이나 `USER_NM` 같은 물리적인 테이블/컬럼 이름은 전혀 알지 못한다. 오직 우리가 정의한 `Member`라는 엔티티 클래스와 그 안의 `username`이라는 필드 이름만을 인지할 뿐이다.

### **2. 대소문자 구분: 엔티티와 필드 이름은 정확하게\!**

SQL은 일반적으로 키워드나 테이블/컬럼명에 대해 대소문자를 크게 신경 쓰지 않는다. 하지만 JPQL은 다르다. `SELECT`, `FROM`, `WHERE` 같은 JPQL 키워드는 대소문자를 구분하지 않지만, **엔티티 클래스 이름과 그 필드의 이름은 자바/코틀린 코드에 정의된 그대로, 정확하게 대소문자를 구분해서 사용해야 한다.**

  * `FROM Member m` (O)
  * `FROM member m` (X) -\> `member`라는 엔티티는 없으므로 에러 발생\!
  * `m.username` (O)
  * `m.USERNAME` (X) -\> `Member` 클래스에 `USERNAME` 필드는 없으므로 에러 발생\!

### **3. 별칭(Alias)은 필수**

SQL에서는 테이블 별칭을 생략할 수 있지만, **JPQL에서는 `FROM` 절에 등장하는 모든 엔티티에 대해 반드시 별칭을 지정해야 한다.**

  * `SELECT m FROM Member m` (O)
  * `SELECT Member FROM Member` (X) -\> 에러 발생\!

JPQL이 별칭을 필수로 요구하는 이유는, `SELECT` 절이나 `WHERE` 절 등에서 객체 그래프를 탐색(`m.team.name`처럼)하기 위해 명확한 시작점을 지정해야 하기 때문이다.

-----

이처럼 JPQL은 SQL의 옷을 입고 있지만, 그 속은 철저히 객체지향적인 사상으로 채워져 있다. JPQL을 작성할 때는 "어떤 테이블을 조회할까?"가 아니라, \*\*"어떤 엔티티 객체를, 어떤 조건으로 가져올까?"\*\*라고 생각의 전환을 하는 것이 중요하다. 이제 이 기본 원칙을 바탕으로 실제 JPQL 쿼리를 작성하는 법을 배워보자.