## 01. ORM의 탄생: 패러다임 불일치(Paradigm Mismatch)의 근본적 이해

JPA를 이해하기 위한 첫 번째 관문은 'ORM이 도대체 왜 필요한가?'라는 질문에 스스로 답할 수 있어야 하는 것이다. ORM은 **Object-Relational Mapping**, 즉 객체와 관계형 데이터베이스를 중간에서 매핑해주는 기술을 의미한다. 이 매핑이 왜 필요한가? 바로 객체가 세상을 바라보는 방식과 관계형 데이터베이스가 데이터를 저장하는 방식이 근본적으로 다르기 때문이다. 이 차이를 우리는 **패러다임 불일치**라고 부른다.

객체지향 프로그래밍 세계에서는 모든 것이 객체다. 예를 들어, 우리는 `Team`이라는 객체를 만들고, 그 안에 여러 명의 `Member` 객체를 `List<Member>` 형태로 자연스럽게 담을 수 있다. 다른 팀의 정보를 알고 싶으면 `member.getTeam()`과 같이 객체 그래프를 자유롭게 탐색(Object Graph Navigation)하면 그만이다. 상속을 통해 `Album`과 `Book`이 `Item`이라는 부모의 특성을 물려받는 것도 지극히 당연한 일이다.

하지만 관계형 데이터베이스의 세계는 다르다. 데이터는 정규화된 테이블이라는 2차원 구조에 저장된다. `Team`과 `Member`의 관계는 외래 키(Foreign Key)라는 개념을 통해 표현될 뿐, `Team` 테이블이 `Member` 로우(Row)들을 직접 담고 있는 구조가 아니다. `member`가 속한 `team`의 정보를 얻으려면 `TEAM` 테이블과 `MEMBER` 테이블을 `JOIN` 해야만 한다. 상속이라는 개념은 아예 존재하지도 않는다.

이러한 불일치는 여러 영역에서 개발자의 발목을 잡는다.

* **연관관계의 불일치:** 객체는 참조(`member.team`)를 사용해 다른 객체와 관계를 맺지만, 테이블은 외래 키(`member.team_id`)를 사용한다. 이 때문에 개발자는 객체 모델과 테이블 모델 사이에서 끊임없이 두뇌 스위칭을 해야 한다. `member.setTeam(team)`이라고 했을 때, 실제 DB에는 `team_id`가 저장되어야 한다는 사실을 항상 인지하고 코드를 짜야만 했다.
* **상속의 불일치:** 객체지향의 강력한 무기인 상속을 데이터베이스 테이블로 표현하는 것은 매우 까다로운 문제다. 부모와 자식 테이블을 나누어 조인할 것인가? 하나의 거대한 테이블에 모든 속성을 넣고 타입 컬럼으로 구분할 것인가? 이 모든 고민을 개발자가 직접 SQL로 해결해야 했다.
* **데이터 타입의 불일치:** 자바/코틀린에는 다양한 타입이 있지만, 데이터베이스가 지원하는 타입은 제한적이다. 예를 들어, 자바의 `LocalDate`를 DB의 `DATE` 타입으로 어떻게 변환할지 등을 개발자가 직접 처리해야 했다.
* **조회 방식의 불일치:** 객체는 `member.getTeam().getLeague().getName()`처럼 자유로운 그래프 탐색이 가능하지만, SQL은 처음부터 조회할 범위를 정하고 `JOIN`을 통해 한 번에 모든 데이터를 가져와야 한다. 이 차이로 인해 `LazyInitializationException`이나 N+1 같은 문제가 발생한다.

ORM이 등장하기 전, 개발자들은 JDBC API를 직접 사용하여 이 모든 불일치를 '노가다'로 해결했다. `ResultSet`에서 데이터를 하나씩 꺼내 객체에 수동으로 값을 채워 넣고(`객체-SQL 매핑`), `INSERT`, `UPDATE` SQL을 문자열로 만들어 실행하는 반복적이고 지루한 작업을 끝없이 수행해야 했다.

바로 이 고통스러운 지점에서 **ORM이 구원자처럼 등장했다.**

ORM 프레임워크는 이 모든 지저분하고 반복적인 매핑 작업을 대신 처리해주는 똑똑한 통역사와 같다. 개발자는 그저 객체지향적인 코드에만 집중하면 된다. `member.setTeam(newTeam)`이라고 코드를 작성하면, ORM이 알아서 `UPDATE MEMBER SET TEAM_ID = ? WHERE ID = ?` 와 같은 SQL을 생성하여 실행해준다. `@Inheritance` 전략을 지정해주면 복잡한 상속 관계도 ORM이 알아서 적절한 테이블 구조와 SQL로 풀어낸다.

즉, **ORM의 핵심 목표는 개발자가 관계형 데이터베이스의 패러다임이 아닌, 객체지향 패러다임에만 집중하여 비즈니스 로직을 구현할 수 있도록 돕는 것이다.** 그리고 JPA는 이러한 ORM 기술을 자바 진영에서 표준화한 명세(Specification)인 셈이다. 이제 우리는 왜 JPA를 배워야 하는지 그 근본적인 이유를 이해했다. 다음 절에서는 이 JPA가 어떤 역사를 거쳐 지금에 이르렀는지 살펴보자.