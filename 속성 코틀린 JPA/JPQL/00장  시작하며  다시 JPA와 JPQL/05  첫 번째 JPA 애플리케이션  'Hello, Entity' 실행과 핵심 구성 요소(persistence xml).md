## 05\. 첫 번째 JPA 애플리케이션: 'Hello, Entity' 실행과 핵심 구성 요소(persistence.xml)

이론은 충분하다. 이제 직접 코드로 JPA의 작동을 경험해 볼 시간이다. 아주 간단한 `Member` 객체를 만들고, 데이터베이스에 저장한 뒤, 다시 조회하는 전체 과정을 실행해 보자.

### **1. 엔티티(Entity) 클래스 작성**

가장 먼저 데이터베이스 테이블과 매핑될 객체를 만들어야 한다. 이것을 **엔티티**라고 부른다. `Member`라는 이름의 간단한 코틀린 데이터 클래스를 생성하자.

`src/main/kotlin/.../domain/Member.kt`

```kotlin
package com.masterclass.jpamaster.domain

import jakarta.persistence.*

@Entity
class Member(
    @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
    val id: Long = 0,

    @Column(nullable = false)
    var name: String
)
```

  * `@Entity`: 가장 중요한 어노테이션이다. "이 클래스는 JPA가 관리하는 엔티티이며, 데이터베이스의 테이블과 매핑됩니다"라고 선언하는 것과 같다.
  * `@Id`: 이 프로퍼티가 테이블의 기본 키(Primary Key)에 해당함을 나타낸다.
  * `@GeneratedValue(strategy = GenerationType.IDENTITY)`: 기본 키 값을 데이터베이스에 위임하여 자동 생성하도록 설정한다. (예: MySQL의 AUTO\_INCREMENT)
  * `@Column`: 프로퍼티를 테이블의 컬럼에 매핑한다. `nullable = false`는 DDL 생성 시 `NOT NULL` 제약조건을 추가한다.

### **2. 리포지토리(Repository) 인터페이스 작성**

다음으로, 이 `Member` 엔티티를 데이터베이스에 저장하고 조회하는 등의 작업을 수행할 데이터 접근 계층이 필요하다. 스프링 데이터 JPA는 `JpaRepository` 인터페이스를 상속받는 것만으로 이 모든 기능을 마법처럼 구현해준다.

`src/main/kotlin/.../repository/MemberRepository.kt`

```kotlin
package com.masterclass.jpamaster.repository

import com.masterclass.jpamaster.domain.Member
import org.springframework.data.jpa.repository.JpaRepository

interface MemberRepository : JpaRepository<Member, Long>
```

이게 전부다. `save()`, `findById()`, `findAll()`, `delete()` 등 기본적인 CRUD 메서드가 이미 모두 구현되어 있다. `JpaRepository<Member, Long>`의 제네릭 타입은 각각 이 리포지토리가 다룰 엔티티 타입(`Member`)과 그 엔티티의 ID 타입(`Long`)을 의미한다.

### **3. 애플리케이션 실행 및 결과 확인**

이제 애플리케이션을 실행해서 실제로 `INSERT`와 `SELECT` 쿼리가 발생하는지 확인해보자. 테스트를 위해 애플리케이션 실행 시점에 코드가 동작하도록 `CommandLineRunner`를 사용할 수 있다.

`src/main/kotlin/.../JpaMasterApplication.kt`

```kotlin
package com.masterclass.jpamaster

import com.masterclass.jpamaster.domain.Member
import com.masterclass.jpamaster.repository.MemberRepository
import org.springframework.boot.CommandLineRunner
import org.springframework.boot.autoconfigure.SpringBootApplication
import org.springframework.boot.runApplication
import org.springframework.context.annotation.Bean
import org.springframework.transaction.annotation.Transactional

@SpringBootApplication
class JpaMasterApplication {

    @Bean
    @Transactional
    fun run(memberRepository: MemberRepository) = CommandLineRunner {
        println("\n>>> 멤버 저장 시작...")
        val member = Member(name = "Master Kim")
        memberRepository.save(member)
        println(">>> 멤버 저장 완료. 생성된 ID: ${member.id}")

        println("\n>>> 멤버 조회 시작...")
        val foundMember = memberRepository.findById(member.id).orElseThrow()
        println(">>> 조회된 멤버: ${foundMember.name}, ID: ${foundMember.id}")
        println(">>> 실행 완료!")
    }
}

fun main(args: Array<String>) {
    runApplication<JpaMasterApplication>(*args)
}
```

이제 애플리케이션을 실행하면, 콘솔에서 다음과 같은 로그를 확인할 수 있다.

```shell
# (... 스프링 부트 시작 로그 ...)

# 하이버네이트가 Member 엔티티를 기반으로 DDL을 실행한다.
Hibernate: 
    drop table if exists member cascade 
Hibernate: 
    create table member (
        id bigint generated by default as identity,
        name varchar(255) not null,
        primary key (id)
    )

>>> 멤버 저장 시작...
# memberRepository.save()가 호출되자 INSERT 쿼리가 실행된다.
Hibernate: 
    /* insert for com.masterclass.jpamaster.domain.Member */ insert into member (name) values (?)
# trace 로그를 통해 '?'에 "Master Kim"이 바인딩된 것을 알 수 있다.
o.h.type.descriptor.sql.BasicBinder      : binding parameter [1] as [VARCHAR] - [Master Kim]
>>> 멤버 저장 완료. 생성된 ID: 1

>>> 멤버 조회 시작...
# memberRepository.findById()가 호출되자 SELECT 쿼리가 실행된다.
Hibernate: 
    /* select m1_0.id,m1_0.name from member m1_0 where m1_0.id=? */ select id, name from member where id=?
o.h.type.descriptor.sql.BasicBinder      : binding parameter [1] as [BIGINT] - [1]
>>> 조회된 멤버: Master Kim, ID: 1
>>> 실행 완료!

# (... 스프링 부트 종료 로그 ...)
```

놀랍지 않은가? 우리는 단 한 줄의 SQL도 작성하지 않았지만, JPA(와 하이버네이트)가 엔티티 클래스를 분석해 테이블을 만들고(`CREATE`), `save()` 메서드 호출을 `INSERT` 쿼리로, `findById()` 메서드 호출을 `SELECT` 쿼리로 변환하여 실행했다.

### **핵심 구성 요소: `persistence.xml`은 어디에?**

전통적인 JPA 환경(Java EE 등)에서는 데이터소스 정보, JPA 구현체 설정, 엔티티 클래스 위치 등을 `META-INF/persistence.xml`이라는 파일에 명시해야 했다. JPA는 이 설정 파일을 읽어 \*\*`EntityManagerFactory`\*\*를 생성하고, 개발자는 이 팩토리에서 \*\*`EntityManager`\*\*를 얻어와 모든 데이터베이스 작업을 수행했다.

  * **`EntityManagerFactory`**: 이름 그대로 `EntityManager`를 만드는 공장. 애플리케이션 전체에서 단 하나만 생성해서 공유하는 무거운 객체다. 데이터베이스 커넥션 풀을 관리하는 등 비용이 많이 드는 작업을 처리한다.
  * **`EntityManager`**: 실제 트랜잭션 단위의 작업을 수행하는 주체. 엔티티를 저장, 수정, 삭제, 조회하는 모든 일은 `EntityManager`를 통해 이루어진다. 우리가 앞으로 배울 **영속성 컨텍스트를 직접 관리하는 녀석**이기도 하다. 여러 스레드가 동시에 접근하면 안 된다.

하지만 우리는 `persistence.xml` 파일을 만든 적이 없다. 어떻게 이게 가능했을까?

바로 **스프링 부트의 자동 설정(Auto-Configuration)** 덕분이다. 스프링 부트는 클래스패스에 `spring-boot-starter-data-jpa`가 있으면, `application.yml`(또는 `.properties`) 파일의 `spring.jpa.*`, `spring.datasource.*` 설정을 읽어들여 `EntityManagerFactory`와 관련 빈(Bean)들을 자동으로 생성하고 설정해준다. 즉, **스프링 부트 환경에서는 `application.yml`이 `persistence.xml`의 역할을 대신**하는 셈이다.

또한, 스프링 데이터 JPA의 `JpaRepository` 내부에서는 우리가 직접 `EntityManager`를 호출하지 않아도 되도록 모든 것을 추상화하여 처리해준다. 개발자는 그저 잘 만들어진 인터페이스를 호출하기만 하면 된다.

-----

여기까지 우리는 JPA가 왜 탄생했고, 어떤 역사를 거쳤으며, 왜 지금도 중요한지, 그리고 어떻게 첫발을 내디딜 수 있는지까지 확인했다. 이제 00장의 '워밍업'은 끝났다. 다음 01장부터는 JPA의 가장 기본 단위인 엔티티를 데이터베이스 테이블과 정교하게 매핑하는 다양한 방법들을 본격적으로 탐험해 볼 것이다.