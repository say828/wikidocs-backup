## 01. 2차 캐시 적용 전략: 적용 시점과 대상 엔티티 선정

2차 캐시의 동작 원리를 이해하고 설정을 마쳤다고 해서, 모든 엔티티에 `@Cacheable`을 붙이는 것은 재앙으로 가는 지름길이다. 2차 캐시는 양날의 검과 같아서, 올바른 대상에 현명하게 적용했을 때만 성능 향상이라는 달콤한 열매를 맺을 수 있다. 잘못 사용된 캐시는 오히려 메모리 낭비와 데이터 불일치라는 심각한 버그의 원인이 된다.

그렇다면 어떤 엔티티가 2차 캐시의 '좋은 후보'일까? 기준은 명확하다.

> **읽기/쓰기 비율이 압도적으로 높고(Read-Mostly), 거의 변하지 않으며, 여러 곳에서 공유되는 데이터**

이 세 가지 조건을 모두 만족하는 엔티티에만 2차 캐시를 적용하는 것이 황금률이다.

---

### **2차 캐시 적용, 좋은 예 vs. 나쁜 예**

**👍 좋은 예 (적극적으로 캐싱을 고려해야 할 대상)**

* **공통 코드성 데이터**: `국가(Country)`, `언어(Language)`, `통화(Currency)` 등 시스템 전반에서 사용되지만, 데이터 변경은 거의 일어나지 않는 기준 정보.
* **카테고리/분류 데이터**: 쇼핑몰의 `상품 카테고리(ProductCategory)`, 게시판의 `게시판 종류(BoardType)` 등. 데이터가 변경되더라도 그 주기가 매우 길다.
* **사용자 권한/역할 정보**: `Role`, `Permission` 등. 사용자의 권한 정보는 자주 바뀌지 않으며, 인증/인가 시점에 반복적으로 조회된다.

이러한 엔티티들은 한 번의 조회로 2차 캐시에 올라가면, 애플리케이션이 실행되는 내내 데이터베이스를 괴롭히지 않고 메모리에서 초고속으로 조회될 수 있다.

**👎 나쁜 예 (절대 캐싱하면 안 되는 대상)**

* **주문/재고 관련 데이터**: `주문(Order)`, `재고(Stock)`, `계좌(Account)` 등. 이들은 트랜잭션이 발생할 때마다 **매우 빈번하게 데이터가 변경**된다. 이런 엔티티를 캐싱하면, 캐시를 최신 상태로 유지하기 위한 오버헤드(cache invalidation)가 DB를 직접 조회하는 비용보다 훨씬 더 커진다. 최악의 경우, 동시성 문제로 캐시와 DB의 데이터가 틀어지는 정합성 문제가 발생할 수 있다.
* **게시글/댓글 데이터**: `게시글(Post)`, `댓글(Comment)` 등. 쓰기 작업이 빈번하고, 실시간으로 최신 내용을 보여주는 것이 중요하다. 캐싱된 오래된 데이터를 보여주는 것은 서비스의 신뢰도를 떨어뜨린다.



---

> **So What? (그래서 어쩌라고?)**
> **2차 캐시는 만병통치약이 아니라, 특정 상황을 위한 정밀 유도 미사일이다.**
>
> 대부분의 실무 애플리케이션 성능 문제는 **N+1 문제**에서 비롯된다. 2차 캐시를 고민하기 전에, **11장에서 배운 페치 조인과 배치 사이즈 설정으로 N+1 문제부터 해결하는 것이 99%의 경우 더 효과적이다.**
>
> 2차 캐시는 N+1 문제까지 모두 해결했음에도 불구하고, 특정 기준 정보 테이블에 대한 반복적인 조회로 인해 발생하는 병목 현상을 해결하기 위한 **최후의 최적화 카드**로 남겨두는 것이 현명하다. 무분별한 캐시는 단순함이라는 아키텍처의 미덕을 해치고, 복잡성만 가중시킬 뿐이다. 수술용 칼을 망치처럼 휘두르지 마라.

2차 캐시가 엔티티 자체를 캐싱하는 기술이라면, 쿼리 결과를 캐싱하는 방법도 존재한다. 다음 절에서는 쿼리 캐시에 대해 알아보자.