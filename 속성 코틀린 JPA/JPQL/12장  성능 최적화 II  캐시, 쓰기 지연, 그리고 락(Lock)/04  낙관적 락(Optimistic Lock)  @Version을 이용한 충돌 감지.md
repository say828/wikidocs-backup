## 04\. 낙관적 락(Optimistic Lock): @Version을 이용한 충돌 감지

데이터베이스 격리 수준만으로는 해결하기 어려운 동시성 문제가 있다. 바로 **'마지막 커밋만 인정(Last Commit Wins)'** 문제다. 두 명의 사용자가 거의 동시에 같은 데이터를 조회하여 수정하는 시나리오를 생각해 보자.

1.  **사용자 A**가 '게시글 1'을 조회한다. (조회수: 10)
2.  **사용자 B**도 거의 동시에 '게시글 1'을 조회한다. (조회수: 10)
3.  **사용자 A**가 게시글 내용을 수정하고 커밋한다. 이 트랜잭션은 조회수를 1 증가시켜 DB에 11로 기록한다.
4.  그 직후, **사용자 B**도 자기가 조회했던 내용 기반으로 게시글을 수정하고 커밋한다. 사용자 B가 읽었던 조회수는 10이었으므로, 이 트랜잭션 역시 조회수를 1 증가시켜 DB에 11로 기록한다.

**결과**: 조회는 두 번 일어났지만, 최종 조회수는 12가 아닌 11이 되었다. 사용자 A의 수정 내역이 사용자 B의 커밋 때문에 덮어씌워져 사라진 것이다. 이를 **갱신 손실(Lost Update)** 문제라고 한다.

이 문제를 해결하는 첫 번째 방법이 바로 \*\*낙관적 락(Optimistic Lock)\*\*이다.

-----

### **낙관적 락의 개념: "충돌은 거의 안 나겠지?"**

낙관적 락은 이름 그대로 "충돌이 자주 발생하지 않을 것"이라고 낙관적으로 가정하는 방식이다. 실제 데이터베이스에 락을 걸어 다른 트랜잭션의 접근을 막는 대신, 트랜잭션을 커밋하는 마지막 순간에 \*\*"내가 데이터를 읽은 후에 다른 누군가가 수정하지는 않았을까?"\*\*를 검사하여 데이터 정합성을 지키는 방법이다.

-----

### **JPA의 구현: `@Version` 어노테이션**

JPA는 이 낙관적 락을 매우 간단하게 구현할 수 있도록 `@Version` 어노테이션을 제공한다.

**1. 엔티티에 `@Version` 필드 추가**
동시성 제어가 필요한 엔티티에 버전 정보를 담을 필드를 하나 추가하고 `@Version` 어노테이션을 붙여준다. 타입은 숫자(`Long`, `Integer`)여야 한다.

```kotlin
@Entity
class Post(
    @Id @GeneratedValue
    val id: Long = 0,
    var title: String,
    
    @Version
    val version: Long = 0
)
```

**2. `@Version`의 마법 같은 동작 원리**
`@Version` 필드를 추가하면, JPA는 이 엔티티를 수정할 때마다 다음과 같이 동작한다.

1.  **조회 시**: 엔티티를 조회할 때 `@Version` 필드의 값도 함께 읽어온다. (예: `version = 1`)
2.  **수정 후 커밋 시**: JPA가 `UPDATE` 쿼리를 실행할 때, `WHERE` 절에 조회 시점의 버전 값을 조건으로 추가한다. 그리고 `SET` 절에서 버전 값을 1 증가시킨다.
    ```sql
    UPDATE POST 
    SET 
        TITLE = '새로운 제목', 
        VERSION = VERSION + 1  -- 2. 버전 1 증가
    WHERE 
        ID = 10 
        AND VERSION = 1        -- 1. 조회 시점의 버전 값으로 조건 검사
    ```
3.  **결과 판정**:
      * **충돌이 없었을 경우**: `WHERE` 절의 `VERSION = 1` 조건이 만족되므로 `UPDATE`가 성공하고, DB의 버전 값은 2가 된다.
      * **충돌이 발생했을 경우**: 만약 다른 트랜잭션이 먼저 커밋하여 DB의 `VERSION`이 2로 변경되었다면, `WHERE` 절의 `VERSION = 1` 조건은 실패한다. `UPDATE`는 0개의 로우에 적용된다. 이때 JPA(하이버네이트)는 **`OptimisticLockException`** (또는 유사한 예외)을 발생시켜 개발자에게 동시성 충돌이 일어났음을 명확하게 알려준다.

개발자는 이 예외를 `catch` 하여 사용자에게 "데이터가 변경되었습니다. 다시 시도해 주세요." 와 같은 메시지를 보여주거나, 로직을 재시도하는 등의 후속 처리를 할 수 있다.

-----

> **결론: 낙관적 락은 언제 사용하는가?**
>
> **조회 작업이 수정 작업보다 훨씬 빈번한** 대부분의 웹 애플리케이션 환경에 매우 적합하다. 실제 DB 락을 사용하지 않으므로 성능 저하가 거의 없으면서도 데이터 정합성을 효과적으로 지킬 수 있다.
>
> 하지만 재고 차감처럼 **충돌이 빈번하게 발생할 것으로 예상되는** 비즈니스 로직에는 적합하지 않다. 예외가 너무 자주 발생하여 사용자가 계속 재시도를 해야 하거나, 재시도 로직 자체가 복잡해질 수 있기 때문이다. 바로 이런 경우를 위해 준비된 것이 다음 절에서 배울 '비관적 락'이다.