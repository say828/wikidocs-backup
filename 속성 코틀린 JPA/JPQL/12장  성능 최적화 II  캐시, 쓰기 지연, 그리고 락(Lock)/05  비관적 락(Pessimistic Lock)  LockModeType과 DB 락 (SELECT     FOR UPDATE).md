## 05\. 비관적 락(Pessimistic Lock): `LockModeType`과 DB 락 (SELECT ... FOR UPDATE)

낙관적 락이 "일단 수정하고, 커밋할 때 혹시 충돌이 있었는지 확인하자"는 방식이라면, \*\*비관적 락(Pessimistic Lock)\*\*은 정반대의 접근법을 취한다. "충돌이 분명히 일어날 것이니, 데이터를 읽는 순간부터 아무도 건드리지 못하게 잠가버리자"는 비관적인 방식이다.

이 방식은 JPA가 아닌, 데이터베이스가 제공하는 실제 락(Lock) 기능을 사용하여 구현된다. 한 트랜잭션이 특정 로우(row)에 락을 걸면, 다른 트랜잭션은 해당 락이 해제될 때까지(첫 번째 트랜잭션이 커밋되거나 롤백될 때까지) 해당 로우에 접근하거나 수정하는 것이 차단된다.

-----

### **JPA에서의 비관적 락 사용법**

JPA는 `EntityManager`의 `find()`, `lock()` 메서드나 `Query`의 `setLockMode()` 메서드에 \*\*`LockModeType`\*\*을 지정하는 방식으로 비관적 락을 사용할 수 있다.

가장 일반적으로 사용되는 방식은 `find()`를 통해 엔티티를 조회하는 시점에 락을 거는 것이다.

```kotlin
// Stock 엔티티를 조회하는 순간, 해당 로우에 배타적 락을 건다.
val stock = entityManager.find(Stock::class.java, stockId, LockModeType.PESSIMISTIC_WRITE)

// 이제 이 stock 객체에 대한 락은 트랜잭션이 끝날 때까지 유지된다.
// 다른 트랜잭션은 이 로우를 수정하거나 읽으려고 하면 대기(WAIT) 상태가 된다.
stock.decrease(quantity)
```

위 코드를 실행하면, JPA는 데이터베이스에 다음과 같은 SQL을 전송한다.

```sql
SELECT * FROM STOCK WHERE ID = ? FOR UPDATE
```

SQL 마지막의 **`FOR UPDATE`** 구문이 바로 데이터베이스에게 해당 로우에 배타적인 락을 걸라고 지시하는 명령어다.

-----

### **`LockModeType`의 종류**

JPA는 몇 가지 종류의 비관적 락 모드를 제공한다.

  * **`PESSIMISTIC_WRITE`**: 가장 일반적인 배타적 락(Exclusive Lock). `SELECT ... FOR UPDATE`를 사용한다. 한 트랜잭션이 이 락을 획득하면, 다른 어떤 트랜잭션도 해당 로우를 읽거나(일부 DB 제외), 수정, 삭제할 수 없다. 데이터 정합성을 가장 강력하게 보장한다.
  * **`PESSIMISTIC_READ`**: 공유 락(Shared Lock). `SELECT ... FOR SHARE`(PostgreSQL) 등을 사용한다. 여러 트랜잭션이 동시에 데이터를 읽는 것은 허용하지만, 누구도 수정할 수는 없게 막는다. `WRITE` 락보다는 동시성이 높다.
  * **`PESSIMISTIC_FORCE_INCREMENT`**: `PESSIMISTIC_WRITE`와 유사하게 동작하면서, `@Version` 필드의 값을 강제로 1 증가시킨다. 낙관적 락과 비관적 락을 함께 사용해야 하는 복잡한 시나리오에서 사용된다.

-----

### **낙관적 락 vs. 비관적 락: 언제 무엇을 쓸까?**

| 구분 | 낙관적 락 (Optimistic) | 비관적 락 (Pessimistic) |
| :--- | :--- | :--- |
| **가정** | 충돌이 거의 발생하지 않는다. | 충돌이 빈번하게 발생한다. |
| **메커니즘**| 커밋 시 `@Version` 값 비교 | 조회 시 DB 로우 락 |
| **동시성** | 높음 (락을 사용하지 않음) | 낮음 (락으로 인해 대기 발생) |
| **예외 처리** | 충돌 시 예외 발생 후 재시도 필요 | 락 획득 실패 시 타임아웃 예외 가능 |
| **주요 사용처**| 대부분의 웹 애플리케이션 (조회 \> 수정) | 금융, 결제, 재고 관리 등 (수정 경쟁이 치열한 곳) |

**결론적으로,**

  * **일반적인 웹 애플리케이션 환경**에서는 비관적 락보다 동시성 처리 성능이 월등히 좋은 **낙관적 락**을 사용하는 것이 기본 전략이다.
  * 하지만 **돈 문제와 직결되거나, 실시간 재고 차감처럼 데이터 정합성이 무엇보다 중요하고 충돌이 빈번할 것으로 명확하게 예상되는 핵심 로직**에서는 비관적 락을 사용하여 충돌 자체를 원천적으로 차단하는 것이 더 안전하고 합리적인 선택이다.

-----

이것으로 캐시와 락을 아우르는 JPA 성능 최적화의 두 번째 여정을 마쳤다. 우리는 2차 캐시를 통해 DB 접근을 줄이는 법을 배웠고, 트랜잭션 격리 수준을 이해했으며, 낙관적 락과 비관적 락이라는 두 가지 강력한 동시성 제어 무기를 모두 갖추게 되었다.

지금까지 우리는 JPA의 핵심 기능과 성능 최적화 기법을 모두 익혔다. 다음 13장부터는 실제 애플리케이션을 구축하면서 마주하게 될 고급 주제와 아키텍처에 대해 알아본다. 엔티티의 변화를 감지하는 '이벤트 리스너', 생성/수정 시간을 자동으로 기록하는 '오디팅(Auditing)', 그리고 JPA 코드를 올바르게 테스트하는 방법 등을 탐구하며 진정한 실무 전문가로 나아갈 것이다.