## 06\. 코틀린 Data Class와 JPA: 'no-arg' 플러그인의 필요성

이 책의 모든 예제에서 우리는 코틀린의 강력한 기능인 `data class`를 엔티티로 사용해왔다. `data class`는 `toString()`, `equals()`, `hashCode()`, `copy()` 메서드를 자동으로 생성해주어 보일러플레이트 코드를 획기적으로 줄여주는 매우 편리한 도구다. 하지만 아무런 추가 설정 없이 `data class`를 엔티티로 사용하려고 하면, 우리는 예상치 못한 에러를 마주하게 된다.

그 이유는 JPA의 근본적인 동작 방식과 코틀린 `data class`의 특성이 충돌하기 때문이다.

### **JPA의 요구사항 vs. 코틀린의 현실**

  * **JPA 명세의 요구사항**: JPA 구현체(하이버네이트 등)는 데이터베이스에서 조회한 데이터를 바탕으로 엔티티 객체의 인스턴스를 만들어야 한다. 이때 리플렉션(Reflection) 기술을 사용하는데, 가장 안정적이고 간단하게 객체를 생성하는 방법은 \*\*'파라미터가 없는 기본 생성자(no-argument constructor)'\*\*를 호출하는 것이다. 따라서 JPA 명세는 모든 엔티티 클래스에 `public` 또는 `protected` 접근 제어자를 가진 기본 생성자가 반드시 존재해야 한다고 규정한다.

  * **코틀린 `data class`의 특성**: 코틀린의 `data class`는 주 생성자(primary constructor)에 선언된 프로퍼티를 기반으로 만들어진다. 만약 주 생성자에 하나 이상의 파라미터가 있다면(엔티티는 보통 `id`나 다른 필드를 가지므로 거의 항상 그렇다), 코틀린 컴파일러는 별도의 기본 생성자를 자동으로 만들어주지 않는다.

결과적으로, `data class Member(val id: Long, var name: String)` 와 같은 코드는 JPA의 요구사항을 만족시키지 못한다. 이 상태로 애플리케이션을 실행하면 하이버네이트는 `Member` 클래스의 인스턴스를 생성할 방법을 찾지 못해 `InstantiationException`과 같은 예외를 발생시킨다.

### **구원 투수, 'no-arg' 플러그인**

이러한 문제를 해결하기 위해 코틀린 진영에서 제공하는 공식적인 해결책이 바로 **`kotlin-jpa` 플러그인**, 일명 **'no-arg' 플러그인**이다.

우리가 00장의 환경 설정에서 `build.gradle.kts`에 추가했던 바로 그 플러그인이다.

```kotlin
plugins {
    kotlin("plugin.jpa") version "1.9.23"
}

// @Entity 같은 특정 어노테이션이 붙은 클래스에 대해
// 인자가 없는 생성자를 자동으로 만들어달라는 설정
noArg {
    annotation("jakarta.persistence.Entity")
}
```

이 플러그인은 컴파일 시점에 `@Entity` 어노테이션이 붙은 클래스를 찾아, 자동으로 인자가 없는 생성자를 바이트코드에 추가해준다. 개발자는 소스 코드 상에서는 아무런 작업을 할 필요가 없다. 이 플러그인 덕분에 우리는 JPA의 요구사항을 만족시키면서 동시에 `data class`의 편리함을 그대로 누릴 수 있게 되는 것이다.

### **[심화] 엔티티에 `data class`를 써도 될까?**

실무에서는 "엔티티 클래스에 `data class`를 사용하는 것이 옳은가?"에 대한 논쟁이 종종 있다. `data class`가 자동으로 생성하는 `equals()`, `hashCode()` 메서드가 양방향 연관관계나 지연 로딩(Lazy Loading)과 같은 JPA의 고급 기능과 함께 사용될 때 예기치 않은 문제를 일으킬 수 있기 때문이다. (예: `hashCode` 계산 시 지연 로딩 관계에 있는 컬렉션을 건드려 불필요한 쿼리를 유발하는 등)

결론부터 말하자면, **장단점을 명확히 알고 사용해야 한다.**

  * **단순한 엔티티**: 다른 엔티티와 복잡한 연관관계가 없는 단순한 CRUD용 엔티티의 경우, `data class`의 생산성이 주는 이점이 훨씬 크다.
  * **복잡한 엔티티**: 양방향 연관관계, 상속, 복잡한 지연 로딩이 얽혀있는 핵심 도메인 엔티티의 경우, 예기치 않은 동작을 피하기 위해 일반 `class`를 사용하고 `equals()`와 `hashCode()`를 식별자(`id`) 필드만을 이용해 직접 구현하는 것이 더 안정적이다.

이 책에서는 초반부의 간단한 예제에서는 `data class`의 편리함을 적극 활용하고, 연관관계 매핑을 다루는 후반부에서는 일반 `class`를 사용하며 이러한 문제점들을 어떻게 해결하는지 구체적으로 다룰 것이다.

-----

이것으로 객체와 테이블의 첫 만남이었던 1장을 마무리한다. 우리는 `@Entity`와 `@Table`로 엔티티를 선언하고, `@Id`로 식별자를 부여했으며, `@Column`과 다양한 매핑 어노테이션으로 객체의 속성을 테이블의 컬럼과 정교하게 연결하는 방법을 배웠다. 또한 `ddl-auto`와 코틀린 플러그인 같은 실용적인 팁까지 익혔다.

이제 우리의 객체는 데이터베이스와 '대화하는 법'을 알게 되었다. 그렇다면 JPA는 이 엔티티들을 '어떻게 관리'할까? `save()`를 호출하면 정말 즉시 `INSERT`가 일어날까? `setter`로 값을 바꾸기만 했는데 어떻게 `UPDATE`가 실행될까? 이 모든 비밀의 열쇠는 다음 장에서 다룰 \*\*영속성 컨텍스트(Persistence Context)\*\*에 있다. JPA의 심장부로 떠날 준비를 하라.