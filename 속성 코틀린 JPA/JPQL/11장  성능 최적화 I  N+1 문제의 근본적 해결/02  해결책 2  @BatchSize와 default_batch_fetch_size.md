## 02\. 해결책 2: @BatchSize와 `default_batch_fetch_size`

페치 조인이 컬렉션과 페이징 API를 함께 사용할 수 없다는 치명적인 한계를 가졌다면, 이 난감한 상황을 해결하기 위해 JPA는 어떤 대안을 마련해 두었을까? 그 해답은 바로 **배치(Batch)를 이용한 최적화**에 있다.

N+1 문제의 근본 원인은 N개의 엔티티 각각에 대해 N번의 추가 쿼리가 나간다는 점이다. 만약 이 N번의 쿼리를 몇 번의 쿼리로 묶어서 실행할 수만 있다면, 성능을 크게 개선할 수 있다. `@BatchSize` 어노테이션과 `default_batch_fetch_size` 글로벌 옵션이 바로 이 역할을 수행한다.

-----

### **`@BatchSize` 어노테이션**

`@BatchSize`는 지연 로딩(`LAZY`)으로 설정된 컬렉션이나 엔티티를 조회할 때, 지정된 `size`만큼의 ID를 모아 단 한 번의 `IN` 쿼리로 조회하게 해주는 어노테이션이다.

**사용법**
이 어노테이션은 컬렉션을 가진 부모 엔티티의 필드에 직접 붙여준다.

**Team.kt**

```kotlin
@Entity
class Team(
    // ...
    @BatchSize(size = 100) // 이 컬렉션을 조회할 때, 최대 100개의 팀 ID를 모아 IN 쿼리를 날린다.
    @OneToMany(mappedBy = "team", fetch = FetchType.LAZY)
    var members: MutableList<Member> = mutableListOf()
)
```

**동작 원리**
`@BatchSize(size = 100)`이 설정된 상태에서, `Team`을 페이징하여 10개만 조회했다고 가정해 보자.

1.  `Team`을 조회하는 쿼리가 1번 실행된다. (결과: `Team` 10개)
2.  이후 `team.members`에 처음 접근하는 순간, JPA는 나머지 9개 `Team`의 `members`도 함께 조회해야 한다는 것을 인지한다.
3.  10개의 `Team` ID를 모아, 다음과 같은 **단 한 번의 `IN` 쿼리**를 생성하여 실행한다.
    ```sql
    SELECT * FROM Member WHERE team_id IN (?, ?, ?, ..., ?) -- ID 10개가 IN 절에 포함됨
    ```

**결과**: N번(10번) 실행되었을 추가 쿼리가 단 1번으로 줄어들었다. N+1 문제가 **1 + (N / batch\_size)** 문제로 바뀌면서, `batch_size`를 적절히 설정하면 사실상 1+1에 가까운 성능을 낼 수 있다.

-----

### **글로벌 설정: `default_batch_fetch_size` (⭐️ 실무 권장)**

`@BatchSize`는 개별 컬렉션마다 설정해야 하는 번거로움이 있다. 더 나은 방법은 이 배치 사이즈 설정을 **글로벌(Global)하게 적용**하는 것이다. `application.yml` (또는 `properties`) 파일에 `hibernate.default_batch_fetch_size` 옵션을 설정하면, 애플리케이션의 모든 컬렉션 지연 로딩에 이 전략이 적용된다.

**application.yml**

```yaml
spring:
  jpa:
    properties:
      hibernate:
        # 글로벌 배치 사이즈 설정. 100 ~ 1000 사이의 값을 권장.
        default_batch_fetch_size: 100
```

이 설정 하나만으로, 우리는 더 이상 `@BatchSize` 어노테이션을 코드에 붙이지 않아도 된다. **실무에서는 개별 설정보다 이 글로벌 설정을 사용하는 것이 훨씬 효율적이고 유지보수에도 유리하다.**

### **페치 조인 vs. 배치 사이즈**

| 구분 | 페치 조인 (Fetch Join) | 배치 사이즈 (Batch Size) |
| :--- | :--- | :--- |
| **쿼리 수** | **단 1번** (JOIN) | **1 + (N / size) 번** (IN) |
| **쿼리 복잡도** | 복잡한 JOIN 쿼리 | 단순한 `IN` 쿼리 |
| **페이징** | 컬렉션 조인 시 **불가능** | **가능** |
| **데이터 전송량** | 모든 데이터를 한 번에 전송 | 필요한 데이터만 나누어 전송 |

**언제 무엇을 써야 할까?**

  * **페이징이 필요 없는 경우**: 데이터를 한 번에 모두 가져와야 한다면, 단 한 번의 쿼리로 끝나는 **페치 조인**이 가장 효율적이다.
  * **페이징이 필수적인 경우**: 컬렉션이 포함된 엔티티 목록을 페이징 처리해야 한다면, \*\*`default_batch_fetch_size`\*\*를 설정하는 것이 유일하고 가장 올바른 해결책이다.

-----

페치 조인과 배치 사이즈는 N+1 문제를 해결하는 가장 확실한 두 개의 카드다. 하지만 JPA는 여기서 멈추지 않고, JPQL 쿼리 자체는 수정하지 않으면서 동적으로 페치 전략을 변경할 수 있는 또 다른 세련된 방법을 제공한다. 다음 절에서는 `@EntityGraph`에 대해 알아본다.