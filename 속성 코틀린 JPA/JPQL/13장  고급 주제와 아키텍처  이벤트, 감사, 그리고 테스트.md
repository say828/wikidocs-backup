# 13장: 고급 주제와 아키텍처: 이벤트, 감사, 그리고 테스트

지금까지 우리는 JPA의 핵심 엔진을 정복하는 데 집중했다. 영속성 컨텍스트의 동작 원리, 다양한 매핑 전략, JPQL을 통한 쿼리, 그리고 성능 최적화까지, JPA 애플리케이션의 뼈대를 이루는 모든 기술을 마스터했다.

하지만 잘 만들어진 애플리케이션은 뼈대만으로 완성되지 않는다. 이번 장에서는 이 뼈대 위에 살을 붙이고 신경망을 연결하는, 즉 애플리케이션을 더욱 견고하고 유지보수하기 쉽게 만드는 **고급 주제와 아키텍처**에 대해 알아본다.

우리는 먼저 엔티티의 생명주기에 따라 특정 로직을 실행하는 **이벤트 리스너**와 **콜백 메서드**의 원리를 탐구한다. 이를 바탕으로, 모든 엔티티의 생성 및 수정 시간을 자동으로 기록하는 **오디팅(Auditing)** 기능을 스프링 데이터 JPA를 통해 얼마나 우아하게 구현할 수 있는지 보게 될 것이다.

더 나아가, 데이터 접근 계층의 코드를 어떻게 격리하여 안정적으로 **테스트**할 수 있는지, 스프링의 `@Transactional` 어노테이션이 가진 더 깊은 비밀은 무엇인지, 그리고 JPA 리포지토리를 \*\*도메인 주도 설계(DDD)\*\*의 관점에서 어떻게 바라보고 설계해야 하는지 등 아키텍처 수준의 논의로 시야를 확장할 것이다. 이 장을 마치면, 여러분은 단순히 JPA를 '사용하는' 것을 넘어, JPA를 중심으로 '견고한 애플리케이션을 설계하는' 개발자로 성장하게 될 것이다.

-----

## 00\. 엔티티 리스너(@EntityListeners)와 콜백 메서드(@PrePersist, @PostUpdate 등)

엔티티가 데이터베이스에 저장되거나, 수정되거나, 삭제되는 등 생명주기의 특정 시점에 우리가 원하는 별도의 로직을 실행하고 싶을 때가 있다. 예를 들어, 엔티티가 저장되기 직전에 특정 값을 검증하거나, 수정된 후에 관련 캐시를 갱신하는 등의 작업이다.

JPA는 이러한 요구사항을 위해 엔티티의 생명주기 이벤트를 '가로채서(intercept)' 로직을 실행할 수 있는 두 가지 방법을 제공한다: **콜백 메서드**와 **엔티티 리스너**.

-----

### **1. 콜백 메서드 (Callback Methods)**

콜백 메서드는 엔티티 클래스 내부에 직접 특정 어노테이션을 붙인 메서드를 정의하여 사용하는 가장 간단한 방법이다.

**생명주기 콜백 어노테이션**

  * `@PrePersist`: `persist()` 메서드 호출 직전에 실행된다.
  * `@PostPersist`: `persist()` 실행 후, 실제 DB에 `INSERT` 쿼리가 실행된 뒤에 호출된다. (식별자가 생성된 후)
  * `@PreUpdate`: DB에 `UPDATE` 쿼리가 실행되기 직전에 실행된다.
  * `@PostUpdate`: DB에 `UPDATE` 쿼리가 실행된 뒤에 호출된다.
  * `@PreRemove`: `remove()` 메서드 호출 직전에 실행된다.
  * `@PostRemove`: DB에 `DELETE` 쿼리가 실행된 뒤에 호출된다.
  * `@PostLoad`: 엔티티가 영속성 컨텍스트에 조회된 직후에 실행된다.

**코드 예시**

```kotlin
@Entity
class Member {
    // ...
    @PrePersist
    fun prePersist() {
        println(">>> Member is about to be persisted.")
    }
    
    @PostLoad
    fun postLoad() {
        println(">>> Member has been loaded.")
    }
}
```

이 방식은 간단하지만, 영속성 관리와 관련된 로직이 엔티티 클래스 내부에 섞이게 되어 객체의 책임이 불분명해진다는 단점이 있다.

-----

### **2. 엔티티 리스너 (@EntityListeners) - ⭐️ 권장**

엔티티 리스너는 콜백 로직을 엔티티 외부의 별도 클래스로 분리하여 관리하는, 훨씬 더 깔끔하고 유연한 방법이다.

**1단계: 리스너 클래스 생성**

```kotlin
// 리스너 클래스는 평범한 클래스다.
class MyEntityListener {

    @PrePersist
    fun prePersist(obj: Any) { // 파라미터로 이벤티가 발생한 엔티티 객체를 받는다.
        if (obj is Member) {
            println("Listener: PrePersist for Member ${obj.username}")
        }
    }
    
    @PostUpdate
    fun postUpdate(obj: Any) {
        println("Listener: Entity has been updated.")
    }
}
```

**2단계: 엔티티에 리스너 등록**
`@EntityListeners` 어노테이션을 사용하여 엔티티에 해당 리스너를 적용한다.

```kotlin
@Entity
@EntityListeners(MyEntityListener::class)
class Member {
    // ...
}
```

이제 `Member` 엔티티에 `persist`나 `update` 이벤트가 발생하면, JPA는 `MyEntityListener`에 정의된 해당 콜백 메서드를 자동으로 호출해준다.

**엔티티 리스너의 장점**

  * **관심사의 분리(Separation of Concerns)**: 엔티티는 순수한 비즈니스 로직만 담고, 영속성 이벤트와 관련된 부가 기능은 리스너로 분리하여 코드의 응집도를 높일 수 있다.
  * **재사용성**: 여러 엔티티에 공통으로 적용되어야 할 로직이 있다면, 리스너 하나를 만들어 여러 엔티티에 등록하여 재사용할 수 있다.
  * **스프링 빈 활용**: 리스너를 스프링 빈으로 등록하면, 다른 서비스나 컴포넌트를 주입받아 더 복잡한 로직을 수행할 수도 있다.

이벤트 리스너는 단순히 로그를 남기는 것 외에도, 이력(history) 테이블에 변경 내용을 기록하거나, 검색 엔진에 인덱싱 요청을 보내거나, 외부 시스템에 알림을 보내는 등 다양한 횡단 관심사(cross-cutting concerns)를 처리하는 데 매우 유용하게 사용된다.

이제 이 리스너 개념을 활용하여, 모든 엔티티의 생성/수정 시간을 자동으로 관리하는 '오디팅' 기능을 다음 절에서 구현해 보자.