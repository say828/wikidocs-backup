# 02장: 영속성 컨텍스트(Persistence Context): JPA 동작 원리의 심장

1장에서 우리는 `@Entity` 어노테이션을 붙인 평범한 코틀린 객체가 어떻게 데이터베이스 테이블과 성공적으로 연결되는지 확인했다. `EntityManager.persist()`를 호출하니 `INSERT` 쿼리가 실행되고, `findById()`를 호출하니 `SELECT` 쿼리가 나가는 것을 보았다. 하지만 정말 그게 전부일까? `persist()`를 호출하는 즉시 `INSERT` SQL이 DB로 전송되는 걸까? 만약 그렇다면, 짧은 트랜잭션 안에서 수백 개의 엔티티를 저장할 때마다 DB 커넥션을 붙잡고 통신해야 한다는 말인데, 과연 효율적일까?

JPA의 진짜 마법은 바로 이 지점에서 시작된다. 그리고 그 마법의 중심에는 **영속성 컨텍스트(Persistence Context)**라는 보이지 않는 작업 공간이 있다. 이 녀석을 이해하는 것이야말로 JPA를 '사용하는 개발자'와 '마스터하는 개발자'를 가르는 결정적인 분기점이다. 단순히 CRUD API를 나열하는 것을 넘어, JPA가 왜 그렇게 동작하도록 설계되었는지를 이해하면 N+1 문제, 동시성 이슈, 성능 최적화 같은 실무의 난제들을 근본적으로 해결할 힘을 갖게 된다.

이번 장에서는 JPA의 심장이자 두뇌인 영속성 컨텍스트의 내부 동작 원리를 낱낱이 파헤쳐 볼 것이다. 엔티티가 영속성 컨텍스트 안에서 어떤 삶을 사는지(생명주기), 1차 캐시는 어떻게 동작하며 왜 동일성을 보장하는지, 트랜잭션을 커밋하는 순간 어떤 SQL들이 묶어서 전송되는지(쓰기 지연), 그리고 분명 `update()` 메소드를 호출한 적도 없는데 어떻게 변경된 데이터를 귀신같이 알아채고 `UPDATE` 쿼리를 날리는지(변경 감지) 그 비밀을 모두 공개한다. 준비되었는가? 진짜 JPA의 세계로 들어갈 시간이다.

---

## 00. 영속성 컨텍스트의 정의: 엔티티를 관리하는 논리적 공간

'영속성 컨텍스트'라는 말을 처음 들으면 무언가 거창하고 물리적인 저장소처럼 느껴질 수 있다. 하지만 그 본질은 의외로 간단하다. 영속성 컨텍스트는 **'엔티티를 영구 저장하는 환경'**이라는 뜻으로, 물리적인 실체가 있는 것이 아니라 JPA가 엔티티를 관리하기 위해 사용하는 **논리적인 개념이자 보이지 않는 저장소**다. 비유하자면, `EntityManager`가 엔티티를 관리하기 위해 마음속에 그려두는 '엔티티 관리 대장' 같은 것이다.

애플리케이션과 데이터베이스 사이에서, 이 영속성 컨텍스트는 객체와 관계형 데이터베이스의 패러다임 불일치를 해결하고, 애플리케이션의 성능을 최적화하기 위한 다양한 마법을 부리는 중간 계층 역할을 한다.

그렇다면 이 '논리적 공간'은 언제, 어떻게 만들어질까? 바로 `EntityManager`가 생성될 때 함께 만들어진다. 그리고 스프링 프레임워크 환경에서는 보통 트랜잭션이 시작될 때 생성되어 트랜잭션이 끝날 때 함께 사라진다. 즉, **하나의 트랜잭션은 하나의 영속성 컨텍스트를 갖는다**고 생각하면 이해하기 쉽다.



영속성 컨텍스트는 내부에 여러 장치를 가지고 있는데, 그중 가장 대표적인 것들이 바로 다음과 같은 기능들이다.

* **1차 캐시 (1st-Level Cache)**: 영속 상태의 엔티티를 내부에 캐싱한다.
* **동일성 보장 (Identity Guarantee)**: 같은 트랜잭션 내에서 조회한 같은 엔티티는 항상 같은 인스턴스임을 보장한다.
* **트랜잭션을 지원하는 쓰기 지연 (Transactional Write-Behind)**: `INSERT`, `UPDATE`, `DELETE` SQL을 바로 보내지 않고 모았다가 트랜잭션 커밋 시점에 한 번에 보낸다.
* **변경 감지 (Dirty Checking)**: 트랜잭션 커밋 시점에 1차 캐시에 저장된 엔티티의 최초 상태(스냅샷)와 현재 상태를 비교하여 변경된 부분이 있으면 `UPDATE` SQL을 자동으로 생성한다.
* **지연 로딩 (Lazy Loading)**: 연관된 엔티티를 실제로 사용하는 시점까지 조회를 미룬다. (지연 로딩은 3장에서 자세히 다룬다.)

이 기능들이 바로 우리가 JPA를 사용하면서 "어? 이게 왜 이렇게 동작하지?"라고 느꼈던 모든 현상의 근원이다. 지금 당장 이 모든 것이 이해되지 않아도 괜찮다. 이어지는 절들에서 하나씩 코드를 통해 직접 확인하며 완벽하게 이해하게 될 것이다.

이제, 이 놀라운 작업 공간의 문을 열고 그 안에서 엔티티가 어떤 삶을 사는지, 그 생명주기부터 자세히 들여다보자.