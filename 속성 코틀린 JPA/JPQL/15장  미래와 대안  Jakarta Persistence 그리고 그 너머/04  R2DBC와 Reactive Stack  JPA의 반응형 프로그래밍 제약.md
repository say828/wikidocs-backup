## 04. R2DBC와 Reactive Stack: JPA의 반응형 프로그래밍 제약

지금까지 우리가 논의한 JPA, jOOQ, Exposed는 모두 하나의 공통된 기반 위에 서 있다. 바로 **JDBC(Java Database Connectivity)** 다. 그리고 14장에서 살펴보았듯이, JDBC는 근본적으로 **블로킹(Blocking) I/O** 방식으로 동작한다. 쿼리를 날린 스레드는 데이터베이스가 응답을 줄 때까지 하염없이 기다려야만 한다. 😥

하지만 Netty, Spring WebFlux, 코틀린 코루틴으로 대표되는 현대적인 **리액티브 프로그래밍(Reactive Programming)** 패러다임은 정반대를 지향한다. 적은 수의 스레드로 엄청난 양의 동시 요청을 처리하기 위해, I/O 작업으로 인한 스레드의 '기다림(blocking)'을 절대 허용하지 않는다.

이러한 리액티브 스택에서 블로킹 JDBC 기반의 JPA를 사용하는 것은, 고속도로에서 자전거를 타는 것과 같다. 시스템 전체의 성능을 저하시키고 리액티브 프로그래밍의 이점을 완전히 상쇄해버린다.

---

### **R2DBC: 리액티브를 위한 새로운 표준**

이 문제를 해결하기 위해 등장한 것이 바로 **R2DBC(Reactive Relational Database Connectivity)** 다. R2DBC는 JDBC를 대체하는, 처음부터 비동기/논블로킹을 위해 설계된 새로운 데이터베이스 드라이버 명세다.

R2DBC 드라이버를 사용하면, 애플리케이션은 데이터베이스에 쿼리를 보낸 뒤 스레드를 막고 기다리는 대신, 작업이 완료되었을 때 결과를 돌려받을 '콜백(Callback)' 또는 리액티브 스트림(`Publisher`, 코틀린의 `Flow`)을 등록한다. 이를 통해 스레드는 기다림 없이 다른 요청을 처리하러 갈 수 있어, 시스템 자원을 극도로 효율적으로 사용하게 된다.



### **JPA의 반응형(Reactive) 제약**

**매우 중요한 점은, JPA는 JDBC 위에 구축된 기술이므로 R2DBC와 호환되지 않는다는 것이다.** JPA의 영속성 컨텍스트, 트랜잭션 관리, 지연 로딩 등 모든 핵심 기능은 '하나의 스레드가 트랜잭션의 시작부터 끝까지 책임진다'는 스레드-바운드(thread-bound) 모델을 기반으로 설계되었다. 이는 스레드 사이를 자유롭게 넘나드는 리액티브 모델과 근본적으로 맞지 않다.

따라서, Spring WebFlux와 같은 완전한 리액티브 스택으로 애플리케이션을 구축하기로 결정했다면, 아쉽지만 **JPA를 포기해야만 한다.**

---

> **결론: 리액티브 스택에서는 JPA의 대안을 찾아야 한다.**
>
> 완전한 논블로킹 애플리케이션을 구축해야 한다면, JPA 대신 다음과 같은 R2DBC 기반의 기술들을 고려해야 한다.
>
> * **Spring Data R2DBC**: 스프링 데이터 프로젝트의 일부로, R2DBC를 사용하여 리포지토리 패턴을 구현할 수 있게 해준다. 하지만 JPA처럼 복잡한 매핑이나 영속성 컨텍스트 기능은 제공하지 않는, 훨씬 가벼운 프레임워크다.
> * **jOOQ**: jOOQ는 R2DBC를 지원하는 리액티브 버전을 제공하여, 타입-안전한 방식으로 논블로킹 SQL 쿼리를 작성할 수 있다.
> * **Vert.x SQL Client, Exposed (실험적 지원)** 등 다른 여러 라이브러리도 R2DBC 생태계에 참여하고 있다.
>
> ---

리액티브 프로그래밍으로의 전환은 단순히 라이브러리를 바꾸는 것을 넘어, 애플리케이션의 아키텍처와 데이터 흐름을 완전히 재고해야 하는 거대한 패러다임의 전환이다.