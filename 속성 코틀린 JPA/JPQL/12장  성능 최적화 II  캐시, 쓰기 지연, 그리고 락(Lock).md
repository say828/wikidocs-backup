# 12장: 성능 최적화 II: 캐시, 쓰기 지연, 그리고 락(Lock)

11장에서 우리는 JPA 성능의 가장 큰 적인 N+1 문제를 정복했다. 페치 조인, 배치 사이즈, 엔티티 그래프라는 강력한 무기들로 무장하여, 이제 우리는 불필요한 SQL을 최소화하고 효율적으로 데이터를 '읽어오는' 방법을 마스터했다.

하지만 애플리케이션의 성능은 단순히 읽기(Read)에만 국한되지 않는다. 조회 자체를 없앨 수는 없을까? 여러 사용자가 동시에 같은 데이터를 수정(Write)하려고 할 때는 어떤 일이 벌어질까? 이번 장에서는 성능 최적화의 또 다른 거대한 두 축인 \*\*캐시(Cache)\*\*와 \*\*잠금(Lock)\*\*의 세계로 깊이 들어간다.

우리는 먼저 트랜잭션의 범위를 넘어 애플리케이션 전역에서 데이터를 공유하여 데이터베이스 접근을 원천적으로 차단하는 \*\*2차 캐시(Second-Level Cache)\*\*의 동작 원리를 알아본다. 그리고 데이터베이스 트랜잭션의 핵심인 격리 수준(Isolation Level)과, 여러 사용자가 동시에 데이터를 수정할 때 데이터의 정합성을 보장하기 위한 두 가지 핵심 전략, \*\*낙관적 락(Optimistic Lock)\*\*과 \*\*비관적 락(Pessimistic Lock)\*\*의 차이와 올바른 사용법을 마스터할 것이다. 이 장을 마치면, 여러분은 단순히 빠른 조회를 넘어, 높은 트래픽과 동시성 환경에서도 굳건히 버티는 견고한 데이터 애플리케이션을 구축할 수 있는 완전한 시야를 갖게 될 것이다.

-----

## 00\. 1차 캐시를 넘어: 2차 캐시(Second-Level Cache)의 작동 원리와 Ehcache/Infinispan 연동

우리는 2장에서 1차 캐시에 대해 이미 배웠다. 1차 캐시는 영속성 컨텍스트 내부에 존재하며, 같은 트랜잭션 안에서 반복적인 조회를 효율적으로 처리해 주는 훌륭한 기능이다. 하지만 1차 캐시는 **트랜잭션이 종료되면 그 내용이 모두 사라진다**는 명확한 한계를 가지고 있다. 다른 트랜잭션에서는 똑같은 데이터를 조회하더라도 또다시 데이터베이스에 SQL을 전송해야 한다.

만약 애플리케이션 전체에서, 여러 트랜잭션에 걸쳐 자주 조회되지만 거의 변경되지 않는 데이터가 있다면 어떨까? (예: 국가 코드, 공통 설정 정보 등) 이런 데이터를 매번 DB에서 조회하는 것은 비효율적이다. 이 문제를 해결하기 위해 JPA는 \*\*2차 캐시(Second-Level Cache)\*\*라는 기능을 제공한다.

-----

### **2차 캐시란 무엇인가?**

2차 캐시는 \*\*애플리케이션 스코프(Scope)\*\*에서 동작하는 캐시다. 즉, `EntityManagerFactory`에 의해 생성되어, 해당 팩토리에서 만들어진 모든 영속성 컨텍스트(즉, 모든 트랜잭션)가 **공유**하는 캐시다.

**캐시 조회 순서**
`entityManager.find()`가 호출되면, JPA는 다음과 같은 순서로 데이터를 찾는다.

1.  **1차 캐시**를 확인한다. (해당 트랜잭션 내에 데이터가 있는지)
2.  (1차 캐시에 없으면) **2차 캐시**를 확인한다. (애플리케이션 전역에 데이터가 캐싱되어 있는지)
3.  (2차 캐시에도 없으면) **데이터베이스**를 조회한다.
4.  DB에서 조회한 데이터는 **2차 캐시와 1차 캐시에 모두 저장**한 뒤, 애플리케이션에 반환한다.

이 구조 덕분에, 한 번 2차 캐시에 올라간 데이터는 어떤 트랜잭션에서 조회하더라도 더 이상 DB를 거치지 않고 메모리에서 즉시 반환될 수 있어, 조회 성능을 극적으로 향상시킬 수 있다.

-----

### **2차 캐시 활성화 방법**

2차 캐시는 기본적으로 비활성화되어 있으며, 몇 가지 설정을 통해 활성화할 수 있다.

**1단계: `application.yml` 설정**
하이버네이트에 2차 캐시를 사용하겠다고 알려주고, 어떤 캐시 구현체를 사용할지 지정해야 한다.

```yaml
spring:
  jpa:
    properties:
      hibernate:
        # 2차 캐시 활성화
        cache:
          use_second_level_cache: true
          # JCache(JSR-107)를 캐시 제공자로 사용하기 위한 RegionFactory 설정
          region.factory_class: org.hibernate.cache.jcache.JCacheRegionFactory
```

**2단계: 캐시 라이브러리 의존성 추가**
하이버네이트는 캐시 인터페이스만 제공할 뿐, 실제 캐시 구현체는 제공하지 않는다. **Ehcache**, **Infinispan** 등 실질적인 캐시 라이브러리를 프로젝트에 추가해야 한다. 여기서는 JCache(JSR-107) 표준을 사용하는 Ehcache 3.x를 기준으로 설명한다.

**`build.gradle.kts`**

```groovy
dependencies {
    // ...
    implementation("org.hibernate.orm:hibernate-jcache:6.4.4.Final")
    implementation("org.ehcache:ehcache:3.10.8")
}
```

**3단계: 캐시 대상 엔티티 지정**
마지막으로, 어떤 엔티티를 2차 캐시에 저장할지 지정해야 한다. 아무 엔티티나 캐싱하는 것은 메모리 낭비와 데이터 불일치 문제를 일으킬 수 있으므로, 명시적인 설정이 필요하다.

**Code.kt (예: 공통 코드 엔티티)**

```kotlin
import org.hibernate.annotations.Cache
import org.hibernate.annotations.CacheConcurrencyStrategy
import jakarta.persistence.Cacheable
import jakarta.persistence.Entity

@Entity
@Cacheable // 이 엔티티는 2차 캐시 대상임을 명시
@Cache(usage = CacheConcurrencyStrategy.READ_ONLY) // 캐시 동시성 전략 설정
class Code(
    @Id val id: String,
    val description: String
)
```

  * `@Cacheable`: JPA 표준 어노테이션으로, 해당 엔티티가 캐시 대상임을 나타낸다.
  * `@Cache(usage = ...)`: 하이버네이트 전용 어노테이션으로, 캐시의 동시성 처리 전략을 더 세밀하게 설정한다. (`READ_ONLY`, `READ_WRITE` 등)

이 세 단계를 거치면 `Code` 엔티티는 이제 2차 캐시에 저장되고 관리된다.

2차 캐시는 조회 성능을 극대화할 수 있는 강력한 도구지만, 모든 엔티티에 무분별하게 적용해서는 안 된다. 다음 절에서는 어떤 엔티티에 2차 캐시를 적용해야 하는지, 그 적용 전략에 대해 알아보자.