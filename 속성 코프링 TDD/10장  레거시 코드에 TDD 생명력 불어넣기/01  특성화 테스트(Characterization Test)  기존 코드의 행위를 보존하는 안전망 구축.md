## 01\. 특성화 테스트(Characterization Test): 기존 코드의 행위를 보존하는 안전망 구축

레거시 코드의 악순환을 끊는 첫 번째 행동은 코드를 수정하는 것이 아니다. 그것은 코드를 변경하지 않고도 현재 코드의 **'실제 동작'을 그대로 기록하고 보존하는 테스트**를 작성하는 것이다. 이 테스트를 바로 \*\*특성화 테스트(Characterization Test)\*\*라고 부른다.

TDD가 "실패하는 테스트를 먼저 작성하여 개발을 주도"하는 것이라면, 특성화 테스트는 정반대의 접근법을 취한다. 이미 존재하는 코드의 동작을 그대로 포착하여 "항상 성공하는 테스트"를 만든다. 이 테스트의 목적은 버그를 찾는 것이 아니다. 설령 현재 코드의 동작이 명백한 버그라 할지라도, 그 버그마저 포함한 **현재 상태를 그대로 사진 찍듯이 기록하여 '안전망'을 구축하는 것**이 유일한 목표다.

이 안전망이 구축되면, 우리는 비로소 두려움 없이 리팩토링을 시작할 수 있다. 만약 리팩토링 중에 실수로 기존 코드의 동작을 단 하나라도 변경했다면, 우리가 미리 쳐놓은 안전망, 즉 특성화 테스트가 즉시 실패하며 우리에게 경고를 보내줄 것이기 때문이다.

### **특성화 테스트 작성 워크플로우**

1.  **테스트 지점 식별:** 레거시 코드에서 테스트하고 싶은 코드 블록을 찾는다. 가능한 한 파급 효과가 적은 작은 단위의 public 메소드가 가장 좋다.
2.  **테스트 하네스(Harness) 작성:** 테스트할 클래스의 인스턴스를 생성하고, 대상 메소드를 호출하는 테스트 코드를 작성한다. 아직 단언(assertion)은 추가하지 않는다.
3.  **결과 관찰:** 특정 입력값을 주고 코드를 실행시킨 뒤, 그 결과를 **주의 깊게 관찰한다.** 결과는 메소드의 반환 값일 수도 있고, 특정 객체의 상태 변화, 혹은 로그 출력일 수도 있다.
4.  **관찰한 결과로 단언문 작성:** 방금 관찰한 \*\*'있는 그대로의 결과'\*\*를 기대값으로 하는 단언문을 작성한다. 이 단언문은 현재 코드의 동작을 그대로 복사한 것이므로, 테스트는 처음부터 \*\*성공(GREEN)\*\*해야 한다.
5.  **반복:** 다양한 입력값에 대해 3, 4번 과정을 반복하여, 코드의 여러 실행 경로를 커버하는 특성화 테스트 스위트를 점진적으로 구축한다.

### **실전 예시: 버그인지 기능인지 모를 레거시 계산기**

다음과 같은 오래된 배송비 계산 로직이 있다고 가정하자. 제주도 배송비 계산 로직이 어딘가 이상해 보이지만, 우리는 이것이 의도된 정책인지 버그인지 확신할 수 없다.

```kotlin
// LegacyShippingFeeCalculator.kt
class LegacyShippingFeeCalculator {
    // 제주도는 무조건 2배의 할증이 붙는 이상한 로직이 있다.
    // 이것이 버그인가, 아니면 숨겨진 비즈니스 규칙인가?
    fun calculate(region: String, weight: Double): Double {
        if (region == "JEJU") {
            return (weight * 2) * 1500.0 
        }
        if (weight > 20.0) {
            return 25000.0
        }
        return 10000.0
    }
}
```

**이 코드에 대한 특성화 테스트 작성:**

```kotlin
// LegacyShippingFeeCalculatorTest.kt
class LegacyShippingFeeCalculatorTest : FunSpec({
    val calculator = LegacyShippingFeeCalculator()

    test("일반 지역(서울)의 기본 배송비를 특성화한다") {
        // 3. 관찰: calculator.calculate("SEOUL", 15.0)을 실행하니 10000.0이 나왔다.
        // 4. 기록: 관찰한 값을 그대로 단언문에 작성한다.
        val fee = calculator.calculate("SEOUL", 15.0)
        fee shouldBe 10000.0
    }

    test("일반 지역(서울)의 무거운 화물 배송비를 특성화한다") {
        // 3. 관찰: calculator.calculate("SEOUL", 25.0)을 실행하니 25000.0이 나왔다.
        // 4. 기록: 관찰한 값을 그대로 단언문에 작성한다.
        val fee = calculator.calculate("SEOUL", 25.0)
        fee shouldBe 25000.0
    }

    test("제주 지역의 배송비를 특성화한다 (버그처럼 보이는 동작 포함)") {
        // 3. 관찰: calculator.calculate("JEJU", 10.0)을 실행하니 30000.0이 나왔다.
        // 4. 기록: 이 동작이 옳든 그르든, 현재 동작을 그대로 기록한다. 이것이 핵심이다.
        val fee = calculator.calculate("JEJU", 10.0)
        fee shouldBe 30000.0
    }
})
```

이제 우리는 이 세 개의 테스트라는 든든한 안전망을 갖게 되었다. 이제 개발자는 `calculate` 메소드 내부의 `if`문을 리팩토링하거나 코드를 정리할 수 있다. 만약 리팩토링 과정에서 실수로 제주도 할증 로직을 변경하거나, 무거운 화물의 기준(20.0)을 잘못 건드린다면, 특성화 테스트 중 하나가 즉시 실패하며 위험을 알려줄 것이다.

특성화 테스트는 레거시 코드를 다루는 TDD의 가장 중요한 첫걸음이다. 그것은 우리가 미지의 땅을 탐험하기 전에, 현재 위치와 주변 지형을 정확히 파악하여 안전지도를 그리는 것과 같다. 이 지도가 완성된 후에야, 우리는 비로소 다음 단계인 **의존성 분리 리팩토링**을 통해 본격적으로 코드의 구조를 개선할 준비를 갖추게 된다.