## 03\. 골든 마스터(Golden Master) 기법을 활용한 대규모 리팩토링 전략

특성화 테스트는 메소드의 반환 값이나 객체의 상태 변화를 검증하는 데 효과적이다. 하지만 만약 우리가 리팩토링하려는 코드의 결과물이 수천 줄에 달하는 복잡한 XML 파일, 거대한 JSON 응답, 혹은 픽셀 단위로 정확해야 하는 이미지라면 어떨까? 이런 복잡한 결과물의 모든 요소를 `shouldBe`와 같은 단언문으로 하나하나 검증하는 것은 사실상 불가능하다.

이러한 상황을 위해 고안된 강력한 특성화 테스트 기법이 바로 **골든 마스터(Golden Master) 테스팅**이다. 이 기법의 아이디어는 매우 단순하다. 코드의 현재 출력을 '정답지'로 정하고, 리팩토링 후의 출력이 이 정답지와 한 글자도 다르지 않은지를 통째로 비교하는 것이다.

  * **골든 마스터:** 개발자가 '이것이 현재의 올바른 출력이다'라고 인정한, 기준이 되는 결과 파일(텍스트, JSON, XML 등). 이 파일은 버전 관리 시스템에 테스트 코드와 함께 저장된다.
  * **골든 마스터 테스트:**
    1.  리팩토링 대상 코드를 실행하여 실제 출력물을 생성한다.
    2.  이 출력물을 미리 저장된 골든 마스터 파일과 비교한다.
    3.  두 파일의 내용이 100% 동일하면 테스트는 성공, 단 한 글자라도 다르면 실패한다.

이 기법은 마치 위조지폐를 감별하는 것과 같다. 우리는 지폐의 모든 디자인 요소를 외워서 검증하는 대신, 의심스러운 지폐를 '진짜 지폐(골든 마스터)' 위에 올려놓고 빛에 비춰보며 차이점을 찾아낸다.

### **골든 마스터 테스트 워크플로우**

1.  **최초 출력물 생성:** 리팩토링하려는 레거시 코드를 특정 입력값으로 실행하고, 그 결과로 나온 복잡한 출력(예: `invoice_C123.txt`)을 파일로 저장한다.
2.  **골든 마스터 '승인':** 생성된 `invoice_C123.txt` 파일의 내용을 수동으로 꼼꼼하게 검토한다. 이 내용이 현재 시스템의 '올바른' 동작임을 확인했다면, 이 파일의 이름을 `invoice_C123.golden.txt`와 같이 변경하여 **골든 마스터로 지정**한다. 이 파일은 이제부터 우리의 '정답지'다.
3.  **테스트 하네스 작성:** 다음 로직을 수행하는 테스트 코드를 작성한다.
      * 1단계와 동일한 입력값으로 레거시 코드를 실행한다.
      * 결과 출력물을 새로운 파일(`invoice_C123.new.txt`)에 저장한다.
      * `invoice_C123.new.txt` 파일의 내용과 `invoice_C123.golden.txt` 파일의 내용을 비교하여, 두 내용이 완전히 동일한지 단언(assert)한다.
4.  **리팩토링 및 검증:** 이제 안심하고 레거시 코드를 리팩토링한다. 리팩토링 후 테스트를 다시 실행한다.
      * **테스트 성공:** 당신의 리팩토링이 코드의 최종 결과물에 어떠한 변경도 일으키지 않았음을 의미한다. 안전하게 리팩토링에 성공했다\!
      * **테스트 실패:** 리팩토링 과정에서 실수로 출력물의 내용을 변경했음을 의미한다. `diff` 도구를 사용하여 `golden` 파일과 `new` 파일의 차이점을 확인하면, 정확히 어느 부분이 변경되었는지 즉시 파악할 수 있다.
5.  **의도된 변경의 경우:** 만약 버그 수정이나 기능 추가로 인해 출력물이 '의도적으로' 변경되어야 한다면, 실패한 테스트가 생성한 `new` 파일의 내용이 올바른지 확인한 후, 기존 `golden` 파일을 이 `new` 파일로 덮어쓰는 방식으로 골든 마스터를 갱신한다.

### **실전 예시: 복잡한 텍스트 리포트 생성기**

```kotlin
// 레거시 리포트 생성기
class LegacyReportGenerator {
    fun generate(data: ReportData): String {
        // ... 수백 줄의 문자열을 조합하여 복잡한 리포트를 만드는 로직 ...
        return "..."
    }
}

// 골든 마스터 테스트
class LegacyReportGeneratorTest : FunSpec({
    test("복잡한 리포트 생성이 기존과 동일하게 동작해야 한다") {
        // given
        val generator = LegacyReportGenerator()
        val testData = ReportData(...)
        
        // 1. 골든 마스터 파일을 읽어온다. 이 파일은 이미 검토 후 저장된 상태다.
        val goldenMasterContent = File("src/test/resources/golden_masters/report_v1.golden.txt").readText()

        // when
        val newReportContent = generator.generate(testData)
        
        // then
        // 새로 생성된 리포트가 골든 마스터와 정확히 일치하는지 비교한다.
        newReportContent shouldBe goldenMasterContent
    }
})
```

이 테스트가 있다면, 우리는 `LegacyReportGenerator` 내부의 복잡한 문자열 조합 로직을 더 효율적인 템플릿 엔진으로 교체하는 등의 대규모 리팩토링을 자신감 있게 수행할 수 있다.

-----

골든 마스터 기법은 복잡하고 거대한 결과물을 다루는 레거시 코드를 위한 가장 효과적인 안전망 구축 전략이다. 이 기법을 통해 우리는 아무리 복잡해 보이는 코드라도 현재의 동작을 명확히 정의하고, 그 기반 위에서 점진적인 개선을 향한 담대한 첫걸음을 내디딜 수 있다.

지금까지 우리는 특성화 테스트, 의존성 분리, 골든 마스터 기법을 통해 어떤 종류의 레거시 코드라도 테스트의 안전망 아래로 가져올 수 있는 실용적인 기술들을 배웠다. 이제 두려움의 악순환은 끝났다. 다음 장에서는 TDD를 개인의 기술을 넘어, 팀과 조직 전체의 문화로 정착시키기 위한 여정을 떠나볼 것이다.