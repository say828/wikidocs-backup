## 02\. 의존성 분리 리팩토링: 테스트 가능한 코드로 점진적으로 개선하는 기술

특성화 테스트라는 안전망을 구축하려고 할 때, 우리는 종종 첫 단계부터 거대한 벽에 부딪힌다. "`new MySqlRepository()` 때문에 클래스를 인스턴스화할 수조차 없어요\!" 바로 00절에서 보았던 **강한 결합** 때문이다. 코드를 테스트하려면 먼저 의존성을 분리해야 하고, 의존성을 안전하게 분리하려면 테스트가 필요한 '닭이 먼저냐, 달걀이 먼저냐'의 딜레마에 빠진다.

이 딜레마를 해결하기 위해, 우리는 코드의 동작을 변경하지 않으면서 오직 \*\*'테스트 가능성'\*\*만을 높이기 위한 아주 작은, 외과수술과도 같은 리팩토링 기술들을 사용해야 한다. 이 기술들의 목표는 코드에 \*\*'틈(Seam)'\*\*을 만들어, 테스트 중에 실제 의존성 대신 테스트 더블을 주입할 수 있는 공간을 확보하는 것이다.

### **핵심 원칙: 테스트를 가능하게 하는 최소한의 변경**

이 단계에서 리팩토링의 유일한 목표는 '테스트를 가능하게 만드는 것'이다. 버그를 수정하거나, 새로운 기능을 추가하거나, 구조를 대대적으로 개선하려는 유혹을 참고 오직 의존성을 끊어내는 최소한의 변경에만 집중해야 한다.

#### **기술 1: 생성자 주입으로 전환 (Introduce Constructor Injection)**

  * **문제 상황:** 클래스가 필드 초기화 시점이나 생성자 내부에서 의존성을 직접 생성한다.

```kotlin
// Before
class LegacyOrderProcessor {
    private val validator = OrderValidator() // 직접 생성!

    fun process(order: Order) {
        if (validator.isValid(order)) { /* ... */ }
    }
}
```
  * **리팩토링 절차:**
    1.  의존성(여기서는 `OrderValidator`)의 인터페이스(`IOrderValidator`)를 추출한다.
    2.  인터페이스를 인자로 받는 **새로운 생성자를 추가**한다.
    3.  기존의 기본 생성자는 새로 만든 생성자를 호출하면서, 예전과 똑같이 `new OrderValidator()`를 넘겨주도록 수정한다. **이것이 핵심이다.** 이로써 기존 코드를 전혀 변경하지 않고도 하위 호환성을 보장할 수 있다.
  * **리팩토링 후:**

```kotlin
// After
interface IOrderValidator { fun isValid(order: Order): Boolean }
class OrderValidator : IOrderValidator { /* ... */ }

class LegacyOrderProcessor(private val validator: IOrderValidator) {
    // 기존 코드를 위한 하위 호환성 보장 생성자
    constructor() : this(OrderValidator())

    fun process(order: Order) {
        if (validator.isValid(order)) { /* ... */ }
    }
}

// In Test
val mockValidator = mockk<IOrderValidator>()
val processor = LegacyOrderProcessor(mockValidator) // 테스트에서는 새 생성자를 사용!
```

#### **기술 2: 메소드 매개변수화 (Parameterize Method)**

  * **문제 상황:** 의존성이 특정 메소드 내부에서 생성되고 사용된다.

```kotlin
// Before
class ReportGenerator {
    fun generateReport() {
        val dbConnection = Database.getConnection() // 메소드 내에서 직접 획득
        // ... dbConnection을 사용하여 리포트 생성 ...
    }
}
```

  * **리팩토링 절차:**
    1.  `dbConnection`을 메소드의 파라미터로 받도록 시그니처를 변경한다.
    2.  이 메소드를 호출하는 모든 곳을 찾아서 실제 `Database.getConnection()`의 결과를 전달하도록 수정한다. IDE의 'Change Signature' 리팩토링 기능을 사용하면 안전하게 변경할 수 있다.
  * **리팩토링 후:**

```kotlin
// After
class ReportGenerator {
    fun generateReport(dbConnection: Connection) { // 의존성을 파라미터로 주입받음
        // ... dbConnection을 사용하여 리포트 생성 ...
    }
}

// In Test
val mockConnection = mockk<Connection>()
val generator = ReportGenerator()
generator.generateReport(mockConnection) // Mock 객체를 전달하여 테스트
```

#### **기술 3: 스태틱 호출 분리 (Extract and Override Call)**

  * **문제 상황:** `IdGenerator.generate()`와 같이 Mocking이 불가능한 스태틱 메소드를 직접 호출한다.
  * **리팩토링 절차:**
    1.  스태틱 호출 부분만 별도의 `protected open` 메소드로 추출한다.
    2.  테스트 코드에서는 테스트 대상 클래스를 상속받는 테스트용 서브클래스를 만들고, 추출된 메소드를 오버라이드하여 예측 가능한 값을 반환하도록 한다.
  * **리팩토링 후:**

```kotlin
// Before
class UserService {
    fun register(name: String) {
        val userId = GlobalIdGenerator.generate() // 스태틱 호출!
        // ...
    }
}

// After: Production Code
open class UserService { // 상속을 위해 open 키워드 추가
    fun register(name: String) {
        val userId = generateNewId() // 내부 메소드 호출로 변경
        // ...
    }

    protected open fun generateNewId(): String {
        return GlobalIdGenerator.generate() // 스태틱 호출을 이 메소드 안에 격리
    }
}

// After: Test Code
class TestableUserService : UserService() {
    // 테스트용 서브클래스에서 메소드를 오버라이드
    override fun generateNewId(): String = "test-user-id-123"
}

val service = TestableUserService()
service.register("test") // 이제 항상 "test-user-id-123" ID를 사용
```

이러한 의존성 분리 기술들은 그 자체로 목적이 아니다. 레거시 코드에 특성화 테스트와 TDD라는 생명력을 불어넣기 위한 준비 작업이자 사전 정지 작업이다. 이 작은 '틈'들을 통해 우리는 테스트라는 빛을 코드의 가장 어두운 곳까지 비출 수 있게 되고, 비로소 점진적인 개선의 긴 여정을 시작할 수 있는 용기를 얻게 된다.