# 00장: TDD, 불확실한 대규모 트래픽 시대를 항해하는 기술

우리는 지금껏 경험하지 못한 시대에 살고 있다. 몇 시간 만에 수백만 사용자가 몰리는 서비스, 초당 수십만 건의 요청을 처리해야 하는 시스템, 그리고 비즈니스의 성패가 단 한 번의 장애로 결정될 수 있는 불확실성의 시대. 이러한 대규모 트래픽과 예측 불가능한 변화의 파도 속에서, 과거의 개발 방식은 더 이상 유효하지 않다. '일단 만들고 나중에 고친다'는 접근 방식은 거대한 재앙을 불러오는 시한폭탄과 같다.

이 장에서는 왜 테스트 주도 개발(TDD)이 이 불확실한 시대를 항해하는 가장 강력한 기술인지, 단순한 코딩 습관을 넘어 시스템의 안정성과 비즈니스의 생존을 어떻게 보장하는지에 대한 거대한 서사의 서막을 연다. 우리는 역사상 가장 극적인 금융 소프트웨어 재앙으로 기록된 실제 사건을 통해 이 여정을 시작할 것이다. 이 이야기는 단순한 경고가 아니다. 우리가 앞으로 배울 모든 기술과 철학이 왜 필요한지에 대한 절박한 이유다.

-----

## 00\. 4억 4천만 달러짜리 배포 버튼: Knight Capital Group 붕괴 사고

2012년 8월 1일, 뉴욕 증권 거래소 개장 후 단 45분. 미국 주식 시장 거래량의 17%를 차지하던 거대 금융기업 Knight Capital Group은 회사를 파산 직전으로 몰고 간 4억 4천만 달러(당시 환율 약 5,000억 원)의 손실을 입었다. 원인은 단 한 번의 잘못된 소프트웨어 배포였다.

**사건의 재구성:**

Knight Capital은 SMARS라는 새로운 고빈도 매매(High-Frequency Trading) 시스템을 8대의 프로덕션 서버에 배포하고 있었다. 비극은 이 과정에서 한 명의 기술자가 8대 중 마지막 한 대의 서버에 신규 코드를 배포하는 것을 **누락**하면서 시작되었다.

문제의 그 서버에는 과거에 사용되다 지금은 쓰이지 않는 `Power Peg`이라는 이름의 '죽은 코드(dead code)'가 남아있었다. 공교롭게도 SMARS 시스템은 `Power Peg` 기능이 사용하던 API 플래그를 다른 용도로 재사용하도록 설계되었다.

시장이 개장되고 새로운 시스템이 활성화 신호를 보내자, 7대의 서버는 정상적으로 동작했다. 하지만 구버전 코드가 그대로 남아있던 마지막 한 대의 서버에서 끔찍한 일이 벌어졌다. 비활성화되어 있어야 할 `Power Peg`이라는 좀비가 깨어나, 새로운 활성화 신호를 잘못 해석하고 미친 듯이 시장에 매수/매도 주문을 쏟아내기 시작했다. 단 45분 만에 154개의 다른 주식에 대해 수백만 건의 잘못된 거래가 체결되었고, 회사는 회생 불가능에 가까운 손실을 입고 역사 속으로 사라질 뻔했다.

**무엇이 재앙을 만들었는가?**

이 사건은 한 개인의 실수를 넘어, **검증과 신뢰에 대한 시스템적 부재**가 빚어낸 참사다. 그들의 개발 및 배포 파이프라인에는 다음과 같은 질문에 답할 수 있는 장치가 전혀 없었다.

  * "우리가 배포하려는 소프트웨어가 모든 서버에 **정확히 동일하게** 설치되었음을 어떻게 보장하는가?"
  * "과거에 사용되던 기능이 새로운 시스템에 의해 **의도치 않게 활성화되지 않을 것**이라고 어떻게 확신하는가?"
  * "배포가 완료된 직후, 시스템이 **정말로 우리가 기대하는 상태**에 있는지 어떻게 자동으로 증명할 수 있는가?"

만약 그들이 테스트 주도 개발의 원칙을 배포 파이프라인에까지 확장했다면 어땠을까? 가령, 다음과 같은 간단한 \*\*'배포 후 검증 테스트(Post-deployment Verification Test)'\*\*가 있었다면 말이다.

```shell
# 모든 서버를 순회하며 배포된 애플리케이션의 버전을 확인하는 가상의 테스트 스크립트
EXPECTED_VERSION="v2.1.0-SMARS"

for server in $(get_all_servers); do
  deployed_version=$(ssh $server get_app_version)
  
  if [ "$deployed_version" != "$EXPECTED_VERSION" ]; then
    echo "CRITICAL: Server $server has WRONG version: $deployed_version!"
    # 즉시 롤백 프로세스를 트리거하고 모든 관리자에게 경고를 보낸다.
    trigger_rollback
    exit 1
  fi
done

echo "All servers are correctly deployed with version $EXPECTED_VERSION."
```

위와 같은 자동화된 테스트는 배포 직후 단 몇 초 만에 불일치를 발견하고, 시스템이 치명적인 행동을 시작하기 전에 전체 배포를 중단시켰을 것이다. 4억 4천만 달러짜리 재앙은, 이처럼 단순하지만 **반드시 실행되는 자동화된 검증**이 없었기 때문에 발생했다.

TDD는 단순히 메소드 하나의 기능을 검증하는 단위 테스트(Unit Test)에 국한되지 않는다. TDD의 핵심 철학은 \*\*"우리가 옳다고 생각하는 것을 코드로 증명한다"\*\*는 것이다. 이는 기능의 논리적 정확성은 물론, 인프라의 상태, 배포의 결과, 시스템의 설정값에 이르기까지 소프트웨어를 구성하는 모든 요소에 적용될 수 있다.

이 책은 바로 이 지점에서 시작한다. 다시는 Knight Capital과 같은 비극이 반복되지 않도록, 우리는 '잘 되겠지'라는 막연한 기대를 버리고 실행 가능한 테스트 코드를 통해 우리의 설계를, 우리의 코드를, 우리의 시스템을 스스로 증명하는 법을 배울 것이다. 불확실성의 시대를 항해하는 데 필요한 것은 더 빠른 손가락이 아니라, 추측이 아닌 확신을 가지고 나아가는 규율과 기술이다.