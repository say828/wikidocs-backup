## 01\. 경계값 분석과 동등 분할: 비즈니스 규칙의 빈틈을 찾아내는 테스트 케이스 설계

풍부한 도메인 모델을 만들기로 했다면, 이제 우리는 어떤 테스트 케이스들을 작성해야 그 모델이 정말로 견고하다고 확신할 수 있을지 고민해야 한다. 단순히 '정상적인 경우(Happy Path)' 하나만 테스트하는 것은 충분하지 않다. 대부분의 버그는 우리가 예상치 못한 입력값, 즉 비즈니스 규칙의 경계선에서 발생하기 때문이다.

TDD는 코딩 기법일 뿐만 아니라, 테스트 케이스를 설계하는 공학적 활동이기도 하다. \*\*동등 분할(Equivalence Partitioning)\*\*과 \*\*경계값 분석(Boundary Value Analysis)\*\*은 수십 년간 검증된 고전적인 테스트 설계 기법으로, 우리의 직관과 추측을 넘어 시스템의 빈틈을 체계적으로 찾아낼 수 있도록 돕는 강력한 무기다.

### **동등 분할: 같은 것은 한 번만 테스트한다**

동등 분할은 모든 가능한 입력 데이터의 집합을 '동일한 방식으로 처리될 것으로 예상되는' 부분집합으로 나누는 기법이다. 이렇게 나눠진 각 그룹을 \*\*동등 클래스(Equivalence Class)\*\*라고 부른다. 핵심 아이디어는, 각 동등 클래스 내의 어떤 값을 사용하더라도 시스템의 동작은 동일할 것이므로, 클래스마다 **단 하나의 대표값**만 테스트하면 된다는 것이다. 이는 무한에 가까운 테스트 케이스의 수를 합리적인 수준으로 줄여준다.

**예시: "성인(19세 이상)만 상품을 구매할 수 있다"는 규칙**

이 규칙에 대한 모든 가능한 나이 입력을 두 개의 동등 클래스로 나눌 수 있다.

  * **유효 동등 클래스:** 구매가 허용되는 나이 (19세 이상). 대표값으로 `25`를 선택할 수 있다.
  * **무효 동등 클래스:** 구매가 거부되는 나이 (19세 미만). 대표값으로 `15`를 선택할 수 있다.

따라서 우리는 수많은 나이 값 대신, `25`와 `15` 단 두 개의 케이스만 테스트하여 규칙의 기본 동작을 검증할 수 있다.

### **경계값 분석: 버그는 경계선을 좋아한다**

경계값 분석은 동등 분할을 한 단계 더 발전시킨 기법이다. 수많은 소프트웨어 결함이 동등 클래스의 중간이 아닌, \*\*경계(Boundary)\*\*에서 발생한다는 경험적 사실에 기반한다. 따라서 우리는 각 동등 클래스의 경계선에 있는 값들을 집중적으로 테스트해야 한다.

**예시: "성인(19세 이상)만 상품을 구매할 수 있다"는 규칙의 경계**

이 규칙의 경계는 명확히 `19`세다. 경계값 분석에 따르면 우리는 다음 값들을 테스트해야 한다.

  * `18`: 무효 동등 클래스의 경계 바로 아래 값 (구매 실패 예상)
  * `19`: 유효 동등 클래스의 경계 값 (구매 성공 예상)
  * `20`: 유효 동등 클래스의 경계 바로 위 값 (구매 성공 예상)

개발자가 부등호(`>=`)를 써야 할 곳에 실수로 `>`를 사용하는 것과 같은 흔한 'Off-by-one' 에러는 바로 이 경계값 테스트를 통해 거의 100% 잡아낼 수 있다.

### **TDD 워크플로우에 통합하기**

이 두 기법을 우리의 TDD 사이클에 어떻게 적용할까? Kotest의 데이터 주도 테스트(`withData`)와 함께 사용하면 매우 효율적이다.

**예시: `Purchaser`(구매자) 도메인 객체 TDD**

```kotlin
// 1. 테스트 케이스 설계
// 규칙: 구매자는 19세 이상이어야 한다.
// 동등 클래스: {age < 19}, {age >= 19}
// 경계값: 18 (실패), 19 (성공)

// 2. 가장 중요한 경계값에 대한 실패하는 테스트 먼저 작성
class PurchaserTest : FunSpec({
    test("나이가 19세 미만이면 Purchaser 객체를 생성할 수 없다") {
        shouldThrow<IllegalArgumentException> {
            Purchaser(age = 18) // RED
        }
    }
})

// 3. 테스트를 통과시키는 최소한의 코드 작성 (GREEN & REFACTOR)
data class Purchaser(val age: Int) {
    init {
        require(age >= 19) { "구매자는 19세 이상이어야 합니다." }
    }
}

// 4. 데이터 주도 테스트로 리팩토링하고 더 많은 케이스 추가
class PurchaserRefactoredTest : FunSpec({
    context("구매자 연령 규칙 검증") {
        withData(
            // name, (age, expectedSuccess)
            "경계값 바로 아래 (18세)는 실패해야 한다" to (18 to false),
            "경계값 (19세)은 성공해야 한다" to (19 to true),
            "경계값 바로 위 (20세)는 성공해야 한다" to (20 to true),
            "유효한 대표값 (40세)은 성공해야 한다" to (40 to true)
        ) { (age, expectedSuccess) ->
            if (expectedSuccess) {
                shouldNotThrow<IllegalArgumentException> { Purchaser(age = age) }
            } else {
                shouldThrow<IllegalArgumentException> { Purchaser(age = age) }
            }
        }
    }
})
```

이처럼 동등 분할과 경계값 분석은 우리가 작성해야 할 테스트 케이스를 '선택'하는 체계적인 기준을 제공한다. 이 기법들을 활용하면 최소한의 테스트로 최대의 결함 발견율을 달성할 수 있으며, 이는 곧 TDD의 효율성과 신뢰성을 극대화하는 길이다.