# 04장: 협력의 설계: 애플리케이션 계층 TDD

3장에서 우리는 외부 세계와 완벽히 격리된 순수한 도메인 모델을 TDD로 구축했다. 이 견고한 도메인 모델은 우리 시스템의 핵심 비즈니스 규칙을 지키는 강력한 심장과 같다. 하지만 심장 혼자서는 아무 일도 할 수 없다. 사용자의 요청을 받아들이고, 심장(도메인)이 올바르게 뛰도록 지시하며, 그 결과를 몸의 다른 부분(인프라)에 전달하는 신경계가 필요하다. 이 역할을 하는 곳이 바로 \*\*애플리케이션 계층(Application Layer)\*\*이다.

이 장에서는 도메인 모델이라는 배우들이 제대로 연기할 수 있도록 무대를 설치하고 조율하는 감독의 역할을 배운다. 애플리케이션 계층의 테스트는 순수한 로직을 검증했던 도메인 계층과는 성격이 다르다. 여기서는 여러 객체들, 즉 도메인 모델과 인프라스트럭처(데이터베이스, 메시지 큐 등) 사이의 \*\*'협력'\*\*이 올바르게 설계되었는지를 검증하는 것이 핵심이다.

이를 위해 우리는 1장에서 배웠던 **런던파 TDD(Mockist School)** 스타일을 적극적으로 활용할 것이다. 테스트 더블(Mock, Stub, Fake)을 통해 의존성을 정교하게 격리하고, 객체 간의 상호작용이 우리가 의도한 대로 정확하게 일어나는지를 TDD를 통해 한 단계씩 설계해 나갈 것이다.

-----

## 00\. Use Case와 애플리케이션 서비스의 역할: 도메인과 인프라의 중재자

애플리케이션 계층이 하는 일을 한마디로 정의하면 \*\*'유스케이스(Use Case)의 실현'\*\*이다. 유스케이스란 "사용자가 시스템을 통해 달성하고자 하는 구체적인 목표"를 의미한다. 예를 들어, '상품을 주문한다', '회원으로 가입한다', '비밀번호를 변경한다'와 같은 것들이 모두 유스케이스다.

그리고 이 유스케이스를 코드 레벨에서 구현한 것이 바로 \*\*애플리케이션 서비스(Application Service)\*\*다. 훌륭한 애플리케이션 서비스는 다음과 같은 명확한 역할과 책임을 가진다.

1.  **지휘자 (Orchestrator), NOT 실무자 (Doer):** 애플리케이션 서비스는 **절대 비즈니스 로직을 직접 포함해서는 안 된다.** 모든 핵심 규칙과 로직은 우리가 3장에서 TDD로 구축한 풍부한 도메인 모델에 위임해야 한다. 서비스의 역할은 단지 필요한 도메인 객체(예: `Order`, `Product`)를 리포지토리(Repository)에서 불러오고, 도메인 객체의 메소드를 호출하여 일을 시킨 뒤, 변경된 도메인 객체를 다시 리포지토리에 저장하는 흐름을 '지휘'하는 것이다.
2.  **중재자 (Mediator):** 애플리케이션 서비스는 외부 세계(Controller, API)와 내부 세계(Domain Model) 사이, 그리고 도메인과 인프라스트럭처 사이의 중재자 역할을 한다. 외부로부터 들어온 단순한 데이터(DTO)를 도메인 객체가 이해할 수 있는 형태로 변환하고, 도메인의 처리가 끝나면 그 결과를 다시 외부 세계가 이해할 수 있는 형태로 변환해 반환한다. **도메인 모델은 데이터베이스나 트랜잭션의 존재를 전혀 알 필요가 없다.**
3.  **트랜잭션의 경계 (Transaction Boundary):** 일반적으로 하나의 유스케이스는 하나의 트랜잭션으로 묶인다. 애플리케이션 서비스의 메소드가 시작될 때 트랜잭션이 시작되고, 성공적으로 끝나면 커밋(commit), 중간에 예외가 발생하면 롤백(rollback)된다.

**잘 설계된 애플리케이션 서비스의 흐름**

```kotlin
// 애플리케이션 서비스는 인터페이스(Port)에 의존한다.
class PlaceOrderService(
    private val orderRepository: OrderRepository,       // 인프라 의존성 (Output Port)
    private val productRepository: ProductRepository    // 인프라 의존성 (Output Port)
) {
    // @Transactional // 트랜잭션 경계
    fun placeOrder(request: PlaceOrderRequest): PlaceOrderResponse {
        // 1. 외부 세계의 데이터를 이용해 도메인 객체를 불러온다 (인프라 위임).
        val product = productRepository.findById(request.productId)

        // 2. 도메인 객체에게 핵심 비즈니스 로직을 위임한다.
        // Order.create(...) 메소드 안에 모든 비즈니스 규칙이 캡슐화되어 있다.
        val order = Order.create(product, request.quantity)

        // 3. 결과를 인프라를 통해 영속화한다 (인프라 위임).
        val savedOrder = orderRepository.save(order)

        // 4. 결과를 외부 세계가 이해할 수 있는 DTO로 변환하여 반환한다.
        return PlaceOrderResponse(savedOrder.id)
    }
}
```

이러한 구조에서 TDD는 어떻게 적용될까? `PlaceOrderService`를 테스트할 때, 우리는 `orderRepository`와 `productRepository`를 **목(Mock)** 객체로 만든다. 그리고 다음과 같은 **협력**을 검증한다.

  * `productRepository.findById`가 올바른 `productId`로 호출되었는가?
  * `orderRepository.save`가 `Order.create`를 통해 생성된 `Order` 객체를 인자로 받아 호출되었는가?

우리는 서비스 자체의 복잡한 로직이 아니라, **서비스가 올바른 순서로 올바른 협력 객체들을 호출하는지**에 집중한다. 이를 통해 각 계층의 역할과 책임을 명확하게 분리하고, 유연하고 테스트하기 쉬운 아키텍처를 구축하게 된다.

다음 절에서는 이 협력을 테스트하는 데 필수적인 무기인 테스트 더블(Mock, Stub, Fake)의 정확한 개념과 사용법을 심도 있게 다룰 것이다.