# 08장: 마이크로서비스 아키텍처에서의 TDD: 계약 테스트

7장에서 우리는 단일 시스템 내부의 가장 깊고 어두운 바다인 비동기 세계를 TDD로 정복했다. 하지만 현대 대규모 시스템의 복잡성은 단일 애플리케이션의 경계를 넘어선다. 거대한 하나의 모놀리식(Monolithic) 애플리케이션은 작고, 독립적이며, 자율적인 여러 개의 **마이크로서비스(Microservices)**들로 쪼개져 서로 협력하는 거대한 생태계를 이룬다.

이러한 마이크로서비스 아키텍처(MSA)는 각 서비스의 독립적인 개발, 배포, 확장을 가능하게 하는 엄청난 유연성을 제공한다. 하지만 이 유연성은 **'신뢰'**라는 값비싼 대가를 요구한다. 내가 만든 '주문 서비스'는 저 팀이 만든 '결제 서비스'가 항상 약속대로 동작할 것이라고 어떻게 믿을 수 있는가? '결제 서비스'가 나에게 아무런 통보 없이 API 명세를 바꾸면, 우리 시스템 전체는 어떻게 되는가?

이 장에서는 마이크로서비스라는 거대한 협주곡 속에서 각 연주자들이 조화롭게 화음을 낼 수 있도록 보장하는 TDD 전략을 배운다. 전통적인 통합 테스트가 MSA 환경에서 왜 지옥으로 변하는지, 그리고 그 해답으로서 **소비자 주도 계약 테스트(Consumer-Driven Contract Testing)**가 어떻게 서비스 간의 깨지기 쉬운 신뢰를 코드로 증명하고 자동화하는지를 깊이 있게 탐구할 것이다.

---

## 00. MSA가 통합 테스트를 지옥으로 만드는 이유: 신뢰의 위기

모놀리식 환경에서 통합 테스트는 비교적 단순했다. 하나의 애플리케이션 내부에서 데이터베이스, 메시지 큐 등 몇몇 의존성만 관리하면 되었다. 하지만 수십, 수백 개의 마이크로서비스가 얽혀있는 환경에서 전통적인 방식의 통합 테스트는 단순한 어려움을 넘어 **'불가능한 지옥'**으로 변모한다.

상상해보자. '주문 서비스'의 작은 기능을 하나 테스트하기 위해, 이와 연관된 '결제 서비스', '재고 서비스', '사용자 서비스', '배송 서비스'를 모두 테스트 환경에 띄워야 한다. 이 시나리오는 다음과 같은 현실적인 재앙을 불러온다.

1.  **환경 구성의 복잡성 폭발:**
    * 수십 개 서비스의 특정 버전을 한곳에 모으고, 각 서비스가 의존하는 데이터베이스와 메시지 큐까지 모두 설치하고 설정해야 한다. 이 환경을 구축하고 유지보수하는 데 드는 비용은 기하급수적으로 증가한다.
2.  **느리고 불안정한 테스트:**
    * 단일 기능을 테스트하기 위해 수많은 서비스가 네트워크를 통해 통신해야 하므로 테스트 실행 속도가 극도로 느려진다.
    * 수많은 의존성 중 단 하나라도 네트워크 문제나 자체 버그로 인해 불안정하면, 우리 서비스에는 아무런 문제가 없음에도 불구하고 테스트는 실패한다. 이런 '가짜 실패(False Negative)'는 테스트 스위트 전체의 신뢰도를 파괴한다.
3.  **자율성의 상실:**
    * '결제 서비스' 팀이 새로운 기능을 개발 중이라 테스트 환경의 API가 불안정하다면, '주문 서비스' 팀은 개발이 완료될 때까지 통합 테스트를 실행할 수 없다. 이는 마이크로서비스가 추구하는 '독립적인 개발과 배포'라는 핵심 가치를 정면으로 위배한다.

이 통합 테스트의 지옥은 결국 **'신뢰의 위기'**를 낳는다. 우리는 더 이상 테스트 결과를 믿을 수 없게 되고, 배포에 대한 자신감을 잃는다. 결국 개발 속도는 점점 느려지고, 변경에 대한 두려움은 커진다. "내 코드는 문제가 없는데, 왜 테스트가 실패하는 거지?"라는 질문에 답을 찾기 위해 수많은 시간을 낭비하게 된다.

### **Mocking의 한계**

"그렇다면 5장에서 배운 것처럼 WireMock으로 다른 서비스를 Mocking 하면 되지 않을까?" 물론 가능하다. '주문 서비스'를 테스트하기 위해 '결제 서비스'의 API를 Mocking 할 수 있다. 하지만 여기서 새로운 질문이 생긴다.

**"당신이 만든 그 Mock API가, 실제 '결제 서비스'의 동작과 일치한다고 어떻게 보장할 수 있는가?"**

'결제 서비스' 팀이 응답 JSON에 `payment_status` 필드를 `status`로 바꾸는 리팩토링을 하고 배포했다고 가정하자. '주문 서비스' 팀은 이 사실을 전혀 모른 채, 계속해서 `payment_status` 필드를 기대하는 오래된 Mock API를 가지고 테스트를 진행할 것이다. 로컬과 CI에서의 모든 테스트는 완벽하게 통과하겠지만, 프로덕션 환경에 배포되는 순간 두 서비스의 통신은 실패하고 시스템은 장애를 일으킨다.

결국, 전통적인 통합 테스트와 단순한 Mocking 방식 모두 MSA 환경에서 서비스 간의 **'깨지기 쉬운 계약(Brittle Contract)'** 문제를 해결하지 못한다. 한쪽의 변경이 다른 쪽에 미치는 영향을 자동으로, 그리고 배포 이전에 발견할 수 있는 새로운 방식의 테스트가 필요하다. 이것이 바로 다음 절에서 우리가 배울 **소비자 주도 계약 테스트**가 필요한 이유다.