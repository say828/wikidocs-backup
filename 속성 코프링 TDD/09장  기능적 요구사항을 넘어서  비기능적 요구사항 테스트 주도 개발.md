# 09장: 기능적 요구사항을 넘어서: 비기능적 요구사항 테스트 주도 개발

지금까지 우리는 TDD를 통해 시스템이 **'무엇을'** 해야 하는지, 즉 \*\*기능적 요구사항(Functional Requirements)\*\*을 검증하는 여정을 걸어왔다. 우리 시스템은 이제 명세에 따라 정확하게 동작한다. 하지만 "정확하게 동작하는 것"만으로는 충분하지 않다. "얼마나 빠르게 동작하는가?", "장애 상황에서 얼마나 잘 버티는가?", "얼마나 안전한가?"와 같은 질문에 답해야 한다. 이것이 바로 \*\*비기능적 요구사항(Non-Functional Requirements, NFRs)\*\*의 세계다.

전통적으로 성능, 안정성, 보안과 같은 NFR은 개발 주기 가장 마지막에, 별도의 QA나 운영팀에 의해 검증되었다. 이 방식은 너무 늦게 문제를 발견하여 수정 비용이 크고, 근본적인 아키텍처 결함을 해결하지 못하는 한계를 가진다.

이 장에서는 TDD의 패러다임을 비기능적 요구사항으로 확장하는 혁신적인 접근법을 탐험한다. 실패하는 '성능' 테스트를 먼저 작성하여 최적화를 이끌어내고, 의도적으로 장애를 주입하는 '카오스' 테스트를 통해 시스템의 회복탄력성을 검증하며, 테스트 코드를 통해 보안 취약점을 방어하는 고급 TDD 전략을 마스터할 것이다. 이를 통해 우리는 기능적으로 올바르면서 동시에 빠르고, 견고하며, 안전한 시스템을 만드는 전문가로 거듭날 것이다.

-----

## 00\. TDD 사이클에 성능 테스트 통합하기: k6, Gatling과 시나리오 기반 테스트

"시스템이 빨라야 한다"는 말은 측정할 수 없는 모호한 요구사항이다. TDD의 첫걸음이 실패하는 테스트를 통해 '요구사항을 명확히 정의'하는 것이었듯, 성능 TDD의 첫걸음 또한 \*\*"성능 목표(Performance Goal)를 실행 가능한 테스트 코드로 명세"\*\*하는 것이다.

우리의 목표는 다음과 같은 구체적인 성능 요구사항을 테스트로 만드는 것이다.
`"상품 주문 API(POST /orders)는 초당 100개의 요청(RPS) 부하 환경에서, 95퍼센타일(95th percentile) 응답 시간이 200ms 이하여야 한다."`

이러한 시나리오 기반 부하 테스트를 위해 우리는 **k6**나 **Gatling**과 같은 전문 부하 테스트 도구를 사용한다. 이 도구들은 수백, 수천 명의 가상 사용자(Virtual User)를 시뮬레이션하여 실제 운영 환경과 유사한 트래픽을 발생시키는 스크립트를 코드로 작성할 수 있게 해준다.

### **성능 TDD 워크플로우**

#### **1. 실패하는 성능 테스트 작성 (RED)**

**k6**는 Grafana Labs에서 만든 JavaScript 기반의 현대적인 부하 테스트 도구다. 스크립트가 간단하고 강력하여 개발자들이 사용하기에 매우 편리하다. 위에서 정의한 성능 목표를 k6 스크립트로 작성해보자.

```javascript
// performance/order-api.test.js
import http from 'k6/http';
import { check } from 'k6';

// k6 실행 옵션: 성능 목표를 'Thresholds'로 명세
export const options = {
  vus: 50, // 50명의 가상 사용자가
  duration: '30s', // 30초 동안 테스트를 수행
  thresholds: {
    // http_req_duration 지표의 95퍼센타일 값이 200ms 미만이어야 한다는 성공 기준
    'http_req_duration': ['p(95)<200'], 
  },
};

export default function () {
  const url = 'http://localhost:8080/orders';
  const payload = JSON.stringify({
    productId: 1,
    quantity: 2,
  });
  const params = {
    headers: { 'Content-Type': 'application/json' },
  };

  const res = http.post(url, payload, params);
  check(res, { 'status was 201': (r) => r.status == 201 });
}
```

이제 로컬 환경에서 우리 애플리케이션을 실행하고, 터미널에서 `k6 run performance/order-api.test.js` 명령을 실행한다. 아직 최적화되지 않은 초기 버전의 코드는 이 부하를 견디지 못하고 95퍼센타일 응답 시간이 200ms를 초과할 것이다. k6는 Thresholds 검증에 실패하며 0이 아닌 종료 코드를 반환한다. 이것이 우리의 **RED** 상태다.

#### **2. 성능 목표 달성 (GREEN)**

이제 우리에게는 명확한 목표가 생겼다. "k6 테스트를 통과시켜라." 개발자는 VisualVM, JProfiler, Pinpoint와 같은 APM 또는 프로파일링 도구를 사용하여 애플리케이션의 병목 지점을 찾는다.

  * 느린 DB 쿼리가 원인인가? -\> 쿼리를 튜닝하거나 인덱스를 추가한다.
  * 불필요한 객체 생성이 많은가? -\> 코드 로직을 최적화한다.
  * 외부 API 호출이 느린가? -\> 캐시(Cache) 도입을 검토한다.

수정이 이루어질 때마다 다시 k6 테스트를 실행하여 성능 개선 여부를 즉시 피드백 받는다. 이 과정을 반복하여 마침내 k6 테스트의 `p(95)<200ms` 기준을 통과하면, 우리는 **GREEN** 상태에 도달한다.

#### **3. 리팩토링 (REFACTOR)**

성능 목표를 만족하는 안전망 위에서, 최적화 과정에서 지저분해졌을 수 있는 코드를 리팩토링하여 가독성과 구조를 개선한다. 물론, 리팩토링 후에도 k6 테스트는 계속 통과해야 한다.

### **CI/CD 파이프라인에 통합하기**

성능 테스트는 일회성으로 끝나서는 안 된다. CI/CD 파이프라인에 이 k6 테스트를 통합하여, 새로운 코드 변경이 성능 저하를 유발하지 않는지(Performance Regression) 지속적으로 검증해야 한다. 매 커밋마다 실행하기에는 무거울 수 있으므로, main 브랜치에 머지될 때나 매일 밤 실행되는 'Nightly Build' 단계에 포함시키는 것이 일반적이다. 만약 성능 테스트가 실패하면, 빌드는 중단되고 즉시 팀에 경고가 전달된다.

성능을 '개발 후의 튜닝'이 아닌, '개발 과정의 명확한 목표'로 삼는 것. 이것이 바로 성능 TDD의 핵심이다. k6나 Gatling과 같은 도구를 통해 우리는 성능 요구사항을 실행 가능한 코드로 전환하고, 이를 TDD 사이클에 통합하여 처음부터 빠르고 확장 가능한 시스템을 자신감 있게 구축할 수 있다.