## 02\. 테스트 주도 개발(TDD)을 넘어서: 테스트 주도 '설계'와 '시스템 안정성'

이제 우리는 '테스트 케이스'가 가장 완벽한 명세서라는 사실을 확인했다. 그러나 TDD의 진정한 힘은 단순히 버그를 찾는 수준에 머무르지 않는다. 많은 개발자들이 TDD를 '테스트를 먼저 작성하는 개발 방법론' 정도로 오해하지만, 이는 TDD의 거대한 가치를 절반도 이해하지 못한 것이다. TDD의 본질은 \*\*테스트 주도 개발(Test-Driven Development)\*\*이 아니라, \*\*테스트 주도 설계(Test-Driven Design)\*\*에 있다.

'개발'이 코드를 작성하는 행위 그 자체에 집중한다면, '설계'는 코드의 구조, 객체 간의 책임과 협력, 그리고 미래의 변화에 대한 유연성을 고민하는 상위 레벨의 활동이다. TDD는 이 설계 과정을 실패의 위험이 없는 안전한 환경에서, 가장 빠른 피드백 루프를 통해 수행하도록 돕는 강력한 설계 기법이다.

어떻게 그것이 가능할까? 테스트 코드를 먼저 작성하는 행위는 개발자에게 한 가지 역할을 강제하기 때문이다. 바로 \*\*'내가 만들 코드의 첫 번째 사용자(client)'\*\*가 되어보는 것이다.

API를 설계한다고 생각해보자. 전통적인 방식에서는 클래스 내부의 구현부터 시작하여 `public` 메소드를 외부로 노출시킨다. 개발자의 관점은 철저히 '공급자'의 입장에 머물러 있다. 반면, TDD에서는 테스트 케이스에서 아직 존재하지 않는 객체와 메소드를 '호출'하는 것으로부터 시작한다.

```kotlin
// 아직 OrderService 클래스도, placeOrder 메소드도 존재하지 않는다.
// 하지만 우리는 이 코드를 사용하는 '고객'의 입장에서 가장 이상적인 모습을 상상하며 코드를 작성한다.
@Test
fun `고객은 상품 ID와 수량을 통해 주문을 할 수 있다`() {
    // given
    val productId = "TSHIRT-001"
    val quantity = 2
    val customerId = "CUST-123"
    
    // when
    // "어떻게 하면 주문을 가장 쉽게 할 수 있을까?" -> OrderService.placeOrder(customerId, productId, quantity)
    // 위와 같은 인터페이스가 가장 직관적이라고 '설계'하는 과정이다.
    val newOrder: Order = orderService.placeOrder(customerId, productId, quantity)

    // then
    // 주문 결과로 무엇을 확인하고 싶을까? -> 주문 ID가 생성되었고, 상태가 '접수'인지 확인하고 싶다.
    assertNotNull(newOrder.id)
    assertEquals(OrderStatus.ACCEPTED, newOrder.status)
}
```

이처럼 테스트를 먼저 작성하는 과정은 곧 코드의 인터페이스(API)를 사용하는 입장에서 가장 이해하기 쉽고, 사용하기 편하며, 오해의 소지가 없는 형태로 다듬는 과정과 같다. 복잡한 설정 객체 대신 필요한 데이터만 명확히 전달하고, 메소드의 이름은 그 자체로 행위와 결과를 설명하도록 지어진다. 결과적으로 TDD를 통해 만들어진 코드는 **결합도(Coupling)는 낮고, 응집도(Cohesion)는 높은** 이상적인 설계 원칙을 자연스럽게 따르게 된다.

그리고 바로 이 **'좋은 설계'가 '시스템 안정성'의 초석**이다.

  * **낮은 결합도와 시스템 안정성:** TDD는 의존성을 격리하여 테스트하는 것을 장려한다. 이 과정에서 자연스럽게 객체들은 서로에게 느슨하게 연결된다. 이는 Knight Capital 사례에서 본 것과 같은 '연쇄 폭발'을 막는 방화벽이 된다. 하나의 모듈에서 발생한 문제가 다른 모듈로 쉽게 전파되지 않아, 시스템 전체가 붕괴되는 최악의 상황을 방지한다.
  * **높은 응집도와 시스템 안정성:** TDD는 '한 번에 하나의 실패만'을 다룬다. 이는 개발자가 지금 해결해야 할 가장 작은 문제에 집중하도록 만든다. 결과적으로 만들어지는 코드(클래스, 메소드)는 명확하게 정의된 단 하나의 책임만을 갖게 된다. 이러한 코드는 이해하고 수정하기가 쉬워, 미래에 변경이 발생했을 때 버그가 발생할 가능성을 극적으로 낮춘다.

결론적으로 TDD는 테스트를 위한 활동이 아니다. TDD는 **실행 가능한 테스트라는 안전망** 위에서, **가장 빠른 피드백을 받으며** 코드의 구조를 끊임없이 개선해나가는 **설계 활동**이다. 우리가 작성하는 실패하는 테스트 하나하나는 단순히 버그를 찾는 신호가 아니라, 더 나은 설계를 향한 이정표다. 그리고 수많은 이정표를 따라 완성된 좋은 설계야말로, 예측 불가능한 트래픽과 끊임없는 변화 속에서도 우리 시스템을 굳건히 지켜줄 가장 강력한 무기다.