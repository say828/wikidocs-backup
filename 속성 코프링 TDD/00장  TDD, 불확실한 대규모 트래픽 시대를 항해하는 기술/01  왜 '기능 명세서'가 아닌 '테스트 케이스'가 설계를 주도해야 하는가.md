## 01\. 왜 '기능 명세서'가 아닌 '테스트 케이스'가 설계를 주도해야 하는가

Knight Capital의 붕괴는 한 명의 엔지니어가 저지른 실수가 아니라, **'추측'과 '가정'에 기반한 개발 프로세스**가 빚어낸 필연적인 참사였다. 그들은 '배포 스크립트가 모든 서버에 동일하게 적용될 것'이라 가정했고, '비활성화된 코드는 영원히 잠들어 있을 것'이라 추측했다. 이 모든 위험한 가정의 뿌리에는 소프트웨어 개발의 가장 오래된 관행, 바로 \*\*'기능 명세서'\*\*에 대한 맹목적인 의존이 있다.

전통적인 개발 프로세스는 기획자가 작성한 기능 명세서에서 시작된다. 이 문서는 대부분 자연어(한국어, 영어 등)로 작성된 '산문(prose)'이다. 산문은 아이디어를 전달하는 훌륭한 도구이지만, 시스템의 동작을 정의하는 데에는 다음과 같은 치명적인 결함을 가진다.

1.  **모호성 (Ambiguity):** "주문 시 프로모션 코드를 적용할 수 있어야 한다." 이 문장은 명료해 보이지만, 개발자에게는 수십 가지 질문을 던진다. 유효하지 않은 프로모션 코드가 입력되면 어떻게 해야 하는가? 한 번 사용한 코드를 다시 사용하면? 재고가 없는 상품에 적용하면? 자연어는 이러한 경계 조건과 예외 상황을 명시적으로 표현하기 어려우며, 개발자는 해석의 빈틈을 자신의 '가정'으로 채워 넣는다.
2.  **불완전성 (Incompleteness):** 명세서는 주로 '정상적인 시나리오(Happy Path)'에 집중한다. Knight Capital의 사례처럼, '오래된 기능 플래그가 재사용될 경우'와 같은 복잡하고 기술적인 맥락의 시나리오는 명세서에서 완벽하게 다루기 불가능하다. 결국 문서는 현실의 복잡성을 따라가지 못하고, 코드와 문서 사이의 괴리는 점점 커진다.
3.  **피드백의 부재 (Lack of Feedback):** 가장 치명적인 문제다. 기능 명세서는 살아있는 유기체가 아니다. 명세서의 내용이 실제 시스템의 동작과 일치하는지 자동으로, 그리고 지속적으로 검증할 방법이 없다. 배포가 끝난 후에도 명세서의 모든 조항이 지켜졌는지 증명할 길은 없다. 그것은 그저 '희망 사항'의 목록일 뿐이다.

이것이 바로 TDD가 개발의 중심축을 '기능 명세서'에서 \*\*'실행 가능한 테스트 케이스'\*\*로 옮겨야 한다고 주장하는 이유다. 테스트 케이스는 단순한 검증 도구를 넘어, 그 자체가 가장 완벽하고 정밀한 형태의 명세서가 된다.

[도표: 기능 명세서 vs. 테스트 케이스 명세서]

| 특성 | 전통적인 기능 명세서 (자연어) | 테스트 케이스 명세서 (코드) |
| :--- | :--- | :--- |
| **정밀성** | 모호함. 해석의 여지가 많음. | 명백함. 코드는 거짓말을 하지 않음. |
| **완전성** | 주로 정상 경로에 집중. 경계/예외 누락. | 다양한 시나리오(정상, 경계, 예외)를 구체적으로 강제함. |
| **피드백** | 수동적, 비연속적. 자동 검증 불가. | 능동적, 지속적. 실행 즉시 피드백 제공. |
| **역할** | 개발의 '시작점'일 뿐, 개발 완료 후 버려짐. | 시스템의 생명주기 내내 살아있는 '문서'이자 '안전망' |
| **설계에 미치는 영향** | 간접적. 개발자의 해석에 의존. | 직접적. 테스트를 통과시켜야 한다는 목표가 코드 설계를 주도. |

TDD에서 우리가 가장 먼저 작성하는 실패하는 테스트 코드를 보자. 이것은 단순한 코드가 아니라, 누구도 오해할 수 없는 \*\*실행 가능한 명세서(Executable Specification)\*\*다.

```kotlin
@Test
fun `유효 기간이 지난 프로모션 코드를 적용하면 예외가 발생해야 한다`() {
    // given: 유효 기간이 어제로 만료된 프로모션 코드가 존재한다.
    val expiredPromoCode = promoCodeRepository.save(
        PromoCode(code = "EXPIRED2025", discountRate = 0.1, expirationDate = LocalDate.now().minusDays(1))
    )
    val orderRequest = OrderRequest(productId = "P001", promoCode = "EXPIRED2025")

    // when & then: 해당 코드로 주문을 시도하면,
    // 명확한 예외(InvalidPromoCodeException)가 발생하는 것을 기대한다.
    assertThrows<InvalidPromoCodeException> {
        orderService.placeOrder(orderRequest)
    }
}
```

이 테스트 코드는 "유효 기간이 지난 프로모션 코드는 사용할 수 없다"는 비즈니스 규칙을 한 줄의 오차도 없이 명세한다. 개발자는 이 테스트를 통과시키기 위해 `placeOrder` 메소드 내부에 날짜를 확인하는 로직을 **반드시** 추가해야만 한다. '깜빡 잊거나', '잘못 해석할' 여지가 원천적으로 차단된다.

**결론적으로, TDD는 개발의 패러다임을 바꾼다.** 모호한 자연어 명세서를 해석하고 추측하며 개발하는 것이 아니라, 명확하고 실행 가능한 테스트 케이스라는 나침반을 따라 코드를 항해하는 것이다. 이 나침반은 우리가 가야 할 길을 정확히 알려주고, 암초(버그와 설계 결함)를 피하게 해주며, 최종적으로는 Knight Capital의 비극과 같은 예측 불가능한 재앙으로부터 우리의 시스템을 지켜주는 가장 신뢰할 수 있는 도구다.