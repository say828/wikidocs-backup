## 01. 부하 테스트(Load Testing)를 통한 병목 지점 식별 및 개선 TDD

앞 절에서 우리는 k6를 통해 "성능 목표를 정의하는 실패하는 테스트"를 작성했다. 이제 우리에겐 "p(95) 응답 시간이 500ms인데, 목표는 200ms다"와 같은 명확한 실패(RED) 상태가 있다. 그렇다면 이 300ms의 차이는 대체 어디에서 발생하는 것일까?

성능 개선은 추측이나 감으로 하는 것이 아니다. **부하 테스트를 통해 시스템에 압력을 가하고, 프로파일링(Profiling) 및 APM(Application Performance Monitoring) 도구를 통해 시스템 내부를 관찰하여 데이터에 기반한 병목 지점을 찾아내는 과학적인 과정**이다. TDD의 `Green` 단계는 바로 이 '측정-분석-수정-검증'의 반복 루프다.

### **성능 개선 TDD 루프**

1.  **RED (기준선 설정):** 이전 절에서 작성한 k6/Gatling 스크립트를 실행한다. 이 실패한 테스트 결과(예: p(95)=500ms)가 우리의 **베이스라인(Baseline)**이 된다. 모든 개선은 이 베이스라인과 비교하여 측정된다.
2.  **INVESTIGATE (병목 지점 분석):** 부하 테스트를 실행하는 **동시에** APM이나 프로파일링 도구로 애플리케이션을 관찰한다.
    * **APM (Pinpoint, Scouter, New Relic 등):** 실제 운영 환경처럼 요청의 전체 흐름을 추적하여 "어떤 메소드에서 시간이 가장 오래 걸리는가?", "어떤 SQL 쿼리가 느린가?", "외부 API 호출의 지연 시간은 얼마인가?"를 시각적으로 보여준다.  대부분의 병목은 APM을 통해 쉽게 발견된다.
    * **프로파일러 (VisualVM, JProfiler 등):** APM으로 원인이 특정되지 않는 경우, 프로파일러를 사용하여 JVM 내부를 더 깊게 들여다본다. "어떤 코드 라인에서 CPU를 가장 많이 사용하는가?", "과도한 GC(Garbage Collection)가 발생하고 있는가?", "스레드들이 특정 락(Lock)을 기다리며 대기하고 있는가?" 등을 분석할 수 있다.
3.  **FIX (가설 기반 수정):** 분석 데이터를 바탕으로 병목의 원인에 대한 가설을 세우고, **단 하나의 수정**을 적용한다. "N+1 쿼리가 문제의 원인이므로, `JOIN FETCH`를 적용하여 쿼리 횟수를 줄인다" 와 같이 말이다. 한 번에 여러 개를 수정하면 어떤 수정이 성능 개선에 영향을 미쳤는지 알 수 없다.
4.  **RE-TEST (개선 검증 → GREEN):** **동일한 k6 스크립트**를 다시 실행하여 베이스라인과 결과를 비교한다.
    * **성능 개선:** p(95) 응답 시간이 200ms 이하로 떨어졌다면, 우리의 가설과 수정이 옳았음이 증명된 것이다. **GREEN** 상태에 도달했다.
    * **개선 미미 또는 악화:** 성능이 목표에 도달하지 못했다면, 방금 적용한 수정을 되돌리고(revert) 2번 분석 단계로 돌아가 다른 가설을 세운다.

### **실전 예시: N+1 쿼리 문제 해결**

`GET /categories/{id}/products` API가 특정 카테고리의 모든 상품 목록을 반환한다고 가정하자.

* **TDD 프로세스:**
    1.  **(RED):** k6로 "카테고리에 상품이 50개일 때, 100ms 안에 응답해야 한다"는 테스트를 작성한다. 초기 구현은 N+1 문제를 가지고 있어, 1개의 카테고리 쿼리와 50개의 상품 쿼리, 총 51개의 쿼리를 실행한다. 당연히 테스트는 응답 시간 초과로 **실패**한다.
    2.  **(INVESTIGATE):** 부하 테스트 중 APM을 확인하자, 해당 API 호출에서 수십 개의 유사한 SQL 쿼리가 실행되는 것이 명확하게 보인다. N+1 문제가 병목 지점으로 즉시 식별된다.
    3.  **(FIX):** `CategoryRepository`의 쿼리 메소드에 `@Query("... JOIN FETCH c.products")`를 추가하여 단 한 번의 쿼리로 카테고리와 모든 상품을 함께 조회하도록 수정한다.
    4.  **(GREEN):** k6 테스트를 다시 실행한다. 이제 단 하나의 쿼리만 실행되므로 응답 시간은 극적으로 단축되고, 100ms 기준을 통과하여 테스트는 **성공**한다.

이처럼 부하 테스트를 TDD 사이클의 일부로 사용하는 것은 성능 개선 과정을 '어둠 속의 추측'에서 '데이터 기반의 공학'으로 바꾸어 놓는다. 실패하는 성능 테스트는 우리가 해결해야 할 명확한 목표를 제시하고, APM과 프로파일러는 그 목표에 도달하기 위한 지도를 제공하며, 반복적인 재측정은 우리가 올바른 길을 가고 있다는 확신을 준다.