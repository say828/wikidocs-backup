## K8s 환경에서의 네트워킹과 서비스 디스커버리 (K8s 네이티브 방식)

05장에서 우리는 마이크로서비스들이 서로를 찾기 위해 `Eureka`나 `Consul` 같은 별도의 **'서비스 레지스트리(Service Registry)'**가 반드시 필요하다고 배웠습니다. `order-service`는 `product-service`의 실제 IP 주소를 모르기 때문에, 중앙의 '전화번호부'에 물어봐야만 했습니다.

하지만 우리가 애플리케이션을 쿠버네티스(K8s) 위에 배포하는 순간, 이 패러다임은 완전히 바뀝니다.

> **"쿠버네티스 환경에서는, 별도의 서비스 레지스트리가 필요 없다."**

쿠버네티스는 서비스 디스커버리와 네트워킹을 **플랫폼의 핵심 기능으로 내장**하고 있기 때문입니다. 이는 우리 아키텍처에서 `Eureka`나 `Consul` 서버 같은 복잡한 컴포넌트를 하나 덜어낼 수 있다는 것을 의미합니다.

---

### 쿠버네티스는 어떻게 이 문제를 해결하는가?

쿠버네티스의 네이티브 서비스 디스커버리는 16장 01절에서 배운 **`Service` 오브젝트**와 클러스터 내장 **DNS**의 조합으로 이루어집니다.

1.  **`Service` 오브젝트의 역할: 안정적인 가상 IP 제공**
    우리가 `member-service`를 위한 `Service` YAML을 클러스터에 적용하면, 쿠버네티스는 `member-service`라는 논리적인 이름에 대해 **변하지 않는 고유한 가상 IP (Cluster IP)**를 할당합니다. 이 `Service`는 `selector`를 이용해 실제 `member-service` Pod들의 IP 주소 목록을 항상 최신 상태로 유지하고, 이 가상 IP로 오는 트래픽을 실제 Pod들에게 로드 밸런싱합니다.

2.  **클러스터 내장 DNS (CoreDNS): 서비스 이름을 IP로 변환**
    모든 쿠버네티스 클러스터에는 `CoreDNS`와 같은 내장 DNS 서버가 함께 설치됩니다. 이 DNS 서버는 쿠버네티스 API와 연동하여, 클러스터 내부의 모든 `Service` 오브젝트에 대한 **DNS A 레코드**를 자동으로 생성하고 관리합니다.

    * `member-service`라는 이름의 `Service`가 `default` 네임스페이스에 생성되면, K8s DNS는 클러스터 내부 어디에서나 접근할 수 있는 다음과 같은 FQDN(정규화된 도메인 이름)을 자동으로 생성합니다.
        * **`member-service.default.svc.cluster.local`**
    * 더 놀라운 것은, 같은 네임스페이스 내에서는 FQDN 전체를 쓸 필요 없이, 그냥 **`member-service`**라는 서비스 이름만으로 통신이 가능하다는 점입니다.

---

### 실제 통신 흐름

이제 `API 게이트웨이`가 `member-service`를 호출하는 과정이 어떻게 바뀌는지 살펴봅시다.



1.  `gateway-service` 컨테이너 내부에서 `http://member-service/api/v1/members/1`로 HTTP 요청을 보냅니다. (더 이상 `lb://MEMBER-SERVICE` 같은 프로토콜이 필요 없습니다.)
2.  컨테이너의 OS는 `member-service`라는 호스트 이름을 해석하기 위해 클러스터 내장 DNS 서버(`CoreDNS`)에 DNS 쿼리를 보냅니다.
3.  `CoreDNS`는 `member-service`라는 이름에 매핑된 **`Service`의 안정적인 가상 IP (Cluster IP)**를 응답으로 돌려줍니다.
4.  이제 `gateway-service`는 이 가상 IP를 목적지로 하여 실제 네트워크 패킷을 전송합니다.
5.  이 패킷은 쿠버네티스의 네트워크 프록시(`kube-proxy`)에 의해 가로채지고, `member-service`가 관리하는 여러 Pod(예: 3개) 중 하나로 **로드 밸런싱**되어 최종적으로 전달됩니다.

이 모든 복잡한 과정은 쿠버네티스 플랫폼 레벨에서 투명하게 처리됩니다. 개발자는 **마치 같은 서버에 있는 다른 프로세스를 DNS 이름으로 호출하는 것처럼** 단순하게 코드를 작성하기만 하면 됩니다.

---

### 아키텍처의 변화

* **의존성 제거:** `spring-cloud-starter-netflix-eureka-client`나 `spring-cloud-starter-consul-discovery` 같은 클라이언트 라이브러리가 더 이상 필요 없어집니다. 애플리케이션이 가벼워집니다.
* **인프라 단순화:** `Eureka Server`나 `Consul` 클러스터를 별도로 구축하고 관리할 필요가 없어집니다. 운영 복잡도가 크게 감소합니다.
* **설정 단순화:** `application.yml`에서 `eureka.client.service-url` 같은 설정이 모두 사라집니다. `WebClient`나 다른 HTTP 클라이언트는 서비스 이름(예: `http://product-service`)을 Base URL로 사용하기만 하면 됩니다.

**결론적으로,** 쿠버네티스는 서비스 디스커버리라는, 이전에는 애플리케이션 레벨(Spring Cloud)에서 해결해야 했던 복잡한 문제를 인프라 레벨의 기본 기능으로 흡수했습니다. 이는 우리 마이크로서비스 아키텍처를 더욱 단순하고, 견고하며, 진정한 '클라우드 네이티브'로 만들어주는 핵심적인 변화입니다.