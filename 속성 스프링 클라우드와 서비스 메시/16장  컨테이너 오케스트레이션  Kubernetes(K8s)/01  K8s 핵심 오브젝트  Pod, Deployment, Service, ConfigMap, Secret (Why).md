## K8s 핵심 오브젝트: Pod, Deployment, Service, ConfigMap, Secret (Why)

쿠버네티스를 이해하는 것은, 쿠버네티스가 세상을 바라보는 방식, 즉 **'오브젝트(Object)'** 모델을 이해하는 것에서 시작합니다. 우리는 `docker run`처럼 컨테이너를 직접 실행하라고 명령하지 않습니다. 대신, **'원하는 상태(Desired State)'**를 `YAML` 파일에 오브젝트 형태로 선언하면, 쿠버네티스가 그 상태를 만들어주고 유지하기 위해 끊임없이 일합니다.

이 장에서는 애플리케이션을 배포하는 데 필요한 가장 기본적인 5가지 핵심 오브젝트의 '존재 이유(Why)'를 알아보겠습니다.

---

### 1. Pod (파드): 배포의 최소 원자 단위 🌱

* **정의:** 쿠버네티스에서 **생성하고 관리할 수 있는 가장 작은 배포 단위**입니다. Pod는 하나 이상의 컨테이너 그룹을 감싸는 '껍질'과 같습니다.
* **비유:** **콩깍지(Pod)**. 콩깍지(`Pod`) 안에 콩(`컨테이너`)이 들어있습니다. 대부분의 경우, 콩깍지 안에는 우리 애플리케이션 컨테이너라는 콩이 **하나**만 들어있습니다. 하지만 로그를 수집하는 '사이드카(Sidecar)' 컨테이너처럼, 주된 컨테이너와 매우 밀접하게 협력해야 하는 보조 컨테이너를 같은 콩깍지 안에 함께 넣어 실행할 수도 있습니다.
* **왜 필요한가? (Why):** Pod는 컨테이너들에게 **'공유 환경'**을 제공합니다. 같은 Pod 안의 컨테이너들은 **동일한 네트워크 공간(IP 주소, 포트)과 스토리지 볼륨을 공유**할 수 있어, `localhost`를 통해 서로 통신할 수 있습니다. 하지만 우리는 보통 Pod를 직접 생성하지 않고, 아래의 `Deployment`를 통해 관리합니다.

---

### 2. Deployment (디플로이먼트): 자가 치유와 스케일링의 관리자 📠

* **정의:** 동일한 Pod들의 집합(ReplicaSet)을 관리하는 상위 오브젝트입니다.
* **비유:** **"복사기와 감독관"**. 우리는 Deployment에게 "이 Pod 설계도(Template)를 가지고, **복사본(Replica) 3개**를 항상 유지해 줘"라고 선언합니다.
* **왜 필요한가? (Why):** Deployment는 마이크로서비스의 **생명주기(Lifecycle)**를 관리합니다.
    * **자가 치유 (Self-healing):** 실행 중이던 Pod 하나가 장애로 죽으면, Deployment는 즉시 이를 감지하고 '원하는 상태(3개)'를 맞추기 위해 새로운 Pod를 자동으로 생성합니다.
    * **스케일링 (Scaling):** 트래픽이 몰릴 때, Deployment의 `replicas` 숫자를 `3`에서 `10`으로 바꾸기만 하면, 쿠버네티스가 알아서 Pod 7개를 추가로 생성해 줍니다.
    * **롤링 업데이트 (Rolling Update):** 애플리케이션의 버전을 `v1`에서 `v2`로 업데이트할 때, Deployment는 `v1` Pod를 하나씩 점진적으로 종료시키면서 `v2` Pod를 생성하여, **서비스 중단 없이(Zero-downtime)** 배포를 수행합니다.

---

### 3. Service (서비스): 안정적인 네트워크 진입점 ☎️

* **정의:** Deployment가 관리하는 여러 Pod들에 대한 **'안정적인 단일 진입점(Endpoint)'**과 **로드 밸런서**를 제공하는 네트워크 오브젝트입니다.
* **문제점:** Pod는 언제든지 죽고 새로 생성될 수 있는 '일시적인(Ephemeral)' 존재입니다. Pod가 새로 생성될 때마다 매번 새로운 IP 주소를 할당받습니다. `API 게이트웨이`는 수시로 바뀌는 10개의 `product-service` Pod IP 주소를 어떻게 알 수 있을까요?
* **비유:** **"회사의 대표 전화번호"**. 우리는 상담원 개개인(`Pod`)의 직통 번호를 모릅니다. 그냥 회사의 대표 번호(`Service`)로 전화를 걸면, 시스템이 알아서 현재 통화 가능한 상담원에게 연결해 줍니다. 상담원이 퇴사하고 새로 들어와도, 회사의 대표 번호는 절대 바뀌지 않습니다.
* **왜 필요한가? (Why):** Service는 Pod들의 IP 주소가 계속 바뀌더라도, 변하지 않는 **고유한 내부 DNS 이름** (예: `product-service`)과 가상 IP를 부여합니다. 이제 `API 게이트웨이`는 더 이상 Pod들의 실제 IP를 알 필요 없이, `http://product-service`라는 안정적인 주소로만 통신하면, Service가 알아서 트래픽을 건강한 Pod들에게 분산시켜 줍니다.

---

### 4. ConfigMap (컨피그맵) & Secret (시크릿): 외부 주입 설정 📋✉️

* **정의:** 애플리케이션의 **설정 정보(ConfigMap)**와 **민감 정보(Secret)**를 컨테이너 이미지와 분리하여 저장하는 오브젝트입니다.
* **문제점:** DB 접속 주소나 비밀번호를 컨테이너 이미지 안에 구워 넣는(Baking in) 것은 매우 비효율적이고 위험합니다. 설정을 바꾸려면 이미지를 다시 빌드해야 하고, 누구나 이미지를 열어보면 비밀번호를 볼 수 있습니다.
* **비유:**
    * **ConfigMap:** 사무실의 **"공개 게시판"** 📋. 와이파이 비밀번호나 공용 프린터 주소처럼, 민감하지 않은 일반 설정 정보를 담습니다.
    * **Secret:** **"봉인된 비밀 서류"** ✉️. DB 비밀번호, API 키처럼 민감한 정보를 담습니다. 데이터는 Base64로 인코딩되어 저장되어, 우발적인 노출을 방지합니다.
* **왜 필요한가? (Why):** 설정과 코드를 완벽하게 분리합니다. `ConfigMap`과 `Secret`에 저장된 값들은 **환경 변수**나 **파일** 형태로 Pod에 실행 시점에 주입(Mount)될 수 있습니다. 이를 통해 이미지를 재빌드하지 않고도 설정을 변경할 수 있으며, 민감 정보를 안전하게 관리할 수 있습니다. (이는 `Spring Cloud Config Server`의 쿠버네티스 네이티브 버전이라고 볼 수 있습니다.)

이 5가지 핵심 오브젝트를 조합하여, 우리는 비로소 쿠버네티스 위에서 우리의 마이크로서비스들을 안정적이고, 탄력적이며, 자동화된 방식으로 운영할 수 있게 됩니다.