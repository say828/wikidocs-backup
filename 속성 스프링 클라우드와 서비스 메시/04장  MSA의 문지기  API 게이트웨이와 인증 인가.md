# 04장: MSA의 문지기: API 게이트웨이와 인증/인가

## 00. 왜 API 게이트웨이가 필수인가?: 단일 진입점(Single Point of Entry)의 중요성

03장 마지막에서, 우리는 모놀리스를 버리고 MSA로 전환을 결정했습니다. 하지만 이 결정은 즉시 새로운 '골치 아픈' 문제들을 야기합니다.

`회원(member-service)`, `상품(product-service)`, `주문(order-service)`이 각각 다른 포트(예: 8081, 8082, 8083)에서 독립적으로 실행된다고 가정해 봅시다.

1.  **클라이언트의 복잡성:** 모바일 앱(클라이언트) 개발자는 이제 `회원` 정보는 `api.ecommerce.com:8081`로, `상품` 정보는 `api.ecommerce.com:8082`로, `주문`은 `api.ecommerce.com:8083`으로 호출해야 합니다. 만약 `상품` 서비스가 트래픽 폭증으로 10대로 증설되면(Scale-out), 클라이언트는 이 10개의 주소를 모두 알고 로드 밸런싱까지 직접 해야 할까요? 이는 재앙입니다.

2.  **중복되는 '횡단 관심사' (Cross-Cutting Concerns):**
    * **인증/인가:** 사용자가 '상품 주문'을 합니다. `상품` 서비스도 이 사용자가 유효한지 JWT 토큰을 검사해야 하고, `주문` 서비스도 같은 토큰을 또 검사해야 합니다. 모든 마이크로서비스가 '인증'이라는 동일한 로직을 중복으로 구현해야 합니다.
    * **공통 로깅:** 모든 시스템에 들어오는 API 요청을 로깅하고 싶다면, 이 로깅 코드를 5개의 서비스에 모두 복사-붙여넣기 해야 합니다.
    * **CORS 및 보안:** CORS(Cross-Origin Resource Sharing) 설정, SSL/TLS 처리, IP 기반 접근 제한(Rate Limiting) 등을 모든 서비스가 개별적으로 처리해야 합니다.

이러한 문제들을 해결하지 못하면, 우리의 MSA는 '독립 배포'라는 장점은 얻을지 몰라도 '유지보수 지옥'이라는 더 큰 문제를 맞이하게 됩니다.

---

### 해답: API 게이트웨이, 단일 진입점

**API 게이트웨이(API Gateway)**는 이 모든 문제를 해결하는 '문지기(Gatekeeper)'입니다. [Image of an API Gateway architecture diagram]

이는 MSA 시스템의 **'유일한 정문(Single Point of Entry)'** 역할을 수행합니다. 마치 회사의 '안내 데스크'와 같습니다.

방문객(클라이언트)은 건물의 수백 개 사무실(마이크로서비스) 주소를 알 필요가 없습니다. 오직 '정문'의 주소만 알면 됩니다. 방문객이 정문에 도착하면, 안내 데스크(게이트웨이)가 방문객의 신원(인증)을 확인하고, 방문 목적(라우팅)에 맞는 사무실로 안내해 줍니다.

API 게이트웨이는 이 역할을 통해 두 가지 핵심 가치를 제공합니다.

#### 1. 라우팅 (Routing): 클라이언트 복잡성 제거

클라이언트는 오직 게이트웨이의 주소(예: `https://api.ecommerce.com`) 하나만 알고 있습니다.

* 클라이언트가 `GET /api/v1/members/1` (회원 조회)을 호출합니다.
* 게이트웨이는 이 요청을 받고, 자신의 '라우팅 테이블'을 확인합니다.
* `/api/v1/members/**` 경로는 `member-service` (내부 IP: 10.0.0.1:8081)로 가야 함을 인지하고 요청을 '대신 전달(Proxy)'해 줍니다.
* 클라이언트는 자신의 요청이 내부적으로 `member-service`로 갔는지 `product-service`로 갔는지 전혀 알 필요가 없습니다.

#### 2. 필터 (Filter): 횡단 관심사의 중앙 처리

게이트웨이는 '정문'이므로, 모든 요청이 통과하는 '검문소' 역할을 할 수 있습니다. 이 '검문' 기능이 바로 **필터(Filter)**입니다.

* **인증/인가 (Authentication/Authorization):**
    모든 요청이 게이트웨이를 통과할 때, 게이트웨이가 '딱 한 번'만 JWT 토큰을 검증합니다. (04장 03절)
    토큰이 유효하면, 게이트웨이는 `X-Member-Id: 123`과 같은 '신뢰할 수 있는' 헤더를 추가하여 내부 서비스로 요청을 전달합니다.
    이제 `product-service`나 `order-service`는 **토큰을 다시 검증할 필요 없이**, 이 헤더 값만 믿고 비즈니스 로직을 처리하면 됩니다.
* **공통 로깅 및 메트릭:** 게이트웨이에서 모든 요청/응답을 중앙에서 로깅하고, API별 호출 횟수나 응답 시간을 수집합니다.
* **보안 및 속도 제한:** 악의적인 IP의 접근을 차단하고, 특정 API에 대한 과도한 호출(Rate Limiting)을 막아 내부 시스템을 보호합니다.

---

결론적으로, API 게이트웨이는 MSA를 '운영 가능한' 시스템으로 만들어주는 **필수 컴포넌트**입니다.

이 장에서는 스프링 클라우드 생태계의 최신 리액티브 게이트웨이인 **`Spring Cloud Gateway`**를 코틀린으로 구축하여, 우리 이커머스 MSA의 '견고한 문지기'를 세울 것입니다.