## Micrometer Tracing(Sleuth)의 외부화: Istio가 생성하는 분산 트레이스 활용

19장에서 우리는 `Micrometer Tracing`과 `OpenTelemetry` SDK(또는 Java 에이전트)를 애플리케이션에 포함시켜 분산 추적을 구현했습니다. 이는 애플리케이션이 **스스로** Span을 생성하고, 컨텍스트를 전파하는 책임의 일부를 지는 방식이었습니다.

하지만 21장에서 배운 서비스 메시의 핵심 철학을 다시 생각해 봅시다.

> **"복잡한 네트워크 통신 관련 책임은 애플리케이션이 아닌 플랫폼(서비스 메시)으로 위임한다."**

분산 추적 역시 본질적으로는 '서비스 간 통신'을 관찰하는 기술입니다. 그렇다면 이 또한 플랫폼 레벨로 외부화할 수 있지 않을까요? 정답은 '그렇다'입니다.

---

### Istio의 투명한 추적 (Transparent Tracing)

우리의 모든 마이크로서비스 트래픽은 이미 Envoy 사이드카 프록시를 통과하고 있습니다. 즉, Envoy는 모든 요청의 시작과 끝을 알고 있으며, 어떤 서비스가 어떤 서비스를 호출하는지 완벽하게 파악하고 있습니다.

Istio는 이 점을 활용하여, **애플리케이션이 추적에 대해 전혀 알지 못하더라도** 분산 추적을 자동으로 생성하고 전파하는 강력한 기능을 제공합니다.

**동작 방식:**
1.  **Trace ID 생성:** 외부 요청이 `Istio Ingress Gateway`에 처음 도착했을 때, 게이트웨이의 Envoy 프록시는 `traceparent`와 같은 추적 헤더가 없으면 **새로운 Trace ID를 생성**합니다.
2.  **Span 생성 및 전파:**
    * 게이트웨이는 자신의 작업을 기록하는 **첫 번째 Span**을 생성합니다.
    * `order-service`로 요청을 보낼 때, 추적 컨텍스트(Trace ID, Span ID)를 HTTP 헤더에 담아 **자동으로 전파**합니다.
3.  **Trace 이어가기:**
    * `order-service`의 Envoy 사이드카는 이 헤더를 수신하고, 들어온 요청에 대한 **자식 Span**을 생성합니다.
    * 이 과정은 메시를 통과하는 모든 서비스 호출에 대해 반복됩니다.
4.  **데이터 전송:** 각 Envoy 프록시는 자신이 생성한 Span 데이터를 설정된 추적 백엔드(예: Jaeger)로 비동기적으로 전송합니다.

---

### 플랫폼 기반 추적의 장점

* **완벽한 투명성 및 언어 독립성:** 애플리케이션은 더 이상 `Micrometer Tracing` 같은 라이브러리에 의존할 필요가 없습니다. 추적은 **코드를 단 한 줄도 변경하지 않고** 플랫폼 레벨에서 '마법처럼' 일어납니다. 이는 서비스가 코틀린, 파이썬, Go 등 어떤 언어로 작성되었든 상관없이 **일관된 품질의 추적**을 보장합니다.
* **풍부한 네트워크 레벨 정보:** Envoy 프록시는 애플리케이션 레벨에서는 알기 어려운 풍부한 네트워크 정보를 Span의 속성(Attribute)으로 추가해 줍니다. (예: TLS 핸드셰이크 정보, TCP 레벨의 연결 실패 사유, 업스트림 클러스터 정보 등)

---

### "그래서 Micrometer Tracing은 이제 필요 없나요?" (하이브리드 접근법)

Istio가 모든 서비스 간의 호출(네트워크 홉)을 완벽하게 추적해 주지만, **서비스 '내부'에서 일어나는 일**은 알지 못합니다. Istio는 `OrderService`의 `createOrder` 메서드가 호출되었다는 것은 알지만, 그 안에서 `validateOrder` 메서드가 얼마나 걸렸고, `calculatePrice` 메서드가 얼마나 걸렸는지는 볼 수 없습니다.

따라서 최고의 실무 환경에서 권장되는 가장 이상적인 접근 방식은 **하이브리드(Hybrid) 모델**입니다.

1.  **Istio (플랫폼): 서비스 간의 '굵직한' 상위 Span들을 담당한다.**
    * Istio/Envoy가 모든 HTTP 요청/응답에 대한 서버 측 Span을 생성하고, 서비스 간에 Trace 컨텍스트를 안정적으로 전파하는 책임을 집니다.

2.  **Micrometer Tracing (애플리케이션): 서비스 '내부'의 세분화된 자식 Span들을 담당한다.**
    * 애플리케이션 내부의 OTel SDK는 Istio의 Envoy 프록시가 전파해 준 Trace 컨텍스트를 **자동으로 이어받습니다.**
    * 개발자는 이 컨텍스트 하에서, "DB 쿼리", "외부 PG 호출", "가격 계산 로직"과 같이 비즈니스적으로 중요한 특정 내부 메서드에 대해서만 **추가적인 자식 Span**을 수동 또는 자동으로 생성하여 Trace에 풍부한 세부 정보를 더합니다.



**결과:** Jaeger UI에서 트레이스를 조회하면, Istio가 생성한 `HTTP Ingress` Span 아래에, 우리 애플리케이션의 `Micrometer Tracing`이 생성한 `DB Query` Span이 자식으로 아름답게 중첩되어 표시됩니다. 이를 통해 우리는 거시적인 서비스 간 병목뿐만 아니라, 미시적인 코드 레벨의 병목까지 한 번에 파악할 수 있게 됩니다.

**결론적으로,** `Micrometer Tracing`을 Istio로 '대체'하는 것이 아니라, 두 가지를 **'함께'** 사용하여 각자의 장점을 극대화하는 것이 가장 현명한 전략입니다. Istio가 안정적인 추적의 '뼈대'를 제공하면, 애플리케이션은 그 위에 비즈니스 컨텍스트라는 '살'을 붙여 관찰 가능성을 완성합니다.