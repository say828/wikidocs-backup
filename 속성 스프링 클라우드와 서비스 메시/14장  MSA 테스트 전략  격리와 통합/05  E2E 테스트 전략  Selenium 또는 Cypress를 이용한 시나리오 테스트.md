## E2E 테스트 전략: Selenium 또는 Cypress를 이용한 시나리오 테스트

테스트 피라미드의 가장 꼭대기에는 **E2E(End-to-End, 종단간) 테스트**가 위치합니다. E2E 테스트는 개별 서비스나 컴포넌트가 아닌, **완전히 배포된 전체 시스템**을 사용자의 관점에서 검증합니다.

E2E 테스트는 실제 사용자가 브라우저를 통해 우리 이커머스 사이트에 접속하여 로그인하고, 상품을 검색하고, 장바구니에 담아 주문을 완료하는 것과 같은 **핵심 비즈니스 시나리오**가 처음부터 끝까지 올바르게 동작하는지를 확인하는 최종 '건강 검진'과 같습니다.

-----

### E2E 테스트의 위치와 트레이드오프

테스트 피라미드의 꼭대기에 있다는 것은, E2E 테스트가 다음과 같은 특징을 가짐을 의미합니다.

  * **가장 느림:** 실제 브라우저를 실행하고, 여러 마이크로서비스 간의 실제 네트워크 통신을 거치므로 테스트 하나를 실행하는 데 수십 초에서 수 분이 걸릴 수 있습니다.
  * **가장 불안정함 (Flaky):** 코드의 버그가 아닌, 일시적인 네트워크 지연이나 특정 UI 요소의 로딩 속도 저하 등 외부 요인으로 인해 테스트가 실패할 확률이 높습니다.
  * **가장 비쌈:** 테스트를 실행하기 위해 스테이징(Staging)과 같이 실제 운영 환경과 거의 동일하게 모든 서비스와 인프라가 배포된 별도의 '완전한 환경'이 필요합니다.

따라서, E2E 테스트는 \*\*"모든 엣지 케이스를 검증"\*\*하기 위해 사용하는 것이 아닙니다. 모든 엣지 케이스는 빠르고 안정적인 단위/통합 테스트에서 다루어야 합니다. E2E 테스트는 오직 시스템의 **가장 중요하고 치명적인 핵심 기능(Critical Path) 몇 가지**가 올바르게 통합되어 있는지만을 확인하는 **'스모크 테스트(Smoke Test)'** 용도로 제한적으로 사용해야 합니다.

-----

### 테스트 도구: Selenium vs. Cypress

E2E 테스트를 자동화하는 대표적인 도구는 `Selenium`과 `Cypress`입니다.

  * **Selenium:** 오랫동안 업계 표준으로 사용되어 온 강력한 브라우저 자동화 도구입니다. Java, Python 등 다양한 언어를 지원하고 모든 브라우저에서 테스트할 수 있는 장점이 있지만, 초기 설정이 다소 복잡할 수 있습니다.
  * **Cypress:** 최근 각광받고 있는 JavaScript 기반의 현대적인 E2E 테스트 프레임워크입니다. 테스트 코드를 작성하면서 실제 브라우저에서 실행되는 과정을 실시간으로 보여주는 등 개발자 경험이 매우 뛰어나고, 테스트의 불안정성(Flakiness)을 줄여주는 여러 기능을 내장하고 있어 더 빠르고 안정적인 테스트 작성이 가능합니다.

이 책에서는 현대적인 개발 환경에 더 적합한 **Cypress**를 기준으로 설명하겠습니다.

-----

### 실전 예제: "사용자의 상품 구매" 시나리오 테스트

우리 이커머스 시스템에서 가장 중요한 E2E 시나리오는 바로 '사용자의 상품 구매' 흐름입니다.

1.  사용자가 사이트에 접속한다.
2.  로그인한다. (`API 게이트웨이` -\> `member-service`)
3.  '티셔츠'를 검색한다. (`API 게이트웨이` -\> `product-service`)
4.  상품을 장바구니에 담고 주문 페이지로 이동한다.
5.  주문을 완료한다. (`API 게이트웨이` -\> `order-service` -\> SAGA 시작)
6.  "주문이 성공적으로 완료되었습니다" 메시지를 확인한다.

#### Cypress 테스트 코드 예시 (개념)

Cypress 테스트 코드는 다음과 같이 사용자의 행동을 그대로 서술하는 것처럼 작성됩니다.

```javascript
// cypress/integration/purchase_spec.js

describe('상품 구매 시나리오 E2E 테스트', () => {
    it('로그인 후, 상품을 검색하여 성공적으로 주문할 수 있어야 한다', () => {
        // 1. 사이트 방문
        cy.visit('https://ecommerce.test.com');

        // 2. 로그인
        cy.get('[data-cy=login-button]').click();
        cy.get('[data-cy=email-input]').type('test@email.com');
        cy.get('[data-cy=password-input]').type('password123');
        cy.get('[data-cy=submit-login]').click();

        // 3. 상품 검색
        cy.get('[data-cy=search-box]').type('코틀린 티셔츠{enter}');

        // 4. 상품 선택 및 주문
        cy.contains('코틀린으로 만든 멋진 티셔츠').click();
        cy.get('[data-cy=add-to-cart-button]').click();
        cy.get('[data-cy=checkout-button]').click();

        // (실제 외부 PG사와 연동할 수 없으므로, 결제 API 요청을 가로채서(intercept)
        // 성공한 것처럼 Stubbing 하는 로직이 필요)
        cy.intercept('POST', '/api/payments/process', { statusCode: 200 }).as('processPayment');

        cy.get('[data-cy=place-order-button]').click();

        // 5. 최종 결과 확인
        cy.contains('주문이 성공적으로 완료되었습니다').should('be.visible');
    });
});
```

이 E2E 테스트는 CI/CD 파이프라인의 가장 마지막 단계(예: Staging 환경 배포 후)에서 실행되어, 새로 변경된 코드가 기존의 핵심 비즈니스 흐름을 망가뜨리지 않았음을 최종적으로 보증하는 **'품질 보증 게이트'** 역할을 수행합니다.

이것으로 14장을 마칩니다. 우리는 테스트 피라미드의 모든 계층 - **단위 테스트**로 로직의 정확성을, **통합 및 계약 테스트**로 서비스 연동의 신뢰성을, 그리고 **E2E 테스트**로 전체 시스템의 무결성을 확보하는 다층적 테스트 전략을 완성했습니다. 이제 우리는 이 복잡한 MSA를 자신감 있게 개발하고 배포할 준비가 되었습니다.