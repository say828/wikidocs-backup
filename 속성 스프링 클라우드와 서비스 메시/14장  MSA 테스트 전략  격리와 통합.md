# 14장: MSA 테스트 전략: 격리와 통합

## 00. MSA 테스트의 어려움: 불확실성과 복잡성

지금까지 우리는 `코틀린`과 `스프링 클라우드`, `카프카` 등을 이용해 여러 마이크로서비스를 유기적으로 연결했습니다. 하지만 이 복잡하게 얽힌 분산 시스템이 정말 우리가 의도한 대로 동작하는지, 그리고 새로운 기능을 추가했을 때 기존 기능이 망가지지 않는다는 것을 어떻게 보장할 수 있을까요?

그 해답은 '견고한 테스트 전략'에 있습니다.

모놀리스 아키텍처의 테스트는 비교적 단순했습니다. 하나의 애플리케이션과 하나의 데이터베이스만 실행하면, 시스템의 모든 흐름을 처음부터 끝까지 테스트(End-to-End Test)하는 것이 가능했습니다.

하지만 마이크로서비스 아키텍처(MSA) 환경에서 테스트는 완전히 다른 차원의 문제가 됩니다.

---

### MSA 테스트가 어려운 이유

#### 1. 서비스 의존성 (Dependencies)

`order-service`의 '주문 생성' 기능을 테스트한다고 상상해 봅시다. 이 기능은 `product-service`(재고 확인)와 `payment-service`(결제)를 동기식으로 호출합니다.

> **"하나의 서비스를 테스트하기 위해, 그 서비스가 의존하는 다른 모든 서비스를 함께 실행해야 하는가?"**

만약 그렇다면, CI/CD 파이프라인은 끔찍하게 복잡해집니다. `order-service`의 코드는 완벽한데, 단지 `product-service`의 빌드가 실패했다는 이유만으로 `order-service`의 테스트 파이프라인 전체가 실패하게 됩니다. 이는 MSA의 핵심인 **'팀의 자율성'과 '독립적인 배포'를 저해**하는 요소입니다.

#### 2. 데이터 관리의 복잡성

각 서비스는 자신만의 데이터베이스를 가집니다. 테스트를 실행하기 전에 `orders` DB, `products` DB, `members` DB에 각각 일관성 있는 테스트 데이터를 어떻게 준비해야 할까요? 테스트가 끝난 후에는 이 모든 데이터를 어떻게 깔끔하게 정리(Clean-up)할 수 있을까요? 분산된 데이터의 정합성을 맞추는 것은 매우 어려운 문제입니다.

#### 3. 비동기 통신의 불확실성

10장에서 구현한 SAGA 패턴은 어떻게 테스트해야 할까요? `order-service`가 `OrderPaidEvent`를 Kafka로 발행했을 때, 우리의 테스트 코드는 `shipping-service`가 **'결국에는(eventually)'** 이 이벤트를 성공적으로 처리했다는 것을 어떻게 확인할 수 있을까요? 비동기 흐름은 테스트에 **타이밍 이슈**와 **비결정성(Non-determinism)**을 도입하여 테스트 코드를 불안정하게 만듭니다.

#### 4. 환경의 이질성

실제 운영 환경은 우리의 마이크로서비스뿐만 아니라, `API 게이트웨이`, `서비스 디스커버리(Consul)`, `메시지 브로커(Kafka)`, `분산 캐시(Redis)` 등 수많은 인프라 컴포넌트가 함께 동작하는 복잡한 네트워크 환경입니다. 개발자의 로컬 환경에서 수행하는 테스트가, 이 모든 복잡성을 완벽하게 재현하는 것은 불가능합니다. 이는 "제 PC에서는 됐는데요" 문제의 근본적인 원인이 됩니다.

---

### 해답: 테스트 피라미드 전략

[Image of the Testing Pyramid]

이러한 복잡성을 관리하기 위해, 우리는 **'테스트 피라미드(Test Pyramid)'** 전략을 따라야 합니다. 이 전략은 빠르고 안정적인 테스트는 많이 작성하고, 느리고 불안정한 테스트는 적게 작성하여, 테스트의 '비용'과 '가치' 사이의 균형을 맞추는 것을 목표로 합니다.

* **단위 테스트 (Unit Tests) - (넓은 기반):**
    가장 빠르고, 가장 안정적이며, 가장 많이 작성해야 하는 테스트입니다. 외부 의존성(DB, 네트워크)을 모두 Mocking하여 오직 클래스나 함수 하나의 논리만 검증합니다. (03장에서 `Kotest`와 `MockK`로 이미 경험했습니다.)

* **통합 테스트 (Integration Tests) - (중간 계층):**
    서비스가 자신의 직접적인 외부 의존성(예: 자신의 DB, Kafka)과 올바르게 연동되는지를 검증합니다. 단위 테스트보다 느리지만, 실제 환경과 유사한 검증을 제공합니다.

* **계약 테스트 (Contract Tests):**
    MSA 환경에서 특히 중요한 테스트입니다. 서비스 간의 API '계약(Contract)'이 깨지지 않았는지를, 상대방 서비스를 직접 실행하지 않고도 검증할 수 있게 해줍니다.

* **E2E (End-to-End) 테스트 - (좁은 최상층):**
    배포된 전체 시스템을 대상으로, 사용자의 시나리오(예: '로그인' -> '상품 검색' -> '주문')를 시뮬레이션합니다. 가장 확실한 검증을 제공하지만, 매우 느리고, 불안정하며, 작성 및 유지보수 비용이 가장 비쌉니다. 따라서 최소한으로, 가장 핵심적인 시나리오에 대해서만 수행해야 합니다.

이 장에서는 이 테스트 피라미드 전략에 따라, MSA 환경에 적합한 각종 테스트를 `Kotest`와 `Testcontainers`, `Spring Cloud Contract` 같은 현대적인 도구를 사용하여 구현하는 실용적인 방법을 탐구할 것입니다.