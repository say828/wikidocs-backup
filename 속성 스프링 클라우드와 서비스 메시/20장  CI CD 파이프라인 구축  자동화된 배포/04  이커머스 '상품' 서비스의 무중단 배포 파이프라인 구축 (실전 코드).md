## 이커머스 '상품' 서비스의 무중단 배포 파이프라인 구축 (실전 코드)

지금까지 CI/CD, 배포 전략, GitOps의 모든 이론을 배웠습니다. 이제 이 모든 것을 하나로 엮어, 우리 `product-service`를 위한 완전 자동화된 \*\*'코드 커밋부터 프로덕션 배포까지'\*\*의 무중단 배포 파이프라인을 **GitHub Actions**와 **ArgoCD**를 이용해 구축해 보겠습니다.

-----

### 파이프라인 아키텍처: 2개의 Git 저장소

우리의 GitOps 파이프라인은 두 개의 분리된 Git 저장소를 중심으로 동작합니다.

1.  **애플리케이션 저장소 (`ecommerce-product-service`):**
      * `product-service`의 스프링 부트 소스 코드가 들어있습니다.
      * CI(빌드, 테스트, 이미지 생성) 파이프라인이 여기서 실행됩니다.
2.  **Manifest 저장소 (`ecommerce-k8s-manifests`):**
      * 우리 이커머스 시스템의 모든 마이크로서비스에 대한 Helm 차트와 `values.yaml` 파일들이 들어있습니다.
      * 이 저장소가 우리 쿠버네티스 클러스터 상태의 \*\*유일한 진실의 원천(Single Source of Truth)\*\*이 됩니다. ArgoCD가 이 저장소를 감시합니다.

-----

### 1단계: CI 파이프라인 - 빌드, 테스트, 이미지 푸시, Manifest 업데이트

`ecommerce-product-service` 저장소의 `.github/workflows/ci-cd.yml` 파일을 작성합니다. 이 파이프라인은 `main` 브랜치에 코드가 푸시될 때 실행됩니다.

```yaml
# ecommerce-product-service/.github/workflows/ci-cd.yml
name: Product Service CI/CD

on:
  push:
    branches: [ "main" ]

env:
  # 사용할 이미지 이름 정의
  IMAGE_NAME: ${{ secrets.DOCKER_USERNAME }}/ecommerce-product-service

jobs:
  # --- JOB 1: 빌드 및 테스트 ---
  build-and-test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: '17'
          distribution: 'temurin'
      - name: Grant execute permission for gradlew
        run: chmod +x ./gradlew
      - name: Build with Gradle
        run: ./gradlew build

  # --- JOB 2: 컨테이너 이미지 빌드 및 푸시 ---
  build-and-push:
    needs: build-and-test # build-and-test Job이 성공해야 실행
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}
      - name: Build and push with Spring Boot Buildpacks
        # Git 커밋 해시를 이미지 태그로 사용하여 고유성 보장
        run: ./gradlew bootBuildImage --imageName=${{ env.IMAGE_NAME }}:${{ github.sha }}

  # --- JOB 3: Manifest 저장소 업데이트 (GitOps 트리거) ---
  update-manifest:
    needs: build-and-push # build-and-push Job이 성공해야 실행
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Manifest Repository
        # 1. Personal Access Token(PAT)을 이용하여 Manifest 저장소에 접근
        uses: actions/checkout@v4
        with:
          repository: my-github-org/ecommerce-k8s-manifests
          token: ${{ secrets.MANIFEST_REPO_PAT }}
      
      - name: Update Image Tag in Helm Chart
        # 2. Helm 차트의 values.yaml 파일에서 이미지 태그를 방금 푸시한 버전으로 변경
        #    'yq'는 YAML 파일을 CLI에서 수정하는 유틸리티
        run: |
          # Git 사용자 설정
          git config user.name "GitHub Actions"
          git config user.email "actions@github.com"
          
          # yq를 사용하여 이미지 태그 업데이트
          yq e '.image.tag = "${{ github.sha }}"' -i ./charts/product-service/values.yaml
          
          # 변경 사항 커밋 및 푸시
          git commit -am "Update product-service image to ${{ github.sha }}"
          git push
```

  * **`secrets`**: `DOCKER_USERNAME`, `DOCKER_PASSWORD`, `MANIFEST_REPO_PAT`는 GitHub 저장소의 `Settings > Secrets and variables > Actions`에 안전하게 저장해야 하는 비밀값입니다.

-----

### 2단계: CD - ArgoCD의 자동 감지 및 배포

이제 CI 파이프라인의 역할은 끝났습니다. 나머지는 쿠버네티스 클러스터에서 실행 중인 **ArgoCD**가 알아서 처리합니다.

1.  **ArgoCD 설정 (사전 작업):**
    ArgoCD UI 또는 YAML을 통해, `product-service`를 위한 'Application'을 미리 생성해 둡니다. 이 Application은 다음 정보를 담고 있습니다.

      * **Source:** `https://github.com/my-github-org/ecommerce-k8s-manifests.git`
      * **Path:** `./charts/product-service`
      * **Destination Cluster:** `https://kubernetes.default.svc`
      * **Sync Policy:** `Automated` (자동 동기화 활성화)

2.  **전체 자동화 흐름:**

    1.  개발자가 `product-service`의 `main` 브랜치에 코드를 푸시합니다.
    2.  **[CI]** GitHub Actions가 실행되어, 테스트를 통과하고 `ecommerce/product-service:<git-sha>` 이미지를 Docker Hub에 푸시합니다.
    3.  **[CI]** GitHub Actions가 `ecommerce-k8s-manifests` 저장소의 `values.yaml` 파일에 있는 이미지 태그를 `<git-sha>`로 변경하고 커밋/푸시합니다.
    4.  **[CD]** ArgoCD가 Manifest 저장소의 변경을 **수 초 내에 감지**합니다.
    5.  ArgoCD는 클러스터의 현재 상태(예전 이미지 태그)와 Git의 원하는 상태(새로운 이미지 태그)가 다름을 인지하고 **'Out of Sync'** 상태가 됩니다.
    6.  자동 동기화 설정에 따라, ArgoCD는 즉시 `helm upgrade`에 해당하는 작업을 클러스터에 실행합니다.
    7.  **[K8s]** 쿠버네티스는 `product-service` Deployment의 **롤링 업데이트**를 수행하여, 서비스 중단 없이 새로운 버전의 Pod로 교체합니다.

이것으로 20장을 마칩니다. 우리는 **Push 기반의 CI**와 \*\*Pull 기반의 GitOps(CD)\*\*를 결합하여, '코드 커밋'에서 '프로덕션 배포'까지 이어지는 안전하고 완전 자동화된 파이프라인을 구축했습니다. 이는 개발팀이 비즈니스 로직 개발에만 집중하면서도, 빠르고 안정적으로 서비스를 고객에게 전달할 수 있게 하는 현대적인 MSA 개발 워크플로우의 핵심입니다.