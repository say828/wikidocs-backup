# 01장: 백엔드 개발자를 위한 코틀린 핵심: 무엇이 다른가?

## 00. 코틀린이 스프링 부트와 만났을 때의 시너지 (Why)

00장에서 우리는 왜 코틀린이 자바보다 '생산성'과 '안정성' 면에서 나은 선택인지 간단히 살펴보았습니다. 1장에서는 이 장점들이 실제 스프링 부트(Spring Boot) 개발 현장에서 어떻게 강력한 '시너지'를 발휘하는지 집중적으로 탐구합니다.

많은 개발자가 코틀린을 '더 예쁜 자바(A prettier Java)' 정도로 오해하지만, 코틀린은 단순히 문법이 간결한 언어가 아닙니다. 코틀린은 **함수형 프로그래밍(Functional Programming)**의 장점과 **객체 지향 프로그래밍(Object-Oriented Programming)**의 실용성을 매우 우아하게 결합한 언어입니다.

스프링 프레임워크는 버전 5(Spring Framework 5)부터 코틀린을 1순위(First-class) 언어로 받아들였습니다. 이는 스프링의 핵심 철학이 코틀린의 설계 철학과 완벽하게 맞아떨어졌기 때문입니다.

### 1. 불변성(Immutability) 중심 설계

스프링의 핵심 원칙 중 하나는 '상태가 없는(Stateless)' 빈(Bean)을 통한 동시성 관리입니다. 코틀린은 `val`(읽기 전용)과 `data class`를 통해 **불변 객체(Immutable Object)**를 만드는 것을 기본으로 권장합니다. 이는 여러 스레드가 동시에 접근해도 안전한(Thread-safe) 컴포넌트를 설계하도록 자연스럽게 유도하며, 복잡한 MSA 환경에서 예측 가능하고 안정적인 서비스를 만드는 기반이 됩니다.

### 2. Null 안정성을 통한 '방어적 프로그래밍'의 내재화

스프링으로 개발할 때 우리는 `@Autowired`나 `@RequestParam` 등이 `null`이 아닐 것이라 '가정'하고 코드를 작성합니다. 하지만 자바에서는 언제 어디서 `NullPointerException`이 발생할지 모릅니다. 코틀린의 Null 안정성(`?`)은 이 '가정'을 '컴파일 시점의 보증'으로 바꿔줍니다. 이는 개발자가 `if (obj != null)` 같은 방어적 코드를 덕지덕지 붙이지 않아도, 시스템이 런타임에 안정적으로 동작할 것을 보장해 줍니다.

### 3. 확장 함수(Extension Functions)를 통한 '관심사의 분리'

스프링을 사용하다 보면 비즈니스 로직과 프레임워크 로직이 뒤섞이기 쉽습니다. 예를 들어, `Order`라는 순수한 도메인 객체가 DTO로 변환되기 위해 스프링에 의존적인 코드를 포함하게 될 수 있습니다. 코틀린의 '확장 함수'를 사용하면, 원본 `Order` 클래스를 수정하지 않고도 `Order.toDto()` 같은 변환 로직을 외부 파일에 깔끔하게 분리해낼 수 있습니다. 이는 **도메인 모델의 순수성**을 지키는 강력한 도구입니다.

### 4. 코루틴(Coroutines)을 통한 비동기/논블로킹의 단순화

스프링의 차세대 리액티브 스택인 `WebFlux`는 강력하지만 `Mono`와 `Flux`라는 새로운 프로그래밍 모델을 학습해야 하는 진입 장벽이 있습니다. 하지만 스프링은 코틀린 `코루틴`을 완벽하게 지원합니다. 덕분에 우리는 `Mono`나 `Flux` 없이, `suspend` 키워드 하나만으로 기존의 동기식 스프링 MVC 코드와 거의 동일한 구조를 유지하면서도 논블로킹(Non-blocking)의 성능을 달성할 수 있습니다. (12장에서 자세히 다룹니다.)

이번 장에서는 이 강력한 시너지를 만드는 코틀린의 핵심 기능들을 '스프링 부트와 이커머스 도메인'이라는 맥락 안에서 하나씩 정복해 나갈 것입니다.