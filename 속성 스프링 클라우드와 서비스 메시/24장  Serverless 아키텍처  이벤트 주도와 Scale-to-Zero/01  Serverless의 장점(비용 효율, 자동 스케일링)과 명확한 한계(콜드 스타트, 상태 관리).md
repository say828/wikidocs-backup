## Serverless의 장점(비용 효율, 자동 스케일링)과 명확한 한계(콜드 스타트, 상태 관리)

서버리스(Serverless)는 특정 유형의 워크로드에 엄청난 이점을 제공하지만, 모든 문제를 해결하는 '만능 열쇠(Silver Bullet)'는 아닙니다. 최고의 실무자는 그 장점과 함께 명확한 한계와 트레이드오프를 이해하고, 기술을 적재적소에 사용해야 합니다.

---

### ## 서버리스의 장점 ✅

#### 1. 압도적인 비용 효율성 (Pay-per-use)

이것이 서버리스를 채택하는 가장 큰 이유입니다. 전통적인 서버(Kubernetes Pod 포함)는 트래픽이 없어도 24시간 실행되며 고정 비용을 발생시킵니다. 하지만 서버리스는 **호출이 있을 때만 실행되고, 정확히 실행된 시간(보통 100ms 단위)만큼만 비용을 지불**합니다.

`Scale-to-Zero`가 가능하기 때문에, 하루에 몇 번만 실행되는 기능이나, 특정 이벤트(예: 월말 정산)에만 반응하는 기능의 경우, 서버를 계속 유지하는 것에 비해 비용을 99% 이상 절감할 수 있습니다.

#### 2. 무한에 가까운 자동 스케일링 (Automatic Scaling)

트래픽이 폭증했을 때, 우리는 더 이상 HPA의 `maxReplicas`를 걱정하거나 클러스터의 노드 개수를 신경 쓸 필요가 없습니다. 클라우드 제공업체가 모든 스케일링을 **자동으로, 그리고 거의 즉각적으로** 처리합니다.

1초에 1개의 요청이 들어오면 1개의 인스턴스가 실행되고, 바로 다음 초에 10,000개의 요청이 들어오면 **10,000개의 인스턴스가 동시에 병렬로 실행**됩니다. 이러한 극한의 탄력성은 예측 불가능한 트래픽 패턴에 대응하는 가장 이상적인 방법입니다.

#### 3. 운영 부담의 최소화 (Reduced Operational Overhead)

서버 OS 패치, 보안 업데이트, 쿠버네티스 버전 관리, 인프라 용량 계획 등 개발자를 괴롭히던 수많은 운영 업무가 사라집니다. 개발자는 오직 비즈니스 로직을 담은 '함수' 코드에만 집중할 수 있어, 제품 개발 속도가 빨라집니다.

---

### ## 서버리스의 명확한 한계 🚧

#### 1. 콜드 스타트 (Cold Start)

서버리스의 가장 잘 알려진 단점입니다. `Scale-to-Zero`의 이면에는 비용이 있습니다. 오랫동안 호출되지 않아 '얼어붙은(cold)' 함수가 처음으로 호출되면, 클라우드 플랫폼은 이 함수를 실행하기 위해 다음과 같은 준비 과정을 거쳐야 합니다.

1.  컨테이너 실행 환경 프로비저닝
2.  애플리케이션 코드 다운로드
3.  런타임(JVM 등) 시작
4.  애플리케이션 초기화 (Spring Context 로딩 등)

이 과정 때문에 첫 번째 요청에 대한 응답 시간이 수백 ms에서 **수 초까지** 지연될 수 있습니다. 특히 JVM 기반의 코틀린과 스프링 프레임워크는 런타임과 프레임워크 초기화 시간 때문에 이 콜드 스타트 문제가 더 두드러집니다.

'주문 생성'과 같이 사용자에게 즉각적인 응답이 필수적인 API에는 치명적일 수 있습니다. (물론 'Provisioned Concurrency'처럼 항상 일정 수의 인스턴스를 '웜업(warm-up)' 상태로 유지하는 옵션도 있지만, 이는 'Scale-to-Zero'의 비용 효율성을 일부 포기하는 것입니다.)

#### 2. 제한된 실행 환경

FaaS는 장시간 실행되는 무거운 작업을 위해 설계되지 않았습니다.
* **최대 실행 시간:** 대부분의 FaaS 플랫폼은 함수의 최대 실행 시간을 제한합니다. (예: AWS Lambda의 경우 최대 15분) 몇 시간씩 걸리는 동영상 인코딩이나 대규모 데이터 배치 작업에는 적합하지 않습니다.
* **자원 제약:** 할당할 수 있는 CPU와 메모리, 디스크 공간에 제한이 있습니다.

#### 3. 상태 관리의 어려움 (Stateless)

함수는 '상태 없음(Stateless)'을 전제로 합니다. 여러 호출에 걸쳐 데이터를 메모리에 유지하거나 로컬 파일 시스템에 저장할 수 없습니다. 모든 상태는 `DynamoDB`나 `Redis` 같은 외부 데이터 저장소에 저장해야 하며, 이는 추가적인 아키텍처 복잡성과 지연 시간을 유발할 수 있습니다.

#### 4. 벤더 종속성 (Vendor Lock-in)

애플리케이션 코드 자체는 이식성이 있을 수 있지만, 함수를 둘러싼 생태계(이벤트 트리거, IAM 보안 정책, 모니터링 및 배포 방식)는 **특정 클라우드 제공업체(AWS, Google, Azure)에 매우 강하게 종속**됩니다. AWS Lambda로 구축한 복잡한 서버리스 시스템을 Google Cloud Functions로 마이그레이션하는 것은 거의 새로 만드는 수준의 노력이 필요할 수 있습니다.

| 특징 | 장점 👍 | 단점 👎 |
| :--- | :--- | :--- |
| **비용** | 사용한 만큼만 지불, 유휴 비용 제로 | 지속적인 고트래픽에는 오히려 비쌀 수 있음 |
| **스케일링** | 완전 자동, 무한에 가까운 확장성 | 콜드 스타트로 인한 지연 시간 발생 |
| **운영** | 서버 관리 불필요, 개발 집중 | 벤더 종속성, 제한적인 제어 |
| **아키텍처** | 이벤트 주도, 비동기에 최적화 | 상태 관리 어려움, 실행 시간 제한 |

**결론적으로,** 서버리스는 **비동기적이고, 비정기적이며, 트래픽 예측이 어려운 이벤트 기반 워크로드**에 적용할 때 그 가치를 극대화할 수 있는 강력한 도구입니다. 하지만 사용자와의 실시간 상호작용이 중요한 API나, 장시간 실행되는 작업에는 쿠버네티스 기반의 컨테이너 방식이 여전히 더 나은 선택일 수 있습니다.