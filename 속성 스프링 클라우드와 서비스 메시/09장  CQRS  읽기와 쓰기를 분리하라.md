# 09장: CQRS: 읽기와 쓰기를 분리하라

## 00. 왜 읽기/쓰기 모델을 분리해야 하는가? (Why): 이커머스 '상품 상세' vs '재고 차감'

지금까지 우리 이커머스 시스템의 아키텍처는 대부분의 애플리케이션이 따르는 전통적인 **CRUD(Create, Read, Update, Delete)** 모델을 기반으로 합니다. 즉, '상품' 정보를 조회할 때 사용하는 `Product` 엔티티와 '상품 재고'를 수정할 때 사용하는 `Product` 엔티티가 동일한 클래스이자 동일한 DB 테이블입니다.

이 단일 모델 접근 방식은 단순하지만, 시스템이 성장함에 따라 심각한 한계에 부딪힙니다. 왜냐하면, **데이터를 읽는(Read) 작업과 쓰는(Write) 작업의 요구사항은 근본적으로 다르며, 종종 서로 충돌하기 때문**입니다.

우리 이커머스 시스템의 '상품' 도메인을 예로 들어 이 충돌을 살펴보겠습니다.

---

### "읽기" 요구사항: 상품 상세 페이지 조회 🖼️

* **워크로드 (Workload):** **압도적인 읽기 위주(Read-Heavy).** 인기 상품 하나는 1초에 수만 번 조회될 수 있지만, 정보가 수정되는 경우는 하루에 몇 번뿐입니다.
* **데이터 형태 (Data Shape):** **비정규화된(Denormalized) 통합 뷰(View)**가 필요합니다. 상품 상세 페이지는 `Product` 테이블의 `name`과 `description`만 보여주지 않습니다. `Category` 테이블의 카테고리 이름, `Brand` 테이블의 브랜드 정보, `Review` 테이블의 평균 별점과 개수, `Seller` 테이블의 판매자 정보 등을 **한 번에 모두** 보여줘야 합니다. 이를 위해 전통적인 모델에서는 수많은 테이블을 `JOIN`하는 복잡하고 느린 쿼리가 필요합니다.
* **일관성 (Consistency):** **약간의 데이터 지연을 허용**할 수 있습니다. 평균 별점이 3초 전에 갱신된 값이라고 해서 비즈니스에 문제가 생기지 않습니다 (최종 일관성, Eventual Consistency).
* **최적화 목표:** **속도와 가용성.** 페이지는 무조건 **빨리** 떠야 합니다.

### "쓰기" 요구사항: 상품 재고 차감  transactional-write 🛍️

* **워크로드 (Workload):** **쓰기 위주(Write-Heavy)이며, 높은 동시성 경합(High Contention)**이 발생합니다. '블랙 프라이데이' 세일이 시작되면, 수천 명의 사용자가 **동시에 동일한 상품의 `stockQuantity` 컬럼**을 수정하려고 달려듭니다.
* **데이터 형태 (Data Shape):** **정규화된(Normalized)** 모델이 필요합니다. 트랜잭션의 원자성과 데이터 무결성을 보장하기 위해, `Product` 엔티티는 오직 자신의 책임(상품 정보, 재고)에만 집중해야 합니다.
* **일관성 (Consistency):** **강력한 일관성(Strong Consistency)이 절대적으로 필수**입니다. 재고가 1개 남았는데 2명에게 동시에 팔리면 안 됩니다. 이를 위해 DB의 `Lock`과 `ACID` 트랜잭션이 반드시 필요합니다.
* **최적화 목표:** **데이터 무결성과 일관성.** 데이터는 무조건 **정확**해야 합니다.

---

### 단일 모델의 딜레마

이처럼 상반된 두 요구사항을 **하나의 모델, 하나의 DB 테이블**로 만족시키는 것은 거의 불가능합니다.

* 읽기 성능을 위해 테이블을 비정규화하면, 쓰기 작업 시 여러 곳에 중복된 데이터를 수정해야 해 정합성이 깨지기 쉽고 성능이 저하됩니다.
* 쓰기 일관성을 위해 테이블을 정규화하면, 읽기 작업 시 수많은 `JOIN`이 발생하여 성능이 저하됩니다.
* 폭발적인 읽기 트래픽이 DB 커넥션 풀을 모두 소진하여, 정작 가장 중요한 '재고 차감' 쓰기 트랜잭션이 지연되거나 실패할 수 있습니다.

### 해답: CQRS (Command Query Responsibility Segregation)

이 딜레마를 해결하기 위한 패턴이 바로 **CQRS (명령과 조회의 책임 분리)**입니다. CQRS의 아이디어는 놀랍도록 단순합니다.

> **"시스템의 상태를 변경하는 '명령(Command)' 모델과, 시스템의 상태를 조회하는 '조회(Query)' 모델을 명시적으로 분리하라."**



* **명령 (Command):** 시스템의 상태를 변경하려는 '의도'를 담은 객체입니다. (예: `DecreaseStockCommand`, `CreateOrderCommand`). 데이터를 반환하지 않는 것이 원칙입니다.
* **조회 (Query):** 시스템의 상태를 조회하기 위한 객체입니다. 절대 시스템의 상태를 변경하지 않습니다. (예: `GetProductDetailsQuery`)

이 단순한 분리를 통해, 우리는 이제 각 작업에 최적화된 모델, 심지어 최적화된 데이터베이스까지 독립적으로 사용할 수 있게 됩니다.

* **쓰기 모델 (Command Model):** RDBMS에 정규화된 모델을 사용하여 데이터 일관성을 보장합니다.
* **읽기 모델 (Query Model):** 검색 엔진(Elasticsearch)이나 NoSQL DB에 '상품 상세 페이지' 전용으로 모든 데이터가 미리 `JOIN`된 거대한 JSON 문서를 저장하여, 단 한 번의 I/O로 모든 데이터를 가져올 수 있습니다.

이 장에서는 이 CQRS 패턴을 적용하여, 우리 이커머스 시스템의 `주문`과 `상품` 도메인을 '명령'과 '조회' 모델로 분리하고, 이를 Kafka 이벤트와 결합하여 두 모델 간의 데이터를 동기화하는 방법을 구현할 것입니다.