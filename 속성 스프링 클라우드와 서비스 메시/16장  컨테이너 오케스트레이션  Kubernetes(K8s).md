# 16장: 컨테이너 오케스트레이션: Kubernetes(K8s)

## 00. 왜 Kubernetes인가?: 컨테이너 배포, 스케일링, 관리의 표준

15장에서 우리는 `Docker`를 통해 애플리케이션을 표준화된 '컨테이너'로 패키징했고, `Docker Compose`를 이용해 로컬 개발 환경에서 이 컨테이너들을 쉽게 실행할 수 있었습니다.

하지만 `Docker Compose`는 **단일 호스트(서버 한 대)** 환경을 위한 도구입니다. 실제 수만 명의 트래픽을 감당해야 하는 프로덕션(운영) 환경은 수십, 수백 대의 서버로 구성된 **클러스터(Cluster)**입니다. 이 거대한 클러스터 환경에서 `Docker Compose`는 다음과 같은 질문에 답하지 못합니다.

* 클러스터의 서버 한 대가 다운되면, 그 위에서 돌던 컨테이너들을 어떻게 **자동으로 다른 건강한 서버로 옮겨서 복구**할 수 있을까?
* 트래픽이 몰릴 때, `product-service` 컨테이너를 3대에서 10대로 **자동으로 늘리고(Auto-scaling)**, 이 10대를 여러 서버에 어떻게 효율적으로 분산시킬까?
* `order-service`의 새 버전을 배포할 때, **서비스 중단 없이(Zero-downtime)** 기존 버전을 새로운 버전으로 교체(Rolling Update)할 수 있을까?
* 클러스터 전체에 흩어져 있는 10대의 `product-service` 컨테이너들의 IP 주소를 어떻게 찾아서 `API 게이트웨이`가 트래픽을 분산(Load Balancing)시킬 수 있을까?

이 모든 문제를 해결하는 것이 바로 **'컨테이너 오케스트레이션(Container Orchestration)'** 기술이며, 오늘날 이 분야의 **압도적인 표준**이 바로 **쿠버네티스(Kubernetes, K8s)**입니다.

---

### 쿠버네티스: "클라우드를 위한 운영체제"

쿠버네티스는 원래 구글이 내부에서 사용하던 컨테이너 관리 시스템(Borg)을 오픈소스로 공개한 프로젝트입니다. 이제는 클라우드 네이티브 컴퓨팅 재단(CNCF)의 가장 중요한 프로젝트로서, '클라우드를 위한 운영체제'라고 불립니다.

**교향악단 지휘자 비유 🎼:**
* **Docker Compose:** 작은 방에서 연주하는 **실내악단(Chamber Orchestra)**의 지휘자입니다. (단일 호스트)
* **Kubernetes:** 수백 명의 연주자가 거대한 무대에 흩어져 있는 **대규모 교향악단(Symphony Orchestra)**의 지휘자입니다. (서버 클러스터)

지휘자는 각 바이올린 연주자가 어떤 의자에 앉을지 일일이 지정하지 않습니다. 대신 **"나는 16명의 바이올린 연주자가 이 파트를 연주하기를 원한다"**라고 **'선언'**할 뿐입니다. 그러면 오케스트라 시스템(쿠버네티스)이 알아서 16개의 빈 의자를 찾아 연주자를 배치하고, 연주자 한 명이 아파서 떠나면(서버 다운) 즉시 다른 연주자를 데려와 항상 16명을 유지합니다.

---

### 쿠버네티스의 핵심 철학: 선언적 API와 상태 관리

쿠버네티스의 가장 중요한 특징은 **'선언적(Declarative)'**으로 동작한다는 점입니다.

개발자나 운영자는 쿠버네티스에게 "A 서버에 컨테이너를 띄우고, B 서버와 C 서버로 트래픽을 보내라"와 같이 '어떻게(How)'를 지시하는 **'명령형(Imperative)'** 방식이 아닌,

> **"나는 `member-service:v1.0.1` 이미지를 사용하는 컨테이너가 항상 3개 떠 있는 '상태(State)'를 원한다."**

와 같이, **원하는 최종 상태(Desired State)**를 YAML 파일로 **'선언(Declare)'**합니다.

그러면 쿠버네티스의 컨트롤 플레인(Control Plane)은 **'조정 루프(Reconciliation Loop)'**를 끊임없이 돌면서, 클러스터의 **'현재 상태(Current State)'**와 사용자가 선언한 **'원하는 상태'**를 비교하여 그 차이를 없애려고 노력합니다.

* **현재 상태:** `member-service` 2개 실행 중 → **원하는 상태:** 3개 실행 → **조치:** 쿠버네티스가 컨테이너 1개를 추가로 생성.
* **현재 상태:** 서버 노드 다운으로 `member-service` 1개만 실행 중 → **원하는 상태:** 3개 실행 → **조치:** 쿠버네티스가 다른 건강한 노드에 컨테이너 2개를 추가로 생성.

이 메커니즘을 통해 쿠버네티스는 다음과 같은 강력한 기능들을 자동으로 제공합니다.

* **자가 치유 (Self-healing):** 장애가 발생한 컨테이너를 자동으로 재시작하거나, 문제가 생긴 서버(노드)에서 실행 중이던 컨테이너들을 건강한 노드로 자동 이전시킵니다.
* **오토스케일링 (Auto-scaling):** CPU 사용량이나 메모리 사용량에 따라 컨테이너의 개수를 자동으로 늘리거나 줄입니다.
* **서비스 디스커버리 및 로드 밸런싱:** 여러 개로 복제된 컨테이너들에 대한 단일 진입점(고유한 DNS 이름)을 제공하고, 그 사이의 트래픽을 분산시킵니다.
* **자동화된 롤아웃 및 롤백 (Automated Rollouts & Rollbacks):** 서비스 중단 없이 새로운 버전의 애플리케이션을 점진적으로 배포(롤링 업데이트)하고, 문제가 발생하면 이전 버전으로 자동으로 되돌릴(롤백) 수 있습니다.
* **설정 및 시크릿 관리:** 애플리케이션 설정이나 DB 접속 정보, API 키 같은 민감 정보를 안전하게 관리하고 컨테이너에 주입할 수 있습니다.

**결론적으로,** Docker가 우리 서비스를 '포장'하는 방법을 표준화했다면, 쿠버네티스는 이 포장된 서비스들을 거대한 서버 클러스터 위에서 '운영'하는 방법을 표준화합니다. 이 장에서는 쿠버네티스의 핵심 오브젝트(Pod, Deployment, Service)를 배우고, 우리의 이커머스 애플리케이션을 실제 쿠버네티스 클러스터에 배포하는 방법을 알아볼 것입니다.