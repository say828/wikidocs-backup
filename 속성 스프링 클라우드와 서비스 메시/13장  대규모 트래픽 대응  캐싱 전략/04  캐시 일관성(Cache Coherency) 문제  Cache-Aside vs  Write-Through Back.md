## 캐시 일관성(Cache Coherency) 문제: Cache-Aside vs. Write-Through/Back

13장 03절에서 우리는 `Redis`를 이용해 애플리케이션의 성능을 극적으로 향상시켰습니다. 하지만 캐시를 도입하는 순간, 우리는 모든 분산 시스템 엔지니어가 마주하는 가장 어려운 숙제와 씨름해야 합니다. 바로 **캐시 일관성(Cache Coherency)** 문제입니다.

**문제:** 원본 데이터베이스의 데이터가 변경되었는데, 캐시에는 여전히 예전 데이터(이를 **'오염된 데이터(Stale Data)'**라고 합니다)가 남아있다면 어떻게 될까요?

**시나리오:**
1.  `product-service`의 캐시에는 '특가 티셔츠'의 가격이 `10,000원`으로 저장되어 있습니다.
2.  운영자가 관리자 페이지에서 가격을 `9,000원`으로 변경합니다. 이 변경 사항은 **DB에만 반영**됩니다.
3.  사용자가 상품 상세 페이지를 조회합니다. 애플리케이션은 DB가 아닌 캐시를 먼저 조회하여, 사용자에게 **예전 가격인 `10,000원`**을 보여줍니다.

이러한 데이터 불일치는 고객의 신뢰를 잃게 만드는 심각한 버그입니다. 이 문제를 해결하기 위해, DB와 캐시 간의 데이터를 동기화하는 여러 전략(패턴)이 존재합니다.

---

### 1. Cache-Aside (Lazy Loading): "일단 캐시에서 찾아보고, 없으면 DB에서 가져와 채운다"

이 패턴은 우리가 13장 02절에서 `@Cacheable`을 통해 구현했던, **가장 널리 사용되는 일반적인 캐싱 전략**입니다.



* **읽기 (Read):**
    1.  애플리케이션은 **캐시**를 먼저 조회합니다.
    2.  **(Cache Hit):** 데이터가 있으면, 캐시의 데이터를 반환합니다. **(끝)**
    3.  **(Cache Miss):** 데이터가 없으면, **데이터베이스**를 조회합니다.
    4.  DB에서 가져온 데이터를 **캐시에 저장**합니다.
    5.  데이터를 반환합니다.

* **쓰기 (Write):**
    1.  애플리케이션은 **데이터베이스**에 먼저 데이터를 씁니다 (UPDATE 또는 DELETE).
    2.  그 후, **캐시에 있는 해당 데이터를 삭제(Invalidate)**합니다. **(절대 캐시를 업데이트하지 않습니다!)**

**왜 캐시를 업데이트하지 않고 삭제할까요?**
만약 쓰기 작업이 매우 빈번하게 일어나는 데이터라면, 캐시를 업데이트하는 비용이 DB를 조회하는 비용보다 더 커질 수 있습니다. 또한, 복잡한 연산을 통해 만들어진 캐시 데이터를 애플리케이션이 직접 재구성하는 것보다, 그냥 삭제하고 다음 읽기 요청 시 DB에서 다시 가져와 캐싱하는 것이 훨씬 간단하고 안전하기 때문입니다.

* **장점:**
    * 구현이 비교적 간단하고, `Spring Cache`의 `@Cacheable`, `@CacheEvict`로 쉽게 적용할 수 있습니다.
    * 실제로 사용되는 데이터만 캐시에 저장되므로, 캐시 메모리를 효율적으로 사용할 수 있습니다.
* **단점:**
    * 첫 번째 데이터 요청은 항상 Cache Miss가 발생하여 DB를 조회해야 하므로, 약간의 지연이 있습니다.
    * DB와 캐시 삭제 작업 사이에 아주 짧은 시간 동안 불일치 상태가 존재할 수 있습니다. (13장 05절에서 해결)

---

### 2. Write-Through: "쓸 때는 항상 DB와 캐시에 동시에 쓴다"

이 패턴은 데이터의 **쓰기 작업이 매우 중요하고, 캐시와 DB 간의 데이터 불일치를 최소화**하고 싶을 때 사용합니다.



* **읽기 (Read):** Cache-Aside와 동일합니다. 캐시에서 먼저 찾고 없으면 DB에서 가져옵니다.

* **쓰기 (Write):**
    1.  애플리케이션은 **캐시**에 먼저 데이터를 씁니다.
    2.  캐시 시스템이 **동기적으로(Synchronously)** 데이터베이스에 해당 데이터를 씁니다.
    3.  DB 쓰기까지 성공적으로 완료된 후에야, 애플리케이션에 쓰기 작업이 성공했음을 알립니다.

* **장점:**
    * 캐시와 DB의 데이터가 항상 일치하도록 보장됩니다. 애플리케이션 개발자는 DB에 대해 신경 쓸 필요 없이 캐시에만 데이터를 쓰면 됩니다.
* **단점:**
    * **쓰기 지연 시간(Latency)이 증가합니다.** 항상 캐시와 DB 두 곳에 모두 쓰기 작업이 완료되어야 응답을 받을 수 있으므로, 쓰기 성능이 저하됩니다.
    * 구현이 복잡합니다. `Spring Cache`는 이 패턴을 직접 지원하지 않으므로, 직접 구현해야 합니다.

---

### 3. Write-Back (Write-Behind): "일단 캐시에만 쓰고, 나중에 몰아서 DB에 쓴다"

Write-Back은 쓰기 성능을 극대화하기 위한 가장 복잡한 패턴입니다.

* **쓰기 (Write):**
    1.  애플리케이션은 모든 쓰기 작업을 **캐시에만** 수행하고 즉시 응답을 받습니다.
    2.  캐시 시스템은 변경된 데이터들을 특정 주기(예: 10초마다) 또는 특정 양(예: 100개씩) 모아서, **비동기적으로(Asynchronously)** 데이터베이스에 한꺼번에 기록합니다.

* **장점:**
    * **쓰기 성능이 가장 빠릅니다.** DB 쓰기를 기다리지 않으므로, 쓰기 작업이 거의 메모리 속도로 이루어집니다.
* **단점:**
    * **데이터 유실 위험이 가장 큽니다.** 데이터가 DB에 기록되기 전에 캐시 서버에 장애가 발생하면, 캐시에만 있던 변경된 데이터는 **영원히 유실**될 수 있습니다.
    * 구현 복잡도가 매우 높습니다.

---

### 우리의 선택: Cache-Aside를 기본으로

대부분의 웹 애플리케이션 시나리오, 특히 우리 이커머스 프로젝트의 '상품 상세 조회'와 같이 **읽기 작업이 쓰기 작업보다 압도적으로 많은 경우**, **Cache-Aside 패턴**이 가장 합리적이고 효과적인 선택입니다.

우리는 `Spring Cache`가 제공하는 `@Cacheable`과 `@CacheEvict`를 사용하여 Cache-Aside 패턴을 기본 전략으로 채택할 것입니다.

하지만 아직 해결되지 않은 문제가 남아있습니다. Cache-Aside 패턴에서 "DB 업데이트와 캐시 삭제 작업 사이"에 발생하는 미세한 데이터 불일치 문제를 어떻게 해결할까요? 그리고 관리자가 DB를 직접 수정했을 때, 캐시는 어떻게 그 변경을 알 수 있을까요?

다음 절에서는 이 '캐시 무효화' 문제를 해결하기 위한 고급 전략을 살펴보겠습니다.