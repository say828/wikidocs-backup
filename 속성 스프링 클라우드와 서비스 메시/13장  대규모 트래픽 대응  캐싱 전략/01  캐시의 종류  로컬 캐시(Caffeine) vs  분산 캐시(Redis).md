## 캐시의 종류: 로컬 캐시(Caffeine) vs. 분산 캐시(Redis)

"캐시를 사용하자"고 결정했다면, 다음 질문은 "그 캐시를 **어디에** 저장할 것인가?"입니다. 캐시의 저장 위치에 따라 아키텍처는 크게 **로컬 캐시**와 **분산 캐시**로 나뉩니다.

---

### 1. 로컬 캐시 (Local Cache)

* **개념:** 애플리케이션 **내부 메모리(JVM Heap)**에 데이터를 저장하는 방식입니다. 별도의 서버나 장비가 필요 없이, 라이브러리 형태로 애플리케이션 코드에 포함되어 동작합니다.
* **대표 기술:** **Caffeine** (과거 Google Guava Cache의 후속 버전으로, 현존 최고의 성능을 자랑하는 자바 로컬 캐시 라이브러리)
* **비유:** 자주 쓰는 전화번호를 컴퓨터 **모니터에 포스트잇으로 붙여놓는 것**과 같습니다.



#### 👍 장점

* **속도:** **가장 빠릅니다.** 네트워크 통신이 전혀 없이, 자신의 메모리에 있는 데이터를 직접 참조하므로 거의 지연 시간이 없습니다.

#### 👎 단점

* **데이터 불일치:** 이것이 MSA 환경에서 로컬 캐시를 사용하기 어려운 결정적인 이유입니다. `product-service`를 3대로 확장(Scale-out)했다고 가정해 봅시다.
    1.  사용자 A의 요청이 1번 서버로 가서 '상품 A' 정보를 캐시에 저장합니다.
    2.  잠시 후, 사용자 B의 요청이 로드 밸런서에 의해 2번 서버로 전달됩니다. 2번 서버의 로컬 캐시에는 '상품 A' 정보가 없으므로 DB를 다시 조회해야 합니다. (캐시 효율 저하)
    3.  더 심각한 것은, 관리자가 '상품 A'의 가격을 변경했을 때입니다. 이 변경 요청을 처리한 1번 서버는 자신의 로컬 캐시를 갱신했지만, 2번과 3번 서버의 캐시에는 **여전히 예전 가격 정보**가 남아있습니다. 사용자마다 다른 가격을 보게 되는 데이터 불일치가 발생합니다.
* **제한된 용량:** 애플리케이션의 JVM 힙 메모리를 공유하므로, 많은 데이터를 캐싱하면 애플리케이션의 GC(Garbage Collection)에 부담을 주어 성능을 저하시킬 수 있습니다.
* **데이터 영속성 부재:** 애플리케이션이 재시작되면, 로컬 캐시의 모든 데이터는 초기화됩니다.

---

### 2. 분산 캐시 (Distributed Cache)

* **개념:** 애플리케이션 외부의 **별도 서버(들)**에 캐시 전용 데이터베이스를 구축하는 방식입니다. 모든 애플리케이션 인스턴스는 이 '중앙 캐시 서버'에 네트워크를 통해 접속하여 데이터를 공유합니다.
* **대표 기술:** **Redis** (가장 널리 사용되는 인메모리 Key-Value 데이터 저장소)
* **비유:** 사무실 중앙에 있는 거대한 **공용 화이트보드**와 같습니다.



#### 👍 장점

* **데이터 일관성 및 공유:** 모든 애플리케이션 인스턴스가 **하나의 캐시 데이터**를 바라봅니다. 1번 서버가 캐시를 갱신하면, 2번, 3번 서버도 즉시 갱신된 데이터를 조회할 수 있습니다. MSA 환경에서 데이터 일관성을 보장합니다.
* **독립적인 확장 및 관리:** 캐시 서버는 애플리케이션 서버와 별개로, 독립적으로 확장하거나 관리할 수 있습니다.
* **유연성과 다양한 기능:** Redis의 경우, 단순 Key-Value 저장뿐만 아니라 Pub/Sub, 정렬된 집합(Sorted Set) 등 다양한 자료구조를 제공하여 캐싱 외의 용도로도 활용할 수 있습니다.

#### 👎 단점

* **네트워크 지연 시간:** 데이터를 조회할 때마다 네트워크 통신이 발생합니다. 물론 인메모리 기반이라 매우 빠르지만(보통 1ms 미만), 로컬 캐시의 메모리 직접 참조 속도보다는 느릴 수밖에 없습니다.
* **인프라 구축 및 관리 비용:** 캐시를 위한 별도의 서버를 구축하고, 고가용성을 위해 클러스터링하는 등의 관리 비용이 발생합니다.
* **단일 실패 지점 (SPOF):** 캐시 서버(클러스터) 자체가 다운되면, 모든 애플리케이션이 캐시를 사용하지 못하게 되어 DB에 부하가 몰리는 '캐시 스탬피드(Cache Stampede)' 현상이 발생할 수 있습니다.

---

### 최종 선택: 우리 MSA를 위한 선택은?

| 특징 | 로컬 캐시 (Caffeine) | 분산 캐시 (Redis) |
| :--- | :--- | :--- |
| **위치** | 애플리케이션 내부 (JVM 힙) | 외부 독립 서버 |
| **속도** | 가장 빠름 (네트워크 없음) | 매우 빠름 (네트워크 지연 포함) |
| **데이터 일관성** | 낮음 (인스턴스 간 불일치) | **높음 (모든 인스턴스가 공유)** |
| **적합 환경** | 단일 서버 (모놀리스) | **분산 서버 (MSA)** |

**결론은 명확합니다.** 여러 대의 서버로 확장되는 우리 이커머스 마이크로서비스 환경에서, 서비스 간 데이터 일관성을 보장하기 위해서는 **분산 캐시(Redis)가 유일한 정답**입니다.

다음 절에서는 이 Redis를 Spring Boot 애플리케이션에 어떻게 우아하게 연동할 수 있는지, `Spring Cache` 추상화에 대해 알아보겠습니다.