# 19장: 완벽한 관찰 가능성(Observability) III: 분산 추적

## 00. MSA에서의 병목 찾기: 분산 추적(Distributed Tracing)의 필요성 (Why)

지금까지 우리는 관찰 가능성의 두 기둥을 세웠습니다.
* **17장 로깅 (Logging):** 시스템에서 발생한 개별 '사건'에 대한 상세한 기록을 제공합니다. "무슨 일이 있었나?"에 답합니다.
* **18장 메트릭 (Metrics):** 시스템의 전반적인 건강 상태와 성능을 '숫자'로 요약하여 보여줍니다. "시스템이 건강한가?"에 답합니다.

이제 마지막 질문이 남았습니다. Grafana 대시보드에서 **"`order-service`의 99퍼센타일 응답 시간이 2초를 넘었다"**는 경고를 받았다고 가정해 봅시다. 메트릭은 **'문제'**가 발생했음을 알려주었지만, **'왜(Why)'** 느려졌는지는 알려주지 않습니다.

* `order-service` 자체의 코드가 문제일까요?
* `order-service`가 호출한 `product-service`가 느렸던 걸까요?
* 아니면 `product-service`가 호출한 데이터베이스 쿼리가 문제였을까요?

17장에서 도입한 **Correlation ID**를 이용해 Kibana에서 관련 로그를 모두 긁어모아 시간 순서대로 재구성하면 언젠가는 원인을 찾을 수 있겠지만, 이는 매우 고되고 시간이 많이 걸리는 수작업입니다.

이 "왜?"라는 질문에 즉시 답을 해주는 것이 바로 관찰 가능성의 마지막 기둥, **분산 추적(Distributed Tracing)**입니다.

---

### 분산 추적: 요청의 여정을 그린 지도 🗺️

**분산 추적**은 단일 사용자 요청이 MSA 시스템의 여러 서비스를 거쳐가는 **전체 여정을 시각화하고 분석**하는 기술입니다.

**릴레이 경주 비유 🏃:**
* **요청(Request):** 배턴(Baton)
* **마이크로서비스:** 각 구간의 주자
* **분산 추적 시스템:** 각 주자의 구간 기록을 측정하고 전체 경주 흐름을 기록하는 심판



#### 분산 추적의 핵심 구성 요소

1.  **Trace:** 하나의 요청에 대한 **전체 여정**입니다. 시스템에 처음 들어올 때 고유한 **`Trace ID`**가 부여되며, 이는 17장의 Correlation ID와 동일한 개념입니다.

2.  **Span:** Trace를 구성하는 **개별 작업 단위**입니다. 각 서비스 내에서 수행되는 특정 작업(예: HTTP API 호출, DB 쿼리 실행)을 나타냅니다. 모든 Span은 자신만의 `Span ID`를 가지며, **시작 시간과 종료 시간(소요 시간)**을 기록합니다.

3.  **부모-자식 관계:** Span들은 부모-자식 관계를 통해 나무(Tree) 구조를 형성합니다.
    * `API 게이트웨이`에서 생성된 첫 Span이 **루트 스팬(Root Span)**이 됩니다.
    * 게이트웨이가 `order-service`를 호출하면, `order-service`에서 생성된 Span은 게이트웨이 Span의 **자식 스팬(Child Span)**이 됩니다.
    * `order-service`가 DB를 쿼리하면, 이 DB 쿼리에 대한 Span은 `order-service` Span의 자식 스팬이 됩니다.

4.  **컨텍스트 전파 (Context Propagation):** 이 부모-자식 관계를 연결하는 핵심 메커니즘입니다. `게이트웨이`가 `order-service`를 호출할 때, `Trace ID`와 부모 `Span ID`가 담긴 **컨텍스트(Context)** 정보를 HTTP 헤더(예: `traceparent` 헤더)에 담아 함께 전달합니다. `order-service`는 이 헤더를 읽어 자신의 Span이 어떤 Trace와 어떤 부모 Span에 속하는지 알 수 있습니다.

---

### 분산 추적이 제공하는 가치: 병목의 시각화

분산 추적 시스템(예: `Jaeger`, `Zipkin`)은 수집된 Span 정보를 `Trace ID`로 묶어 위 이미지와 같은 **폭포(Waterfall) 차트**로 보여줍니다.

이 차트 하나로 우리는 다음 정보를 즉시 알 수 있습니다.
* **전체 호출 흐름:** `Gateway` -> `Order Service` -> `Product Service` -> `DB`
* **각 단계별 소요 시간:** 전체 응답 시간 800ms 중 `Product Service` 호출에서 600ms가 소요되었고, 그중 DB 쿼리에서 550ms가 걸렸다는 사실을 한눈에 파악할 수 있습니다.

**결론적으로,** 로그가 '점'이고 메트릭이 '선'이라면, 분산 추적은 이 점과 선을 연결하여 **인과 관계**를 설명하는 **'이야기'**입니다. MSA 환경에서 발생하는 복잡한 성능 문제의 근본 원인을 신속하게 찾아 해결하기 위한 필수적인 도구입니다.

이 장에서는 분산 추적의 표준으로 자리 잡고 있는 **OpenTelemetry**의 개념을 이해하고, 이를 스프링 부트 애플리케이션에 적용하여 **Jaeger**를 통해 요청의 흐름을 시각화하는 방법을 구현할 것입니다.