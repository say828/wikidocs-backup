## 컨텍스트 맵(Context Map) 작성: 서비스 간의 관계 정의 (Shared Kernel, Anti-Corruption Layer)

02장 01절에서 5개의 바운디드 컨텍스트(BC)를 식별하여 마이크로서비스의 '경계'를 확정했습니다. 하지만 이 서비스들은 '섬'이 아닙니다. 이커머스 비즈니스를 완성하기 위해 서로 끊임없이 '소통'해야 합니다.

**컨텍스트 맵(Context Map)**은 이 BC(서비스)들 간의 **'관계'와 '통신 방식'을 정의하는 전략적 청사진**입니다. 이는 "어떤 팀이 어떤 팀에 의존하는가?" 혹은 "두 팀의 모델이 변경될 때 서로에게 어떤 영향을 주는가?"를 명확히 하는, MSA 프로젝트의 '정치 지도'와도 같습니다.

이 관계를 명확히 정의하지 않으면, 서비스 경계를 나눈 의미가 무색하게 다시금 강한 결합(Tight Coupling)이 발생합니다.

---

### 핵심 관계 패턴

DDD는 BC 간의 관계를 정의하는 여러 패턴을 제시합니다. 우리는 그중 MSA에 가장 필수적인 패턴들을 살펴보겠습니다.

#### 1. 업스트림(Upstream)과 다운스트림(Downstream)

모든 관계의 기본입니다.

* **업스트림 (Upstream):** '상류'에 있는 서비스. 다른 서비스에게 정보나 기능을 **제공**합니다. (예: `상품` 서비스)
* **다운스트림 (Downstream):** '하류'에 있는 서비스. 업스트림의 정보나 기능을 **소비**합니다. (예: `주문` 서비스)

이 관계에서 **다운스트림은 업스트림의 결정에 영향을 받습니다.** `상품` 서비스가 API 스펙을 바꾸면, `주문` 서비스는 코드를 수정해야 할 수도 있습니다.

#### 2. 셰어드 커널 (Shared Kernel, SK)

* **정의:** 두 개 이상의 BC(팀)가 도메인 모델의 일부(예: 공통 라이브러리, DB 스키마)를 문자 그대로 **공유(Share)**하는 관계입니다.
* **이커머스 예시:** 모든 서비스가 공통으로 사용하는 `Money` Value Object나 `MemberId` 클래스를 `common-domain.jar` 같은 공통 라이브러리로 만들어 공유하는 것.
* **장점:** 코드 중복이 줄어듭니다.
* **위험성:** **MSA에서는 매우 위험한 안티패턴이 될 수 있습니다.** 만약 이 `common-domain.jar`가 변경되면, 이 커널을 공유하는 **모든 서비스가 동시에 수정 및 재배포**되어야 합니다. 이는 MSA의 '독립 배포' 원칙을 깨뜨립니다. 따라서 셰어드 커널은 `MemberId`처럼 절대 변하지 않을 것이 확실한, 아주 작은 핵심 모델에만 극도로 제한적으로 사용해야 합니다.

#### 3. 안티-커럽션 레이어 (Anti-Corruption Layer, ACL)

* **정의:** **다운스트림**이 **업스트림**의 '오염된' 모델로부터 자신의 '순수한' 도메인 모델을 **보호(Protect)**하기 위해 구축하는 '방어막'이자 '번역기' 계층입니다.
* **이커머스 예시 (가장 중요):**
    1. `주문(Ordering)` BC(다운스트림)가 `상품(Product)` BC(업스트림)의 API를 호출합니다.
    2. `상품` BC는 전시/마케팅 정보까지 포함된 50개 필드의 거대한 `ProductResponseDto`를 반환합니다.
    3. `주문` BC는 이 DTO가 자신의 핵심 도메인(`Order`)까지 침투(오염)하는 것을 원치 않습니다.
    4. `주문` BC 내부에 **ACL**을 둡니다. 이 ACL은 `ProductResponseDto`를 받아서, `주문` 도메인에 **딱 필요한 3개의 필드(`productId`, `name`, `orderPrice`)**만 추출한 뒤, `주문` BC 내부의 순수한 모델인 `ProductInfo`로 '번역'해 줍니다.
* **장점:** **느슨한 결합(Loose Coupling)의 핵심입니다.** 나중에 `상품` BC가 `ProductResponseDto`에 20개 필드를 추가하더라도, `주문` BC의 핵심 도메인은 아무런 영향을 받지 않습니다. ACL 계층의 번역 로직만 살짝 수정하면 그만입니다.

#### 4. 오픈 호스트 서비스 (Open Host Service, OHS) & 발행 언어 (Published Language, PL)

* **정의:** **업스트림**이 자신의 기능을 외부에 '공개'하는 방식입니다. 잘 정의된 REST API(`OHS`)와 이 API가 사용하는 DTO 또는 이벤트(`PL`)를 제공합니다.
* **이커머스 예시:** `상품` BC가 `GET /v1/products/{id}`라는 API(`OHS`)를 제공하고, 응답으로 `ProductResponseDto`(`PL`)를 반환하는 것입니다.

#### 5. 컨포미스트 (Conformist, CF)

* **정의:** '순응자'라는 뜻 그대로, **다운스트림(Downstream)** 팀이 **업스트림(Upstream)** 팀의 모델을 아무런 번역이나 수정 없이 **그대로 받아들여 사용**하는 관계입니다. 다운스트림은 업스트림 모델에 대해 어떠한 영향력도 행사하지 않으며, 전적으로 순응합니다.
* **이커머스 예시:**
    1.  `회원(Member)` 서비스(업스트림)가 `id`, `name`, `grade` 필드를 가진 `MemberDto`를 API 응답으로 제공합니다.
    2.  `주문(Order)` 서비스(다운스트림)는 이 `MemberDto`를 자신의 서비스 계층과 비즈니스 로직에서 **직접 사용**합니다. 별도의 번역 계층이나 `OrderMember`와 같은 내부 모델을 만들지 않습니다.
* **장점:** **극도의 단순함.** ACL과 같은 번역 계층을 만들 필요가 없어, 개발 속도가 매우 빠르고 초기 구현이 간단합니다.
* **위험성:** **강한 결합(Tight Coupling)이 발생합니다.** 다운스트림은 업스트림에 완전히 종속됩니다. 만약 `회원` 서비스팀이 `MemberDto`의 `grade` 필드를 `level`로 변경하면, `주문` 서비스의 코드는 **컴파일 에러를 일으키며 즉시 깨집니다.** 이로 인해 `주문` 서비스는 자신의 비즈니스 로직 변경이 없음에도 불구하고, 오직 업스트림의 변경 때문에 코드를 수정하고, 테스트하고, 재배포해야 하므로 **독립적인 배포 원칙이 위배**됩니다.

---

### 우리 이커머스 프로젝트의 컨텍스트 맵

이제 우리 5개의 BC 간의 관계를 정의해 봅시다.



1.  **`상품(Product)` (U) vs `주문(Order)` (D)**
    * **관계:** **Anti-Corruption Layer (ACL)**
    * **이유:** `주문`은 `상품`의 모든 정보가 필요 없습니다. `주문`은 `상품`의 API가 변경되더라도 자신의 도메인을 보호해야 합니다. (06장 `Feign` 클라이언트가 이 ACL의 일부가 됩니다.)

2.  **`회원(Member)` (U) vs `주문(Order)` (D)**
    * **관계:** **Open Host Service (OHS) / Conformist (CF)**
    * **이유:** `회원` 모델은 `MemberId`, `Name`, `Grade` 정도로 매우 단순하고 안정적입니다. `주문`은 `회원`의 모델이 변경될 위험이 적다고 판단, `회원`이 제공하는 DTO를 그대로 '수용(Conform)'합니다. (ACL을 구축하는 오버헤드를 줄임)

3.  **`주문(Order)` (U) vs `결제(Payment)` (D)**
    * **관계:** **Open Host Service (OHS) + ACL**
    * **이유:** `주문`이 `결제`를 동기식(Sync)으로 호출할 때, `주문`은 `결제`가 필요한 최소 정보(`orderId`, `amount`)만 제공합니다. `결제`는 `주문`의 복잡한 내부 모델을 알 필요가 없습니다.

4.  **`주문(Order)` (U) vs `배송(Shipping)` (D)**
    * **관계:** **이벤트 기반 (Event-Driven) / Published Language (PL)**
    * **이유:** `주문`은 '결제가 완료'되면 `OrderPaid` 이벤트를 `Kafka`로 발행(Publish)합니다. (07장) 이 이벤트가 `주문`의 `PL`입니다. `배송`은 이 이벤트를 구독(Subscribe)하여 작업을 시작합니다. 두 서비스는 서로의 존재조차 모를 수 있습니다. (궁극의 Loose Coupling)

5.  **`결제(Payment)` (U) vs `주문(Order)` (D)**
    * **관계:** **이벤트 기반 (Event-Driven) / Published Language (PL)**
    * **이유:** `결제`가 완료되면, `PaymentCompleted` 이벤트를 `Kafka`로 발행합니다. `주문`은 이 이벤트를 구독하여 `주문`의 상태를 `PAID`로 변경합니다. (10장 SAGA 패턴에서 자세히 다룸)

이 컨텍스트 맵은 이제 우리 MSA의 '통신 규약'이 되었습니다. 우리는 이 규약에 따라 `ACL`을 구현하고, `OHS` API를 설계하며, `PL` 이벤트를 정의할 것입니다.