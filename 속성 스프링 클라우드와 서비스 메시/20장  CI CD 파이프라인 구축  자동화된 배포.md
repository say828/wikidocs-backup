# 20장: CI/CD 파이프라인 구축: 자동화된 배포

## 00. 왜 CI/CD가 필수인가?: 빠르고 안전한 배포

지금까지 우리는 훌륭한 마이크로서비스들을 개발하고, 컨테이너화했으며, 쿠버네티스에 배포하는 방법까지 배웠습니다. 하지만 이 모든 과정이 여전히 '수작업'이라면 어떨까요?

**수동 배포의 현실:**
1.  개발자가 로컬에서 코드를 수정합니다.
2.  로컬에서 `./gradlew test`로 테스트를 실행합니다.
3.  `./gradlew bootBuildImage`로 컨테이너 이미지를 빌드합니다.
4.  `docker push`로 이미지를 컨테이너 레지스트리에 푸시합니다.
5.  `kubectl set image deployment/...` 명령어로 쿠버네티스에 배포합니다.

이 과정은 한 명의 개발자가 하나의 서비스를 다룰 때는 가능해 보입니다. 하지만 10명의 개발자가 10개의 서비스를 매일 수십 번씩 변경한다면, 이 수작업은 곧 **느리고, 실수가 잦으며, 일관성 없는** 재앙으로 변합니다. 개발자는 비즈니스 로직 개발이라는 본업보다 배포에 더 많은 시간을 쏟게 됩니다.

이 문제를 해결하고, MSA의 진정한 힘인 '빠르고 독립적인 배포'를 실현하기 위해 **CI/CD 파이프라인**은 선택이 아닌 **필수**입니다.

---

### CI/CD: "지속적인 통합"과 "지속적인 전달/배포"

CI/CD는 두 가지 개념의 조합입니다.

#### 1. CI (Continuous Integration, 지속적인 통합)

* **정의:** 여러 개발자가 작업한 코드를 중앙 저장소(예: GitHub의 `main` 브랜치)에 **자주 병합(Merge)**하는 개발 프랙티스입니다.
* **핵심:** 코드가 병합될 때마다, **자동화된 빌드와 단위/통합 테스트가 실행**됩니다.
* **목표:** **"통합 지옥(Integration Hell)"을 방지하는 것.**
    각자 며칠, 몇 주 동안 작업한 거대한 코드를 한꺼번에 병합할 때 발생하는 수많은 충돌과 버그를 사전에 방지합니다. 코드 변경으로 인해 빌드가 깨지거나 테스트가 실패하면, CI 서버가 즉시 피드백을 주어 문제를 조기에 발견하고 해결할 수 있습니다. CI는 코드 품질을 일정 수준 이상으로 유지하는 **'품질 게이트'** 역할을 합니다.

#### 2. CD (Continuous Delivery/Deployment, 지속적인 전달/배포)

* **정의:** CI 단계를 성공적으로 통과한 코드 변경 사항을 **자동으로 프로덕션 환경까지 릴리즈**하는 프랙티스입니다.
* **두 가지 수준:**
    * **지속적인 전달(Continuous Delivery):** CI가 끝난 후, 코드를 빌드하고 컨테이너 이미지로 만들어 **스테이징(Staging) 환경까지는 자동으로 배포**합니다. 하지만 **실제 프로덕션 환경으로의 배포는 운영자의 '버튼 클릭'과 같은 수동 승인**을 통해 이루어집니다. 이는 비즈니스적으로 중요한 릴리즈 시점을 제어할 수 있는 안전한 접근 방식입니다.
    * **지속적인 배포(Continuous Deployment):** '지속적인 전달'의 최종 단계입니다. 스테이징 환경에서의 모든 자동화된 테스트(E2E 테스트 등)까지 통과하면, **사람의 개입 없이 자동으로 프로덕션 환경에 배포**됩니다. 이는 테스트 자동화에 대한 매우 높은 신뢰도를 요구하는 가장 높은 수준의 자동화입니다.

* **목표:** 배포 과정을 **빠르고, 안정적이며, 반복 가능하게** 만드는 것.
    수동 배포에서 발생하는 모든 휴먼 에러를 제거하고, 작은 단위의 변경을 자주 배포함으로써 각 배포의 리스크를 극적으로 줄입니다.

---

### 우리의 CI/CD 파이프라인 청사진



1.  **[개발]** 개발자가 `feature` 브랜치에 코드를 푸시하고 `main` 브랜치로 **Pull Request(PR)**를 생성합니다.
2.  **[CI 시작]** CI 서버(**GitHub Actions**)가 PR을 감지하고 파이프라인을 실행합니다.
3.  **[빌드 및 테스트]** `./gradlew build`를 실행하여 코드를 컴파일하고, 모든 단위/통합/계약 테스트를 수행합니다.
4.  **[PR 피드백]** 테스트 결과를 PR에 자동으로 코멘트합니다. 테스트가 실패하면 병합(Merge)이 불가능하도록 설정합니다.
5.  **[병합]** 코드 리뷰 후, PR이 `main` 브랜치에 병합됩니다.
6.  **[CD 시작]** CI 서버가 `main` 브랜치로의 변경을 감지하고 CD 파이프라인을 실행합니다.
7.  **[이미지 빌드 및 푸시]** `./gradlew bootBuildImage`로 컨테이너 이미지를 빌드하고, Docker Hub나 AWS ECR 같은 **컨테이너 레지스트리**에 푸시합니다.
8.  **[스테이징 배포]** 쿠버네티스 클러스터의 `staging` 네임스페이스에 `kubectl` 또는 `Helm` 명령어를 사용하여 새로운 이미지로 배포합니다.
9.  **[E2E 테스트]** 스테이징 환경을 대상으로 자동화된 E2E 테스트를 실행합니다.
10. **[프로덕션 배포]** (수동 승인 후) `production` 네임스페이스에 동일한 방식으로 배포합니다.

이 자동화된 파이프라인은 MSA를 위한 '고속도로'와 같습니다. 이 고속도로가 없다면, 각 서비스는 비포장도로를 달리며 속도를 내지 못할 것입니다. 이 장에서는 **GitHub Actions**를 사용하여 우리 이커머스 서비스를 위한 실용적인 CI/CD 파이프라인을 처음부터 끝까지 구축할 것입니다.