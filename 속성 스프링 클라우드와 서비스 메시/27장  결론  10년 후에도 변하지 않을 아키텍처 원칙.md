# 27장: 결론: 10년 후에도 변하지 않을 아키텍처 원칙

## 00. 우리가 구축한 이커머스 아키텍처의 완성형 리뷰

기나긴 여정의 끝에, 우리는 드디어 '100% 완성형 이커머스 MSA 프로젝트'의 청사진을 완성했습니다. 03장의 간단했던 '회원' 모놀리스 API에서 출발하여, 우리는 이제 수많은 최신 기술과 아키텍처 패턴이 유기적으로 결합된 정교한 클라우드 네이티브 시스템을 갖게 되었습니다.

이 마지막 장에서는 우리가 구축한 최종 아키텍처를 전체적으로 조망하고, 이 복잡성 속에서 10년 후에도 변하지 않을 핵심적인 아키텍처 원칙들을 되새겨보고자 합니다.

---

### 우리의 최종 아키텍처: 한눈에 보기



우리가 완성한 시스템은 다음과 같은 핵심적인 특징을 가집니다.

* **애플리케이션 계층:**
    * `DDD`를 통해 명확한 책임과 경계를 가진 마이크로서비스(`회원`, `상품`, `주문` 등)로 분리되었습니다.
    * 핵심 서비스는 `코틀린`과 `스프링 부트`로, 이벤트 처리 백그라운드 작업은 `서버리스(KNative)`로 구현된 **폴리글랏(Polyglot) 아키텍처**입니다.

* **데이터 계층:**
    * **Database per Service** 패턴을 채택하여 각 서비스는 자신만의 DB를 소유합니다.
    * **폴리글랏 퍼시스턴스**를 적용하여, `주문`(트랜잭션)에는 `RDBMS`를, `상품`(검색)에는 `Elasticsearch`를, `캐시`에는 `Redis`를 사용하는 등 목적에 맞는 최적의 데이터 저장소를 선택했습니다.
    * **CQRS**, **SAGA**, **CDC**, **트랜잭셔널 아웃박스** 패턴을 통해 분산된 데이터 환경에서의 **최종 일관성(Eventual Consistency)**을 확보했습니다.

* **플랫폼 및 인프라 계층:**
    * 모든 서비스는 **컨테이너화(Buildpacks/Jib)**되어, **쿠버네티스(Kubernetes)** 위에서 실행됩니다.
    * **서비스 메시(Istio)**를 도입하여, 서비스 디스커버리, 라우팅, 서킷 브레이커, mTLS 보안 등 복잡한 네트워크 제어를 애플리케이션 외부의 **플랫폼 레벨**로 위임했습니다.
    * **KNative**를 통해 요청 기반의 `Scale-to-Zero`가 가능한 진정한 서버리스 워크로드를 쿠버네티스 위에서 구현했습니다.

* **운영 및 관찰 가능성:**
    * **GitHub Actions**와 **ArgoCD**를 이용한 **GitOps** 기반의 완전 자동화된 **CI/CD 파이프라인**을 구축했습니다.
    * **로깅(ELK/Loki), 메트릭(Prometheus/Grafana), 추적(Jaeger/OpenTelemetry)**이라는 관찰 가능성의 세 기둥을 완성하여, 시스템 내부를 완벽하게 들여다볼 수 있는 '눈'을 갖추었습니다.
    * **플랫폼 엔지니어링**의 철학 아래, 이 모든 복잡성을 **내부 개발자 플랫폼(IDP)** 뒤로 추상화하여 개발자의 경험(DevEx)을 향상시키는 방향을 제시했습니다.

---

### 이 아키텍처가 달성한 가치

이 복잡한 아키텍처는 단순히 최신 기술의 나열이 아닙니다. 우리는 이 설계를 통해 현대 비즈니스가 요구하는 핵심적인 가치들을 달성했습니다.

* **민첩성 (Agility):** 각 팀은 다른 팀에 대한 의존성 없이, 자신들의 마이크로서비스를 독립적으로 개발, 테스트, 배포할 수 있습니다. 이는 비즈니스 요구사항에 훨씬 더 빠르게 대응할 수 있음을 의미합니다.
* **확장성 (Scalability):** 트래픽이 몰리는 특정 서비스(`product-service`)만 독립적으로 확장(HPA)할 수 있어, 자원을 매우 효율적으로 사용할 수 있습니다.
* **탄력성 (Resilience):** 하나의 서비스(`review-service`)에 장애가 발생하더라도, 서킷 브레이커와 서비스 메시가 장애를 격리하여 전체 시스템의 붕괴(Cascading Failure)를 막습니다.
* **유지보수성 (Maintainability):** 각 서비스는 자신의 도메인 책임에만 집중하므로 코드베이스가 작고 응집도가 높습니다. 덕분에 코드를 이해하고 수정하기가 훨씬 용이합니다.

물론, 이 모든 것을 얻는 대가로 우리는 '복잡성'이라는 비용을 지불했습니다. 하지만 중요한 것은, 이 복잡성을 개별 개발자에게 떠넘기는 대신, **플랫폼**이 흡수하고 자동화했다는 점입니다.

우리는 이 책을 통해 하나의 완성된 시스템을 구축하는 여정을 마쳤습니다. 이제 마지막으로, 이 구체적인 구현을 넘어, 시간이 지나도 변치 않을 보편적인 아키텍처 설계의 원칙에 대해 이야기해 보겠습니다.