## 컨슈머(Consumer)와 컨슈머 그룹: 리밸런싱(Rebalancing)의 이해

프로듀서가 보낸 이벤트를 실제로 소비하고 비즈니스 로직을 수행하는 **컨슈머(Consumer)**는 Kafka 아키텍처의 마지막 퍼즐 조각입니다. Kafka 컨슈머의 가장 큰 특징은 **컨슈머 그룹(Consumer Group)**이라는 개념을 통해 **병렬 처리(Parallelism)**와 **결함 허용(Fault Tolerance)**을 동시에 달성한다는 점입니다.

---

### 컨슈머 그룹: 작업을 분담하는 한 팀

**컨슈머 그룹**은 동일한 **`group.id`**를 가진 컨슈머 인스턴스들의 묶음입니다. 이 그룹은 하나의 팀처럼 협력하여 특정 토픽을 구독합니다.

여기에는 매우 중요한 규칙이 하나 있습니다.

> **"하나의 토픽 파티션은, 동일한 컨슈머 그룹 내에서 오직 하나의 컨슈머 인스턴스에만 할당된다."**



**슈퍼마켓 계산대 비유:**
* **토픽:** 계산이 필요한 물건들
* **파티션:** 4개의 계산대 (P0, P1, P2, P3)
* **컨슈머 그룹:** 계산원 팀

1.  **계산원 1명 (컨슈머 인스턴스 1개):**
    * 계산원 C1은 4개의 계산대(P0, P1, P2, P3)를 모두 혼자 담당해야 합니다.
2.  **계산원 2명 (컨슈머 인스턴스 2개):**
    * 이제 일을 분담할 수 있습니다. C1이 1, 2번 계산대(P0, P1)를 맡고, C2가 3, 4번 계산대(P2, P3)를 맡습니다. 처리량이 2배로 늘어납니다.
3.  **계산원 4명 (컨슈머 인스턴스 4개):**
    * 가장 이상적인 상태입니다. C1, C2, C3, C4가 각각 하나의 계산대(P0, P1, P2, P3)를 전담합니다. 병렬 처리가 극대화됩니다.
4.  **계산원 5명 (컨슈머 인스턴스 5개):**
    * C5는 할당받을 계산대가 없으므로 **아무 일도 하지 않고 놀게 됩니다.**

이 비유에서 알 수 있듯이, 한 컨슈머 그룹 내에서 **활성화될 수 있는 컨슈머의 최대 개수는 구독하는 토픽의 파티션 개수와 같습니다.** 이것이 Kafka의 병렬 처리를 설계하는 핵심 원칙입니다.

---

### 리밸런싱(Rebalancing): 파티션을 재분배하는 과정

컨슈머 그룹에 새로운 컨슈머가 들어오거나, 기존 컨슈머가 나갈 때, Kafka는 이 파티션 할당을 동적으로 재조정해야 합니다. 이 과정을 **리밸런싱(Rebalancing)**이라고 부릅니다.

리밸런싱은 다음과 같은 상황에서 **트리거(Trigger)**됩니다.
1.  **새로운 컨슈머 인스턴스가 그룹에 참여할 때** (예: 서비스 배포, 스케일 아웃)
2.  **기존 컨슈머 인스턴스가 그룹을 떠날 때** (예: 정상 종료, 장애로 인한 크래시, 하트비트 실패)
3.  **구독하는 토픽의 메타데이터가 변경될 때** (예: 관리자가 토픽의 파티션 개수를 늘릴 때)

**리밸런싱의 동작 ("Stop-the-World"):**
1.  리밸런스가 트리거되면, Kafka 클러스터의 **그룹 코디네이터(Group Coordinator)**는 해당 컨슈머 그룹의 **모든 컨슈머에게 "모두 잠시 멈춰!"**라는 신호를 보냅니다.
2.  이 신호를 받은 모든 컨슈머는 메시지 처리를 **일시 중단**하고, 자신이 할당받았던 파티션의 소유권을 모두 포기합니다. 이 짧은 시간 동안 토픽의 소비는 완전히 멈춥니다.
3.  그룹 코디네이터는 그룹에 남아있는 컨슈머들을 확인하고, 파티션 할당 전략(기본값: RangeAssignor 또는 StickyAssignor)에 따라 각 컨슈머에게 새로운 파티션들을 재분배합니다.
4.  새로운 파티션을 할당받은 컨슈머들은, 할당받은 파티션의 마지막 커밋 오프셋부터 메시지 처리를 다시 시작합니다.

#### 리밸런싱의 의미와 주의점

리밸런싱은 Kafka가 스스로 **결함 허용(Fault Tolerance)**과 **탄력성(Elasticity)**을 확보하는 핵심 메커니즘입니다. 컨슈머 하나가 장애로 죽더라도, Kafka가 알아서 그 컨슈머가 담당하던 파티션을 다른 살아있는 컨슈머에게 넘겨주어 서비스 중단을 최소화합니다.

하지만 리밸런싱 중 발생하는 **"Stop-the-World"**는 실시간 처리가 매우 중요한 애플리케이션에서는 성능 저하의 원인이 될 수 있습니다. 컨슈머가 너무 자주 죽었다 살아나며 리밸런싱이 빈번하게 발생하면, 시스템 전체의 처리량이 크게 떨어질 수 있습니다.

따라서 안정적인 컨슈머 애플리케이션을 작성하고, `max.poll.interval.ms` (컨슈머가 브로커로부터 다음 메시지를 가져오는 최대 시간) 같은 옵션을 비즈니스 로직 처리 시간에 맞게 적절히 튜닝하여 불필요한 리밸런싱을 피하는 것이 중요합니다.

이제 Kafka의 핵심 아키텍처를 모두 이해했습니다. 마지막으로 이 지식을 바탕으로 `Spring Kafka`를 활용하여 실제 이커머스 이벤트 파이프라인을 구축하는 코드를 살펴보겠습니다.