## 프로듀서(Producer)의 작동 원리: ACK 옵션과 전송 보장(Delivery Guarantee)

Kafka의 핵심 아키텍처를 이해했으니, 이제 시스템의 첫 관문인 **프로듀서(Producer)**가 어떻게 이벤트를 Kafka 클러스터로 안정적이고 효율적으로 전송하는지 그 내부 원리를 살펴보겠습니다.

프로듀서의 역할은 간단합니다. 이벤트 데이터(Value), 토픽 이름, 그리고 선택적인 파티셔닝 키(Key)를 담은 `ProducerRecord` 객체를 만들어 Kafka 브로커로 전송(`send`)하는 것입니다. 하지만 그 이면에는 성능과 안정성을 위한 중요한 메커니즘이 숨어있습니다.

---

### 고성능의 비결: 배치(Batch) 전송

프로듀서는 모든 메시지를 개별적으로 네트워크를 통해 전송하지 않습니다. 만약 1초에 1000개의 메시지를 보내야 한다면, 1000번의 네트워크 왕복(Round-trip)이 발생하여 심각한 성능 저하를 유발할 것입니다.

대신, 프로듀서는 **배치(Batch)**라는 영리한 최적화 기법을 사용합니다.

1.  프로듀서는 `send()` 요청을 받으면, 메시지를 내부 버퍼(Buffer)에 쌓아둡니다.
2.  **동일한 파티션**으로 가는 메시지들을 모아 하나의 '배치'로 묶습니다.
3.  버퍼가 일정 크기(`batch.size`)에 도달하거나, 대기 시간(`linger.ms`)이 초과되면, 이 배치를 **단 한 번의 네트워크 요청**으로 브로커에 전송합니다.

이 배치 처리 덕분에, 프로듀서는 약간의 지연 시간(latency)을 희생하는 대신, 네트워크 오버헤드를 극적으로 줄여 엄청난 처리량(throughput)을 얻을 수 있습니다.

---

### 전송 보장(Delivery Guarantee)의 핵심: `acks` 옵션

"프로듀서가 `send()`를 호출했을 때, 이 메시지가 Kafka에 '성공적으로 저장되었다'는 것을 어떻게 보장할 수 있을까?"

이 질문은 분산 시스템에서 데이터 유실을 막기 위한 가장 근본적인 질문입니다. Kafka는 이 '전송 보장' 수준을 프로듀서의 **`acks` (acknowledgements, 확인 응답)** 옵션을 통해 개발자가 직접 제어할 수 있도록 합니다.

`acks` 옵션은 **데이터 무결성(Durability)**과 **성능(Performance)** 사이의 중요한 트레이드오프 관계를 가집니다.

#### 1. `acks=0`: "일단 쏜다" (Fire-and-Forget)

* **동작:** 프로듀서는 메시지를 브로커로 전송한 직후, 브로커로부터 **아무런 확인 응답(ack)을 기다리지 않고** 즉시 '전송 성공'으로 간주합니다.
* **성능:** 네트워크 왕복 대기 시간이 없으므로, **가장 빠르고 처리량이 높습니다.**
* **보장 수준 (At-most-once):** 메시지가 브로커에 도착했는지, 성공적으로 저장되었는지 전혀 보장할 수 없습니다. 브로커가 다운되었거나 네트워크가 불안정하면 **메시지는 유실될 수 있습니다.**
* **사용 사례:** 일부 데이터가 유실되어도 괜찮은 비즈니스 로직. (예: 대규모 실시간 로그 수집, 비핵심 모니터링 메트릭)

#### 2. `acks=1`: "리더는 받았다" (Leader Acknowledgement) - **기본값**

* **동작:** 프로듀서는 메시지를 전송한 뒤, 파티션의 **리더(Leader) 레플리카**가 메시지를 자신의 로그에 기록했다는 확인 응답(ack)을 받을 때까지 기다립니다.
* **성능:** 리더의 응답을 기다려야 하므로 `acks=0`보다는 느리지만, 여전히 매우 빠릅니다.
* **보장 수준 (At-least-once, 대부분):** 메시지가 최소한 리더 브로커에는 안전하게 저장되었음을 보장합니다.
* **단점 (데이터 유실 가능성):** 만약 리더가 메시지를 받고 ack를 보낸 직후, 다른 **팔로워(Follower) 레플리카**들이 데이터를 복제하기 **전에** 리더 브로커가 다운되면 어떻게 될까요? 이 경우, 팔로워 중 새로운 리더가 선출되지만, 마지막 메시지는 유실된 상태가 됩니다. (매우 드문 경우)
* **사용 사례:** 대부분의 일반적인 비즈니스 애플리케이션에 적합한, 성능과 안정성의 좋은 균형점입니다.

#### 3. `acks=all` (또는 `-1`): "모두가 받았다" (Full Acknowledgement)


* **동작:** 프로듀서는 메시지를 전송한 뒤, 파티션의 **리더 레플리카뿐만 아니라, 모든 '동기화된(In-Sync)' 팔로워 레플리카들까지** 메시지를 성공적으로 복제했다는 확인 응답을 리더를 통해 받을 때까지 기다립니다.
* **성능:** 리더와 여러 팔로워 간의 데이터 복제 시간까지 모두 기다려야 하므로, **가장 느리고 처리량이 낮습니다.**
* **보장 수준 (At-least-once, 가장 강력함):** **데이터 유실을 절대 허용하지 않는 가장 강력한 보장 수준**입니다. 리더 브로커가 다운되더라도, 메시지가 최소 하나 이상의 팔로워에 안전하게 복제되어 있음을 100% 보장합니다. (멱등성 프로듀서 옵션과 함께 사용 시 Exactly-once도 가능)
* **사용 사례:** **절대 유실되어서는 안 되는 매우 중요한 데이터.** (예: **결제 완료 이벤트**, **주문 생성 이벤트**)

---

### 우리의 선택: `OrderPaidEvent`는 `acks=all`로

우리 이커머스 프로젝트에서, 고객의 결제와 주문을 나타내는 `OrderPaidEvent`는 단 하나도 유실되어서는 안 되는 핵심 데이터입니다. 따라서 이 이벤트를 발행하는 프로듀서는 반드시 **`acks=all`** 옵션을 사용해야 합니다.

반면, 사용자의 단순 클릭 로그 같은 비핵심 데이터를 수집할 때는 `acks=1`을 사용하여 성능을 확보하는 전략적 선택을 할 수 있습니다.

이처럼 `acks` 옵션은 개발자가 비즈니스의 중요도에 따라 성능과 안정성 사이에서 능동적으로 저울질할 수 있게 해주는 Kafka의 강력한 기능입니다.