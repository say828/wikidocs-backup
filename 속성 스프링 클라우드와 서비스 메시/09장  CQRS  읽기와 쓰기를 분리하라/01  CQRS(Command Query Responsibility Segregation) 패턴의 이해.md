## CQRS(Command Query Responsibility Segregation) 패턴의 이해

CQRS는 09장 00절에서 제기된 '읽기'와 '쓰기'의 상충하는 요구사항을 해결하기 위한 아키텍처 패턴입니다. 이 패턴의 창시자인 그렉 영(Greg Young)은 마틴 파울러(Martin Fowler)가 제시한 CQS(Command Query Separation) 원칙에서 아이디어를 얻었습니다.

* **CQS (Command Query Separation):** 객체의 메서드는 '상태를 변경하는 **명령(Command)**'이거나 '상태를 반환하는 **조회(Query)**'여야 하며, 둘 다여서는 안 된다.

CQRS는 이 CQS 원칙을 객체 수준을 넘어 **아키텍처 전체 수준으로 확장**한 것입니다. 즉, 상태를 변경하는 **'명령 모델'**과 상태를 조회하는 **'조회 모델'**을 아예 분리하는 것을 의미합니다.

---

### CQRS의 핵심 구성 요소

CQRS 아키텍처는 크게 두 개의 흐름(Pipeline)으로 나뉩니다.



#### 1. 명령(Command) 측 파이프라인

이 흐름의 유일한 목적은 **시스템의 상태를 변경하는 것**입니다.

* **Command:** 상태를 변경하려는 '의도'를 담은 객체입니다.
    * **명명 규칙:** `CreateProductCommand`, `DecreaseStockCommand`처럼 동사형으로 명명합니다.
    * **특징:** 로직 수행에 필요한 모든 데이터를 담고 있으며, **데이터를 반환하지 않는 것(`void` 또는 `Unit`)**이 원칙입니다. (성공/실패 여부나 생성된 리소스의 ID 정도만 반환할 수 있습니다.)

* **Command Handler:** `Command` 객체를 받아 실제 비즈니스 로직을 수행하는 처리기입니다.
    * **역할:** Command의 유효성을 검증하고, 02장에서 설계한 **도메인 모델(Aggregate)**을 조회하여 비즈니스 규칙(Invariant)을 실행한 뒤, 변경된 상태를 **쓰기 전용 저장소(Write DB)**에 영속화합니다.

#### 2. 조회(Query) 측 파이프라인

이 흐름의 유일한 목적은 **시스템의 상태를 조회하는 것**이며, 절대 상태를 변경해서는 안 됩니다.

* **Query:** 데이터를 요청하는 '의도'를 담은 객체입니다.
    * **명명 규칙:** `GetProductDetailsQuery`, `FindOrdersByMemberQuery`처럼 조회 목적을 나타내도록 명명합니다.
    * **특징:** 페이징, 정렬, 필터링 조건 등을 담을 수 있습니다.

* **Query Handler (또는 Query Service):** `Query` 객체를 받아 데이터를 조회하고 **읽기 전용 DTO**를 반환하는 처리기입니다.
    * **역할:** **읽기 전용 저장소(Read DB)**에 직접 접근하여, 화면에 필요한 모양 그대로 최적화된 데이터를 조회합니다. 여기에는 복잡한 비즈니스 로직이 포함되지 않습니다.

---

### 모델의 분리: Aggregate vs. Read Model

CQRS의 진정한 힘은 '로직'의 분리를 넘어 '모델' 자체의 분리에서 나옵니다.

* **쓰기 모델 (Write Model):**
    * **02장에서 설계한 DDD의 Aggregate**가 바로 쓰기 모델입니다.
    * 복잡한 비즈니스 규칙과 불변성(Invariant)을 강제하는 '똑똑한' 모델입니다.
    * 데이터의 일관성과 무결성을 위해 **정규화된(Normalized) RDBMS**에 저장하는 것이 일반적입니다.

* **읽기 모델 (Read Model):**
    * 오직 특정 화면이나 API 조회를 위해 존재하는 **'멍청한' 데이터 덩어리(DTO)**입니다.
    * `상품 상세 페이지`처럼, 여러 테이블의 데이터가 미리 `JOIN`되어 모든 정보가 담겨있는 **비정규화된(Denormalized)** 형태를 가집니다.
    * 빠른 조회를 위해 **Elasticsearch** 같은 검색 엔진, **Redis** 같은 인메모리 DB, 또는 단순히 RDBMS의 '조회 전용 테이블'에 저장될 수 있습니다.

---

### 가장 큰 숙제: 데이터 동기화 (Data Synchronization)

쓰기 모델과 읽기 모델이 분리되면서 새로운 문제가 발생합니다. "쓰기 DB의 데이터가 변경되었을 때, 이 변경 사항을 어떻게 읽기 DB에 반영할 것인가?"

이 동기화 문제를 해결하는 가장 이상적인 방법이 바로 08장에서 배운 **이벤트 기반 아키텍처(EDA)**입니다.

1.  `Command Handler`가 쓰기 모델(Aggregate)의 상태를 변경하고 **쓰기 DB**에 저장합니다.
2.  이와 동시에, "상품 가격이 변경되었다"는 의미를 담은 `ProductPriceChangedEvent`를 발행합니다. (11장의 '트랜잭셔널 아웃박스' 패턴을 통해 DB 저장과 이벤트 발행의 원자성을 보장합니다.)
3.  이 이벤트는 **Kafka**로 전송됩니다.
4.  별도의 **프로젝터(Projector)** 또는 조회 서비스의 컨슈머가 이 이벤트를 구독합니다.
5.  프로젝터는 이벤트를 받아 **읽기 DB**의 비정규화된 '읽기 모델' 데이터를 갱신(Update)합니다.

이 방식을 사용하면 쓰기 DB와 읽기 DB 사이에는 약간의 시간 차이가 발생하는 **최종 일관성(Eventual Consistency)**을 가지게 되지만, 두 모델을 완벽하게 분리하여 각각의 목적에 맞게 최적화할 수 있는 강력한 유연성을 얻게 됩니다.

다음 절부터 우리는 `주문` 도메인을 대상으로 실제 '명령'과 '조회' 모델을 코드로 구현해 보겠습니다.