## 왜 자바가 아닌 코틀린인가?: 생산성과 안정성이라는 두 마리 토끼

이 책은 '자바(Java)'가 아닌 '코틀린(Kotlin)'을 주력 언어로 선택했습니다. 이것은 단순한 '취향'의 문제가 아니라, 앞서 언급한 현대 아키텍처의 요건(확장성, 탄력성, 유지보수성)을 달성하기 위한 전략적인 선택입니다.

스프링(Spring) 생태계는 자바를 기반으로 탄생했지만, 이제 스프링 부트 3.0 이상에서는 코틀린을 1순위(First-class Citizen)로 지원하며 공식 문서와 예제에서도 코틀린을 적극적으로 활용하고 있습니다. 왜일까요?

### 1\. 생산성: 더 적은 코드로 더 많은 일을 하라

자바 개발자가 코틀린을 처음 접했을 때 가장 놀라는 부분은 코드의 '간결함'입니다.

  * **데이터 클래스 (Data Class):** 이커머스 시스템의 DTO(Data Transfer Object)나 도메인 모델을 생각해 보십시오. 자바에서는 `equals()`, `hashCode()`, `toString()`, `getter/setter` 등을 구현하기 위해 수십 줄의 상용구(Boilerplate) 코드가 필요합니다. (Lombok을 사용하더라도 어노테이션이 필요합니다.)

```java
// Java (with Lombok)
@Getter
@EqualsAndHashCode
@ToString
public class OrderDto {
    private final Long orderId;
    private final String productName;
    private final Long amount;

    public OrderDto(Long orderId, String productName, Long amount) {
        this.orderId = orderId;
        this.productName = productName;
        this.amount = amount;
    }
}
```

    코틀린은 이 모든 것을 단 한 줄로 끝냅니다. `data` 키워드 하나에 `equals()`, `hashCode()`, `toString()`, 그리고 `copy()` 메서드까지 자동으로 생성됩니다.

```kotlin
// Kotlin
data class OrderDto(
    val orderId: Long,
    val productName: String,
    val amount: Long
)
```

  * **불변성 (Immutability):** 코틀린은 기본적으로 **불변성**을 권장합니다. `val`(value, 읽기 전용)과 `var`(variable, 변경 가능)을 명확히 구분합니다. MSA 환경에서는 여러 서비스가 데이터를 주고받거나 여러 스레드가 동시에 데이터에 접근할 수 있으므로, '변경 불가능한' 객체를 사용하는 것이 시스템의 안정성을 극적으로 높여줍니다. 위 `OrderDto` 예시의 `val` 키워드가 바로 그것입니다.

### 2\. 안정성: '10억 달러짜리 실수'를 방지하라

"I call it my billion-dollar mistake." - 토니 호어 (Tony Hoare), `null` 참조의 발명가

자바 개발자를 가장 고통스럽게 하는 예외는 단연 `NullPointerException` (NPE)입니다. MSA 환경에서 '주문' 서비스가 '회원' 서비스로부터 응답을 받았는데, 특정 필드가 `null`이어서 시스템 전체가 멈춘다면 끔찍한 일입니다.

코틀린은 **타입 시스템(Type System)** 자체에 Null 안정성을 내장했습니다.

  * **Nullable vs. Non-Nullable:** 코틀린은 타입 선언 시 `?` 기호를 통해 이 변수가 `null`을 허용하는지(`String?`) 아닌지(`String`)를 컴파일 시점에 명시해야 합니다.

```kotlin
var name: String = "Ecommerce"
// name = null // 컴파일 에러! String 타입에는 null을 할당할 수 없습니다.

var nullableName: String? = "Ecommerce"
nullableName = null // OK! String? 타입은 null을 허용합니다.
```

  * **안전한 호출 (Safe Call):** `null`일 수도 있는 타입(`String?`)은 `?.` 연산자를 사용해야만 메서드를 호출할 수 있습니다. 만약 객체가 `null`이면, 메서드를 호출하는 대신 `null`을 반환하고 프로그램은 멈추지 않습니다.

```kotlin
// nullableName이 null이면 NPE를 발생시키는 대신, null을 반환합니다.
val length = nullableName?.length
```

이처럼 코틀린은 런타임(Runtime)에 터질 NPE 폭탄을 **컴파일(Compile)** 시점에 미리 제거하도록 강제합니다. 이는 특히 복잡한 도메인 로직을 다루는 이커머스 백엔드에서 서비스의 안정성을 보장하는 가장 강력한 무기입니다.

### 3\. 코루틴 (Coroutines): 더 적은 자원으로 더 많은 트래픽을

현대 MSA는 대규모 트래픽을 효율적으로 처리하기 위해 비동기/논블로킹(Async/Non-blocking) 패러다임을 요구합니다. 자바의 `CompletableFuture`나 RxJava 같은 리액티브 프로그래밍은 강력하지만, 콜백 헬(Callback Hell)로 인해 코드가 복잡해지고 가독성이 떨어지는 문제가 있습니다.

코틀린은 \*\*코루틴(Coroutines)\*\*이라는 독보적인 동시성(Concurrency) 모델을 제공합니다. (12장에서 자세히 다룹니다.)

코루틴을 사용하면, 비동기/논블로킹 코드를 마치 **동기식(Blocking) 코드처럼** 쉽고 간결하게 작성할 수 있습니다. 이는 개발 생산성과 시스템 성능이라는 두 마리 토끼를 동시에 잡는 혁신적인 기능입니다.

결론적으로, 코틀린은 자바의 안정성과 JVM 생태계의 강력함을 그대로 유지하면서, 더 간결한 문법(생산성)과 Null 안전성(안정성), 그리고 코루틴(성능)을 제공합니다. 이 책에서 우리는 이 코틀린의 장점들을 100% 활용하여 견고하고 효율적인 MSA를 구축할 것입니다.