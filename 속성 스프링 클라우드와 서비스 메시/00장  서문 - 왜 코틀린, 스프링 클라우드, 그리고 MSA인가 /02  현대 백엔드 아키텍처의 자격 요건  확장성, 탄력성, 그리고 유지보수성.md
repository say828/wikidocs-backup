## 현대 백엔드 아키텍처의 자격 요건: 확장성, 탄력성, 그리고 유지보수성

우리가 구축하려는 이커머스 플랫폼은 오늘 100명의 사용자를 처리하지만, 내일은 블랙 프라이데이 이벤트로 100만 명의 동시 접속자를 감당해야 할 수도 있습니다. 비즈니스는 예측 불가능하게 성장하며, 백엔드 아키텍처는 이 성장을 가로막는 '병목'이 아니라 성장을 가속하는 '엔진'이 되어야 합니다.

과거의 아키텍처가 '기능 구현'에 집중했다면, 현대의 '클라우드 네이티브(Cloud Native)' 아키텍처는 다음 세 가지를 필수 자격 요건으로 요구합니다.

### 1. 확장성 (Scalability)

* **수직 확장 (Scale-Up):** 기존 서버의 CPU나 메모리를 증설하는 방식입니다. 간단하지만, 물리적인 한계가 명확하고 비용이 기하급수적으로 증가합니다. 모놀리스 아키텍처가 주로 선택하는 방식입니다.
* **수평 확장 (Scale-Out):** 동일한 애플리케이션을 실행하는 서버의 '개수'를 늘리는 방식입니다. 클라우드 환경의 핵심이며, 사실상 무한대에 가까운 확장이 가능합니다.

MSA는 '수평 확장'을 극단적으로 추구하는 아키텍처입니다. '주문' 서비스에 트래픽이 몰리면 '주문' 서비스만 독립적으로 100대로 늘리고, 상대적으로 트래픽이 적은 '회원' 서비스는 3대만 유지하는 식의 유연한 대응이 가능합니다. 이 책 전반에 걸쳐 `Kubernetes`의 `HPA(Horizontal Pod Autoscaler)`를 통해 이 개념을 실제로 구현할 것입니다.

### 2. 탄력성 (Resilience)

과거에는 '장애가 발생하지 않는(Fail-safe)' 시스템을 목표로 했습니다. 하지만 수백, 수천 개의 분산된 서비스로 구성된 MSA 환경에서 장애는 '예외'가 아닌 '일상'입니다.

현대 아키텍처의 목표는 '장애가 발생하더라도 서비스 전체가 중단되지 않는(Fail-over)' 시스템, 즉 **탄력성**을 확보하는 것입니다.

* 이커머스에서 '상품 리뷰' 서비스가 장애가 나더라도, 고객은 '주문'을 할 수 있어야 합니다.
* '결제' 서비스가 일시적으로 응답이 느려지더라도, 이 장애가 '주문' 서비스나 'API 게이트웨이'까지 전파되어 시스템 전체가 마비되는 '장애 전파(Cascading Failure)'를 막아야 합니다.

우리는 이 책에서 `Resilience4j`의 `서킷 브레이커(Circuit Breaker)` 패턴을 통해 서비스 간의 장애를 격리하고(06장), `Istio(서비스 메시)`를 통해 이 탄력성을 코드 밖(플랫폼 레벨)으로 외부화하는 과정(22장)을 심도 있게 다룰 것입니다.

### 3. 유지보수성 (Maintainability) & 관찰 가능성 (Observability)

시스템이 거대해질수록 '코드 변경의 영향 범위'를 파악하기 어려워집니다. 모놀리스 아키텍처에서는 간단한 '회원 등급' 로직 변경이 아무 상관없어 보이는 '배송비 계산' 로직에 버그를 유발할 수 있습니다.

* **유지보수성:** DDD(도메인 주도 설계)를 통해 각 서비스의 '책임'과 '경계'(02장)를 명확히 분리함으로써, 우리는 코드 변경의 두려움을 없애고 비즈니스 요구사항에 민첩하게 대응할 수 있습니다.
* **관찰 가능성:** MSA는 수많은 서비스가 상호작용하므로, 장애 발생 시 원인을 추적하기가 매우 어렵습니다. '주문 실패'의 원인이 '주문' 서비스인지, '결제' 서비스인지, 아니면 'Kafka' 메시지 유실인지 어떻게 알 수 있을까요?
    이를 위해 우리는 `분산 로깅`(17장), `메트릭`(18장), 그리고 `분산 추적`(19장)이라는 '관찰 가능성(Observability)의 세 기둥'을 구축하여, 복잡한 MSA 시스템 내부를 손금 보듯 들여다볼 수 있게 만들 것입니다.

이 세 가지 요건(확장성, 탄력성, 유지보수성)은 이 책의 모든 장을 관통하는 핵심 주제이며, 우리가 코틀린과 스프링 클라우드, 그리고 쿠버네티스를 선택한 이유입니다.