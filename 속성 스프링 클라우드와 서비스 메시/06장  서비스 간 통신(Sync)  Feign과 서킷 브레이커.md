# 06장: 서비스 간 통신(Sync): Feign과 서킷 브레이커

## 00. 동기식(Synchronous) 호출의 필요성과 위험성

05장까지 우리는 MSA의 기반을 튼튼히 다졌습니다. 서비스들은 이제 '서비스 디스커버리'를 통해 서로를 찾을 수 있고, '중앙 설정'을 통해 일관된 환경 설정을 갖습니다. 이제 드디어, 이 서비스들이 서로 **'대화'**하는 방법을 배울 시간입니다.

서비스 간의 통신은 크게 '동기식(Synchronous)'과 '비동기식(Asynchronous)'으로 나뉩니다. 이 장에서는 먼저 '동기식' 통신에 집중합니다.

**동기식 통신**이란, 클라이언트(호출하는 서비스)가 서버(호출받는 서비스)에 요청을 보낸 뒤, **서버의 응답이 올 때까지 기다리는(Blocking)** 방식입니다. MSA 환경에서는 주로 HTTP 기반의 REST API 호출이 여기에 해당합니다.

---

### 동기식 호출의 '필요성'

"비동기 통신이 더 발전된 방식 아닌가?"라고 생각할 수 있지만, 동기식 호출은 특정 비즈니스 시나리오에서 **반드시 필요합니다.**

가장 대표적인 예가 바로 우리 이커머스 프로젝트의 **'주문 생성'** 로직입니다.

1.  사용자가 '주문하기' 버튼을 누릅니다.
2.  `order-service`는 요청을 받습니다.
3.  `order-service`는 주문을 DB에 저장하기 **전에**, `product-service`에 **'즉시 물어봐야'** 합니다.
    * "이 상품의 현재 판매 가격은 얼마인가?"
    * "이 상품의 재고는 충분한가?"
4.  `product-service`가 "가격은 10,000원이고, 재고는 충분하다"라고 **즉시 응답**해야만, `order-service`는 그 정보를 바탕으로 주문을 생성하고 사용자에게 "주문이 완료되었습니다"라고 알려줄 수 있습니다.

만약 이 과정이 비동기라면, `order-service`는 재고가 없는 상품에 대한 주문을 생성하는 심각한 오류를 범할 수 있습니다. 이처럼 **요청에 대한 즉각적인 응답(결과)이 있어야만 다음 비즈니스 로직을 진행할 수 있는 경우**, 동기식 호출은 필수적입니다.

---

### 동기식 호출의 '위험성'

동기식 호출은 이처럼 이해하기 쉽고 구현이 간단하지만, 분산 시스템에서는 매우 위험한 '함정'을 내포하고 있습니다.

#### 1. 시간적 결합 (Temporal Coupling)

`order-service`가 `product-service`를 동기식으로 호출한다는 것은, **두 서비스가 반드시 '동시에' 정상적으로 실행 중이어야 함**을 의미합니다. 만약 `product-service`가 배포 중이거나, 장애로 인해 다운되었다면, `order-service`의 '주문 생성' 기능 역시 **함께 실패합니다.** 두 서비스는 시간적으로 강하게 결합되어 있습니다.

#### 2. 성능 저하 및 병목 현상

클라이언트의 성능은 이제 자신이 호출하는 서버의 성능에 직접적인 영향을 받습니다. `product-service`의 응답이 500ms 느려지면, `order-service`의 '주문 생성' API 응답 시간도 똑같이 500ms 느려집니다. 하나의 병목이 전체 시스템의 성능을 저하시킵니다.

#### 3. 장애 전파 (Cascading Failure) - 가장 치명적인 위험

이것이 동기식 MSA가 직면하는 최악의 시나리오입니다.



1.  어떤 이유로 `product-service`가 매우 느려졌다고 가정합시다. (예: DB 쿼리 성능 저하)
2.  `API Gateway`를 통해 `order-service`로 '주문 생성' 요청이 쇄도합니다.
3.  `order-service`의 모든 스레드(Thread)는 `product-service`를 호출하고, 응답이 오지 않자 무한정 **'대기(Blocking)'** 상태에 빠집니다.
4.  순식간에 `order-service`의 스레드 풀(Thread Pool)이 고갈됩니다. 이제 `order-service`는 '주문 생성'뿐만 아니라 '주문 조회' 등 다른 모든 API 요청에도 응답할 수 없는 '먹통' 상태가 됩니다.
5.  이제 장애는 `API Gateway`로 전파됩니다. `Gateway`는 `order-service`를 호출하지만 타임아웃이 발생하고, `Gateway`의 스레드 풀마저 고갈됩니다.
6.  결국, **아무 상관없던 `member-service`로 가는 요청까지 `Gateway`에서 처리되지 못하고, 시스템 전체가 마비됩니다.**

`product-service`라는 단 하나의 서비스의 작은 문제가, 도미노처럼 번져나가 시스템 전체를 붕괴시키는 것. 이것이 바로 **'장애 전파'**의 공포입니다.

---

이러한 위험성 때문에 동기식 호출을 사용하지 말아야 할까요? 아닙니다. **위험성을 '관리'하고 '통제'하는 기술**을 함께 적용해야 합니다.

이 장에서는 먼저, `OpenFeign`을 이용해 동기식 호출을 우아하게 구현하는 방법을 배우고, 이어서 '장애 전파'를 막는 가장 강력한 무기인 **`Resilience4j`의 서킷 브레이커(Circuit Breaker)** 패턴을 적용하여 안전하고 탄력적인(Resilient) 동기식 통신을 완성할 것입니다.