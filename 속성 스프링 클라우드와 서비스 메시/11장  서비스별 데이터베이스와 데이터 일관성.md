# 11장: 서비스별 데이터베이스와 데이터 일관성

## 00. Database per Service 패턴: 왜 서비스마다 DB를 분리해야 하는가?

지금까지 우리는 `order-service`, `product-service` 등 마이크로서비스의 '애플리케이션'을 분리하는 데 집중했습니다. 하지만 진정한 마이크로서비스 아키텍처를 완성하기 위해서는, 반드시 넘어야 할 마지막 관문이 있습니다. 바로 **데이터베이스의 분리**입니다.

**데이터베이스 퍼 서비스(Database per Service)** 패턴은 마이크로서비스 아키텍처의 핵심 원칙 중 하나입니다.

> **"각 마이크로서비스는 자신만의 데이터베이스를 소유하고, 직접 접근을 독점해야 한다."**

즉, `order-service`만이 `orders` DB에 접근할 수 있으며, `product-service`나 다른 어떤 서비스도 `orders` DB에 직접 `SELECT`하거나 `JOIN`해서는 안 됩니다. 데이터가 필요하다면, 반드시 `order-service`가 제공하는 **공식 API를 통해서만** 접근해야 합니다.

---

### 안티패턴: 공유 데이터베이스 (Shared Database)

많은 팀이 MSA를 처음 도입할 때, 애플리케이션은 분리하면서 편의를 위해 데이터베이스는 하나로 공유하는 실수를 저지릅니다.



이 '공유 데이터베이스' 구조는 MSA가 제공하는 거의 모든 이점을 파괴하는 최악의 **안티패턴**입니다.

1.  **극심한 결합도 (Tight Coupling):** 이것이 가장 치명적인 문제입니다. `product-service` 팀이 `products` 테이블의 `price` 컬럼명을 `sales_price`로 변경하고 싶다고 가정해 봅시다. 공유 DB 환경에서는 마음대로 바꿀 수 없습니다. `order-service`나 `recommendation-service`가 이 `price` 컬럼을 직접 읽어가고 있을 수 있기 때문입니다. DB 스키마 변경 하나를 위해 모든 관련 팀이 모여 회의를 하고, 배포 일정을 조율해야 합니다. **서비스의 자율성과 독립적인 배포 능력**이 완전히 사라집니다.

2.  **캡슐화 위반 (Broken Encapsulation):** 데이터베이스 스키마는 서비스의 내부 구현에 해당합니다. 공유 DB는 이 내부 구현을 모든 서비스에 공개하는 것과 같습니다. 서비스들은 더 이상 서로의 API가 아닌, **DB 테이블이라는 불안정한 '비공식적 API'**에 의존하기 시작합니다.

3.  **기술 스택 종속 (Technology Lock-in):** 모든 서비스가 단일 데이터베이스 기술에 종속됩니다. `order-service`는 ACID 트랜잭션을 위해 관계형 데이터베이스(RDBMS)가 필요하지만, `product-service`는 전문 검색 기능과 유연한 스키마를 위해 Elasticsearch나 MongoDB 같은 NoSQL을 사용하고 싶어도 불가능합니다.

---

### Database per Service 패턴의 힘

서비스별로 데이터베이스를 분리하면, 위에서 언급된 모든 문제가 해결됩니다.



1.  **느슨한 결합과 자율성 (Loose Coupling & Autonomy):**
    `product-service` 팀은 이제 다른 팀의 눈치를 보지 않고 자유롭게 `products` DB의 스키마를 변경하거나, 성능 튜닝을 하거나, 심지어 DB를 MySQL에서 MongoDB로 교체할 수도 있습니다. 다른 서비스에 영향을 주는 것은 오직 **공식적으로 약속된 API의 명세(Contract)**뿐입니다. 이것이 진정한 마이크로서비스의 힘입니다.

2.  **폴리글랏 퍼시스턴스 (Polyglot Persistence):**
    '폴리글랏(다국어)'이라는 말처럼, 각 서비스가 자신의 요구사항에 가장 적합한 데이터 저장 기술을 선택할 수 있습니다.
    * `order-service`: 트랜잭션을 위해 **PostgreSQL (RDBMS)** 사용
    * `product-service`: 상품 검색을 위해 **Elasticsearch (검색 엔진)** 사용
    * `member-service`: 세션 관리를 위해 **Redis (인메모리 DB)** 사용

3.  **독립적인 확장 (Independent Scaling):**
    읽기(Read) 트래픽이 몰리는 `product-service`의 DB와 쓰기(Write) 트랜잭션이 중요한 `order-service`의 DB를 서로 다른 사양으로, 독립적으로 확장(Scale-out)할 수 있어 자원을 효율적으로 사용할 수 있습니다.

---

### 새로운 도전 과제

물론, 이 패턴은 '공짜'가 아닙니다. 공유 DB 시절에는 없었던 새로운 문제들을 야기합니다.

* **분산 트랜잭션:** 10장에서 SAGA 패턴으로 해결했던 바로 그 문제입니다.
* **서비스 간 데이터 조인:** `orders` DB와 `products` DB의 데이터를 `JOIN`해야 하는 리포트나 관리자 페이지는 어떻게 만들어야 할까요?
* **데이터 일관성:** `product-service`에서 상품 가격이 변경되었을 때, `order-service`는 어떻게 그 변경 사실을 알 수 있을까요?

Database per Service 패턴은 이러한 문제들을 '만들어내는' 것이 아니라, 분산 시스템이 본질적으로 가지고 있는 문제들을 **'수면 위로 드러내는'** 것입니다. 이 문제들을 해결하는 과정이야말로 MSA를 제대로 구축하는 길입니다.

이 장의 나머지 부분에서는 이 새로운 도전 과제들, 특히 '데이터 일관성' 문제를 해결하기 위한 구체적인 패턴들을 탐구할 것입니다.