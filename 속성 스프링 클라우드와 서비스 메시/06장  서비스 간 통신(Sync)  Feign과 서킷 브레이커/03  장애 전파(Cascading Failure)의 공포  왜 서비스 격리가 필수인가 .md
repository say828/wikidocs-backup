## 장애 전파(Cascading Failure)의 공포: 왜 서비스 격리가 필수인가?

06장 00절에서 우리는 '장애 전파(Cascading Failure)'라는 용어를 소개했습니다. 이 개념은 마이크로서비스 아키텍처(MSA)의 안정성을 이해하는 데 가장 중요하므로, 그 '공포'를 생생하게 느껴볼 필요가 있습니다.

왜 서비스 격리(Service Isolation)가 선택이 아닌 **필수**인지, 레스토랑 주방을 비유로 들어 설명해 보겠습니다. 🧑‍🍳

***

### 바쁜 레스토랑 주방 (우리의 MSA 시스템)

* **주방 전체**: 우리의 전체 MSA 시스템
* **각 요리 스테이션**: 각 마이크로서비스 (`주문 스테이션`, `그릴 스테이션`, `샐러드 스테이션` 등)
* **웨이터**: 요청을 처리하는 스레드(Thread)

#### 정상적인 상황

1.  손님이 '스테이크 정식'을 주문합니다. (`주문` API 요청)
2.  **웨이터**(스레드)가 주문서를 받아 **'그릴 스테이션'**(`상품` 서비스)으로 갑니다. (동기식 Feign 호출)
3.  웨이터는 그릴 스테이션 앞에서 스테이크가 나올 때까지 **기다립니다.** (스레드 블로킹)
4.  그릴 스테이션의 요리사가 1분 만에 스테이크를 구워 전달합니다.
5.  웨이터는 스테이크를 받아 주문을 완성하고 손님에게 서빙합니다.

모든 것이 빠르고 효율적으로 동작합니다.

---

## 장애 전파 시나리오: 그릴 스테이션의 문제



1.  **장애 발생**: '그릴 스테이션'(`상품` 서비스)의 가스가 거의 떨어져 스테이크가 익는 데 1분이 아니라 30분이 걸리기 시작합니다. (서비스 지연 발생)

2.  **첫 스레드 고갈**: 첫 번째 웨이터가 스테이크를 주문하고, 그릴 스테이션 앞에서 **30분 동안 꼼짝도 못 하고 기다립니다.** 이 웨이터는 다른 테이블의 주문을 받거나, 물을 가져다주는 등 다른 어떤 일도 할 수 없습니다. (첫 번째 스레드 블로킹)

3.  **스레드 풀 고갈**: 연이어 스테이크 주문이 들어옵니다. 두 번째, 세 번째, 네 번째 웨이터... 레스토랑의 **모든 웨이터가 그릴 스테이션 앞에 길게 줄을 서서 하염없이 기다리기 시작합니다.** (`주문` 서비스의 스레드 풀 고갈)

4.  **시스템 전체 마비**: 바로 그때, 새로운 손님이 들어와 아주 간단한 **'샐러드'**만 주문합니다.
    * 웨이터는 주문을 받았지만, '샐러드 스테이션'(`회원` 서비스, 정상 상태)으로 갈 수가 없습니다. 그릴 스테이션으로 가는 길이 다른 모든 웨이터들로 완전히 막혀있기 때문입니다.
    * 결국 샐러드 주문조차 처리되지 못하고, 레스토랑 전체가 마비됩니다.

이것이 바로 장애 전파의 공포입니다. **'그릴 스테이션'(`상품` 서비스) 하나의 문제가, 아무 상관없던 '샐러드 스테이션'(`회원` 서비스)의 기능까지 모두 정지시키고 레스토랑 전체를 멈추게 만들었습니다.**

---

## 해결책: 서비스 격리 ("웨이터의 현명한 포기")

만약 레스토랑에 이런 규칙이 있었다면 어땠을까요?

> **"어떤 스테이션에서든 5분 이상 응답이 없으면, 웨이터는 즉시 기다리는 것을 '포기'하고, 주방 매니저에게 '그릴 스테이션에 문제가 발생했다'고 보고한 뒤, 다른 업무를 수행하라."**

이 규칙이 바로 **서비스 격리(Service Isolation)**의 핵심 아이디어입니다.

* **실패의 빠른 인지**: 웨이터는 5분만 기다리고 즉시 실패를 인지합니다. (Fail Fast)
* **자원 보호**: 기다림을 포기한 웨이터는 다른 샐러드 주문을 처리할 수 있습니다. 레스토랑의 나머지 기능은 정상적으로 동작합니다.
* **장애 격리**: '그릴 스테이션'의 문제는 그 스테이션만의 문제로 **격리**됩니다. 다른 스테이션으로 장애가 전파되지 않습니다.
* **회복 기회 제공**: 문제가 생긴 그릴 스테이션에 더 이상 웨이터들이 몰려들지 않으므로, 요리사는 압박 없이 문제를 해결할 시간을 벌 수 있습니다.

동기식 통신을 사용하는 MSA에서, 이처럼 하나의 서비스 장애가 다른 서비스로 전파되지 않도록 막는 '지능적인 퓨즈' 메커니즘은 **선택이 아닌 필수**입니다. 다음 절에서는 이 '서비스 격리'를 구현하는 가장 대표적인 패턴인 **서킷 브레이커(Circuit Breaker)**를 알아보겠습니다.