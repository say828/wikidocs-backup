# 07장: 비동기 통신(Async): 이벤트 기반 아키텍처(EDA)의 서막

## 00. 왜 모든 통신이 동기식이면 안 되는가? (Why)

06장에서 우리는 `OpenFeign`과 `Resilience4j`를 통해 안정적인 동기식(Synchronous) 통신 모델을 구축했습니다. '주문 생성' 시 '상품 재고'를 실시간으로 확인하는 것처럼, 즉각적인 응답이 필수적인 업무에서 동기 통신은 매우 강력하고 직관적인 해결책입니다.

그렇다면, 우리 이커머스 시스템의 **모든 서비스 간 통신**을 동기식 Feign 호출로 구현하면 어떨까요?

'주문 결제가 완료'된 직후의 시나리오를 상상해 봅시다.

1.  `order-service`는 `payment-service`를 동기 호출하여 결제를 성공시킵니다. (여기까지는 좋음)
2.  결제가 성공했으므로, `order-service`는 **순차적으로** 다음 서비스들을 동기 호출해야 합니다.
    * `shipping-service`에 '배송 시작'을 요청합니다.
    * `member-service`에 '포인트 적립'을 요청합니다.
    * `notification-service`에 '주문 완료 이메일 발송'을 요청합니다.
    * ... (향후 '데이터 분석 서비스'에 통계 전송 요청 추가...)

이 아키텍처는 심각한 문제들을 내포하고 있습니다.

---

### 1. 극심한 시간적 결합 (Strong Temporal Coupling)

만약 이 과정에서 **`notification-service`(이메일 발송)가 일시적으로 다운**되거나 느려지면 어떻게 될까요?

* `order-service`는 `notification-service`를 호출하고 응답이 올 때까지 하염없이 **대기(Blocking)**합니다.
* 서킷 브레이커가 작동하여 호출이 실패하더라도, '결제'라는 핵심 트랜잭션은 성공했는데도 사용자에게는 **"알 수 없는 오류가 발생했습니다"**라는 최종 실패 응답을 보낼 수 있습니다.
* 사용자는 결제가 안 된 줄 알고 **'재주문'**을 시도하여, '중복 결제'라는 치명적인 문제를 야기할 수 있습니다.

'이메일 발송'이라는, 상대적으로 중요도가 낮은 **비핵심 기능의 장애**가, '결제'라는 **가장 중요한 핵심 기능**의 성공을 가로막았습니다. 서비스들이 서로의 발목을 잡는 구조가 된 것입니다.

### 2. 낮은 회복탄력성 (Poor Resilience)

만약 `notification-service`가 다운된 상태에서 동기 호출이 실패하면, '주문 완료 이메일'은 **영원히 유실됩니다.** `order-service`가 이 실패한 '이메일 발송' 작업을 기억했다가 나중에 재시도하는 복잡한 로직을 직접 구현하지 않는 한, 복구할 방법이 없습니다.

### 3. 떨어지는 확장성 (Limited Scalability)

`order-service`의 스레드는 결제, 배송, 포인트, 알림 등 모든 동기 호출이 끝날 때까지 붙잡혀 있습니다. 이는 '주문'이라는 단일 요청이 시스템의 자원을 매우 오랜 시간 점유한다는 의미이며, 시스템 전체가 처리할 수 있는 **초당 주문 수(Throughput)에 심각한 병목**이 됩니다.

---

### 해답: 비동기 이벤트 기반 통신

이 문제들을 해결하기 위해, 우리는 "결제가 완료되었다"는 **'사실(Fact)'** 또는 **'사건(Event)'**을 비동기적으로 전달하는 방식을 도입해야 합니다.



**개선된 시나리오:**
1.  `order-service`는 `payment-service`를 동기 호출하여 결제를 성공시킵니다.
2.  `order-service`는 **`OrderPaidEvent`**("주문 결제가 완료되었음")라는 '이벤트'를 **메시지 큐(Message Queue)**라는 중앙 우체통에 던져 넣습니다.
3.  `order-service`의 역할은 **여기서 끝**입니다. 즉시 사용자에게 "고객님의 주문 및 결제가 성공적으로 완료되었습니다!"라고 응답을 보냅니다. 사용자는 1초 안에 빠른 응답을 받습니다.
4.  그 후, 메시지 큐에 관심 있던 다른 서비스들이 **'독립적으로'** 그리고 **'비동기적으로'** 이 이벤트를 가져가서 각자의 일을 처리합니다.
    * `shipping-service`가 이벤트를 보고 '배송'을 시작합니다.
    * `member-service`가 이벤트를 보고 '포인트'를 적립합니다.
    * `notification-service`가 이벤트를 보고 '이메일'을 발송합니다.

이 구조에서는 `notification-service`가 한 시간 동안 다운되어 있어도 아무런 문제가 없습니다. `order-service`는 이미 성공 응답을 보냈고, `OrderPaidEvent`는 메시지 큐에 안전하게 보관되어 있다가 `notification-service`가 다시 살아났을 때 전달될 것입니다.

**결론:**
동기 통신은 '즉각적인 응답이 필요한 강한 결합'에, **비동기 통신**은 **'결과를 즉시 알 필요 없는 느슨한 결합'**에 사용됩니다.

이 두 가지 통신 방식을 비즈니스 시나리오에 맞게 적절히 조합하는 것이 MSA를 성공으로 이끄는 핵심입니다. 이 장에서는 비동기 통신의 심장인 '메시지 큐'와 이를 스프링에서 우아하게 사용하는 `Spring Cloud Stream`에 대해 배울 것입니다.