# 10장: 분산 트랜잭션의 성배: SAGA 패턴

## 00. MSA 환경에서의 트랜잭션: 왜 2PC(Two-Phase Commit)는 답이 아닌가?

03장에서 우리는 모놀리스의 장점 중 하나로 **ACID 트랜잭션**의 단순함을 꼽았습니다. `@Transactional` 어노테이션 하나면, 여러 테이블(`orders`, `products`, `members`)에 걸친 데이터 변경 작업을 '모두 성공'시키거나 '모두 실패(롤백)'시키는 원자성(Atomicity)을 손쉽게 보장할 수 있었습니다.

하지만 마이크로서비스 아키텍처에서는 이것이 불가능합니다. `order-service`, `payment-service`, `product-service`는 각각 **자신만의 독립적인 데이터베이스**를 가지고 있습니다. 네트워크로 분리된 여러 데이터베이스에 걸쳐 단일 ACID 트랜잭션을 적용할 수 있는 마법은 없습니다.

이것이 바로 MSA가 직면하는 가장 어렵고 중요한 문제, **'분산 트랜잭션(Distributed Transaction)'**입니다.

'주문 생성'이라는 핵심 비즈니스 흐름을 다시 생각해 봅시다.
1.  **[Order Service]** `orders` DB에 `Order`를 `PENDING` 상태로 생성합니다. (트랜잭션 1)
2.  **[Payment Service]** `payments` DB에 `Payment` 기록을 남기고 외부 PG 결제를 성공시킵니다. (트랜잭션 2)
3.  **[Product Service]** `products` DB의 `재고(Stock)`를 차감합니다. (트랜잭션 3)

만약 1, 2번은 성공했는데, 3번 '재고 차감' 단계에서 네트워크 오류나 DB 장애로 실패하면 어떻게 될까요? 고객의 돈은 받아 갔는데, 재고가 차감되지 않아 상품을 보낼 수 없는 **데이터 불일치 상태**에 빠집니다. 우리는 2번 '결제'를 '롤백'(취소)해야만 합니다.

---

### 전통적인 해법: 2PC (Two-Phase Commit)

이 문제를 해결하기 위한 고전적인 컴퓨터 과학 알고리즘이 바로 **2PC (2단계 커밋)**입니다. 2PC는 **'트랜잭션 코디네이터(Transaction Coordinator)'**라는 중앙 관리자를 통해 모든 참여자(마이크로서비스)의 트랜잭션을 원자적으로 커밋하거나 롤백합니다.

**결혼식 비유: 👰🤵**
* **코디네이터:** 주례
* **참여자:** 신랑(`payment-service`), 신부(`product-service`)

1.  **1단계: 준비 단계 (Prepare Phase / 투표)**
    * 주례(코디네이터)가 신랑과 신부에게 묻습니다. "결혼을 약속할 준비가 되었습니까?" (`prepare` 요청)
    * 신랑과 신부(참여자)는 "네, 준비되었습니다"라고 대답하고 **서약서에 사인할 준비**를 합니다. 이 순간부터는 변심할 수 없습니다. (`DB 리소스 Lock`)
2.  **2단계: 커밋 단계 (Commit Phase / 실행)**
    * 주례(코디네이터)는 **모두가 '준비 완료'라고 답한 것을 확인**한 뒤, "이제 두 사람은 부부가 되었음을 선포합니다!"라고 외칩니다. (`commit` 요청)
    * 그제서야 신랑과 신부는 서약서에 최종 사인을 합니다. (트랜잭션 커밋)
    * 만약 1단계에서 단 한 명이라도 '아니오'라고 했다면, 주례는 결혼 무효를 선언(`abort` 요청)하고 모두 없었던 일로 돌아갑니다. (트랜잭션 롤백)

---

### 왜 2PC는 현대 MSA에 답이 아닌가?

이론적으로 완벽해 보이는 2PC는 현대 마이크로서비스 환경에서는 다음과 같은 치명적인 단점 때문에 거의 사용되지 않습니다.

1.  **동기식 블로킹 (Synchronous Blocking): 致命的**
    * 이것이 2PC를 사용하지 않는 가장 큰 이유입니다. 1단계(Prepare)에서 '준비 완료' 응답을 보낸 모든 서비스는, 코디네이터로부터 최종 `commit` 또는 `abort` 신호를 받을 때까지 **관련된 모든 DB 리소스(테이블, 로우)를 `Lock` 상태로 대기**해야 합니다.
    * 네트워크 지연이 심한 분산 환경에서 이 `Lock` 대기 시간은 수 초 이상 길어질 수 있습니다. '재고' 테이블이 `Lock` 걸려있는 동안, 다른 모든 '주문' 요청은 하염없이 기다려야 합니다. 이는 **시스템 전체의 처리량(Throughput)과 성능을 극단적으로 저하시킵니다.**

2.  **코디네이터의 단일 실패 지점 (SPOF):**
    * 만약 코디네이터가 1단계는 성공적으로 마쳤는데, 2단계 `commit` 신호를 보내기 직전에 다운되면 어떻게 될까요? 모든 참여자 서비스들은 자신들의 DB 리소스를 `Lock`한 채로 코디네이터가 다시 살아나기만을 기다리는 **'불확실한(in-doubt)' 상태**에 빠져 영원히 멈출 수도 있습니다.

3.  **'CAP 이론'과의 충돌:**
    * 분산 시스템은 일관성(Consistency), 가용성(Availability), 분할 허용성(Partition Tolerance) 중 최대 2가지만을 동시에 만족시킬 수 있다는 이론입니다.
    * 2PC는 **강력한 일관성(C)**을 선택하는 대신, 블로킹으로 인해 **가용성(A)을 희생**하는 전략입니다. 하지만 대부분의 MSA는 일시적인 데이터 불일치를 감수하더라도, 서비스가 멈추지 않는 **'높은 가용성(A)'**을 더 중요하게 여깁니다.

결론적으로, 2PC는 마이크로서비스의 핵심 철학인 '느슨한 결합(Loose Coupling)'과 '높은 가용성'에 정면으로 위배됩니다.

우리는 강력한 일관성을 포기하고, 대신 '최종 일관성(Eventual Consistency)'을 목표로 하는 다른 접근 방식이 필요합니다. 그 해답이 바로 이 장의 주제인 **SAGA 패턴**입니다.