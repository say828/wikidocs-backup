# 03장: 모놀리스에서 시작하기: 첫 번째 서비스 '회원 API' 구축

## 00. 모놀리스 아키텍처의 장점과 명확한 한계점

이 책의 최종 목표는 '마이크로서비스 아키텍처(MSA)'를 구축하는 것입니다. 그런데 왜 03장의 제목은 '모놀리스(Monolith)에서 시작하기'일까요?

이는 매우 의도적인 교육적 선택입니다. 많은 개발팀이 MSA의 '장점'만 보고 섣불리 도입했다가, 분산 시스템의 복잡성이라는 거대한 벽에 부딪혀 좌절합니다. MSA는 '은제 탄환(Silver Bullet)'이 아니며, 그에 상응하는 막대한 비용(복잡성, 운영 오버헤드)을 요구합니다.

가장 좋은 아키텍처 학습법은, **모놀리스의 한계를 직접 '체감'하고, 그 '고통'을 해결하기 위한 명확한 '이유'를 가지고 MSA로 진화하는 것**입니다. 이것이 바로 "모놀리스 퍼스트(Monolith First)" 전략입니다.

---

### 모놀리스 아키텍처의 장점 (Why we start here)

모놀리스는 하나의 거대한 코드베이스(Codebase)와 하나의 결과물(예: `app.jar`)로 모든 비즈니스 로직(회원, 상품, 주문...)을 처리하는 구조입니다. 특히 프로젝트 초기에 강력한 장점들을 제공합니다.

1.  **개발 단순성 (Simplicity):**
    * **단일 코드베이스:** IDE(IntelliJ) 하나에서 모든 코드를 관리할 수 있습니다. `OrderService`가 `MemberService`를 호출하는 것은 단순한 '메서드 호출'일 뿐, 네트워크 통신을 고민할 필요가 없습니다.
    * **쉬운 리팩토링:** `Member` 클래스의 필드명을 변경하면, 이 클래스를 참조하는 `Order` 코드까지 IDE가 한 번에 찾아 안전하게 수정해 줍니다.
    * **로컬 테스트:** `app.jar` 파일 하나와 DB 하나만 실행하면 전체 시스템이 동작하므로, 로컬 환경에서 테스트하기가 매우 쉽습니다.

2.  **배포 용이성 (Easy Deployment):**
    * 빌드 결과물(`jar` 또는 `war`)이 단 하나입니다. 이 파일 하나만 서버에 복사하고 실행하면 배포가 끝납니다. CI/CD 파이프라인이 극도로 단순해집니다.

3.  **성능 (Performance):**
    * 모든 로직이 같은 프로세스(JVM) 내부에서 실행됩니다. MSA처럼 서비스 간의 HTTP/gRPC 네트워크 호출에서 발생하는 '지연 시간(Latency)'이 전혀 없습니다.

4.  **데이터 일관성 (Strong Consistency):**
    * 단일 데이터베이스(Single Database)를 사용하므로, ACID 트랜잭션을 활용하기가 매우 쉽습니다. '주문' 생성 시 '회원' 등급을 업데이트하고 '상품' 재고를 차감하는 로직을 **하나의 DB 트랜잭션**으로 묶어 강력한 데이터 일관성을 손쉽게 보장할 수 있습니다. (MSA에서는 10장 SAGA 패턴 같은 복잡한 기술이 필요합니다.)

---

### 모놀리스 아키텍처의 명확한 한계점 (Why we leave)

우리의 이커머스 비즈니스가 성공하여 '회원 100만 명, 일일 주문 100만 건' 수준으로 성장했다고 가정해 봅시다. 이제 모놀리스의 장점은 모두 '한계점'으로 돌변합니다.

1.  **확장성의 한계 (Scalability):**
    * '블랙 프라이데이' 세일로 인해 '주문' 기능에만 트래픽이 몰려도, 우리는 '주문' 기능만 독립적으로 확장(Scale-out)할 수 없습니다.
    * CPU 집약적인 '상품 추천' 로직과 메모리 집약적인 '회원 캐시' 로직이 뒤섞인 **거대한 모놀리스 전체를 통째로** 복제해서 배포해야 합니다. 이는 막대한 자원 낭비입니다.

2.  **유지보수성의 저하 (Maintainability):**
    * 코드베이스가 너무 커져 '**진흙탕 괴물(Big Ball of Mud)**'이 됩니다. 코드 간의 의존성을 파악하기 불가능해집니다.
    * 간단한 버그 수정에도 시스템의 어느 부분이 터질지 몰라(Side Effect) 두려워집니다.
    * 빌드 및 테스트 시간이 수십 분 이상 걸리게 되어 개발 속도가 급격히 저하됩니다.

3.  **기술 스택의 종속 (Technology Lock-in):**
    * 모든 기능이 코틀린/스프링/JPA라는 하나의 기술 스택에 묶입니다.
    * '상품 추천' 기능만 파이썬(Python)과 머신러닝 라이브러리를 도입하고 싶어도, 전체 모놀리스 구조를 바꾸지 않는 한 불가능합니다.

4.  **배포의 위험성 (Deployment Risk):**
    * **이것이 가장 치명적입니다.** 중요도 낮은 '상품 리뷰' 기능의 사소한 버그 하나가, 전체 JVM 프로세스를 죽여서 **시스템 전체(주문, 결제 포함)를 마비**시킬 수 있습니다.
    * 배포 위험이 너무 크기 때문에, '일주일에 한 번' 배포하기도 두려워집니다. (MSA는 '하루에 수십 번' 배포를 목표로 합니다.)

5.  **팀 조직의 병목 (Team Bottleneck):**
    * '주문팀', '상품팀', '회원팀' 모두가 **단 하나의 코드베이스**에 코드를 커밋(Commit)합니다.
    * 서로의 코드가 충돌(Conflict)하고, 하나의 '배포 파이프라인'을 통과하기 위해 병목 현상이 발생하며, 팀의 민첩성(Agility)과 자율성이 사라집니다.

---

우리는 이 장에서 먼저 '모놀리스'의 장점을 누리며 `회원 API`를 빠르게 구축할 것입니다. 그리고 03장 04절에서 '상품'과 '주문' 기능을 이 모놀리스에 추가하면서 위에서 언급한 '한계점'들이 어떻게 우리의 발목을 잡는지 직접 경험해 볼 것입니다.