## 모놀리스의 고통: '상품'과 '주문' 기능을 추가할 때 발생하는 문제점 분석

우리는 03장 03절까지 '회원(Member)' API라는 작고 잘 정의된 모놀리스를 성공적으로 구축하고 테스트했습니다. 이 상태만 놓고 보면 모놀리스는 완벽해 보입니다.

이제, 비즈니스 요구사항에 따라 이 모놀리스에 \*\*'상품(Product)'\*\*과 **'주문(Order)'** 기능을 **'같은 코드베이스'에** 추가한다고 가정해 봅시다.

`ProductController`, `ProductService`, `ProductRepository`, `Product` 엔티티...
`OrderController`, `OrderService`, `OrderRepository`, `Order`, `OrderLine` 엔티티...

이 코드들을 기존 `com.ecommerce.member` 패키지 옆에 `com.ecommerce.product`, `com.ecommerce.order` 패키지를 만들어 추가하기 시작합니다. 바로 이 순간, 모놀리스의 '명확한 한계점'들이 '고통'이 되어 우리를 덮치기 시작합니다.

-----

### 문제점 1: '진흙탕 괴물' (Big Ball of Mud) - 도메인 결합

`OrderService`는 '주문 생성' 로직을 구현해야 합니다. 이 로직은 02장에서 정의한 대로 '상품'의 재고를 확인하고 '회원'의 포인트를 적립해야 합니다.

모놀리스 환경에서 개발자는 가장 쉽고 빠른 길을 택하게 됩니다.

```kotlin
// /src/main/kotlin/com/ecommerce/order/OrderService.kt (가상)
@Service
class OrderService(
    private val orderRepository: OrderRepository,
    
    // ⛔️ 치명적인 결합 (TIGHT COUPLING) ⛔️
    private val productRepository: ProductRepository, 
    private val memberRepository: MemberRepository
) {
    @Transactional
    fun createOrder(memberId: Long, request: CreateOrderRequest) {
        
        // 1. '주문' 도메인이 '회원' 도메인의 Repository를 직접 참조
        val member = memberRepository.findByIdOrNull(memberId) ?: ...

        // 2. '주문' 도메인이 '상품' 도메인의 Repository를 직접 참조
        val product = productRepository.findByIdOrNull(request.productId) ?: ...
        
        // 3. '상품' 엔티티의 내부 로직(재고)을 '주문' 서비스가 직접 수정
        product.decreaseStock(request.quantity)
        // ⛔️ productRepository.save(product) -> 이건 언제 호출?
        
        // 4. '회원' 엔티티의 내부 로직(포인트)을 '주문' 서비스가 직접 수정
        member.addPoints(request.totalAmount * 0.01)
        // ⛔️ memberRepository.save(member) -> 이건 언제 호출?
        
        val order = Order(...)
        orderRepository.save(order)
    }
}
```

02장에서 '청사진'으로 그렸던 **바운디드 컨텍스트(BC) 간의 명확한 경계가 코드 레벨에서 완전히 무너졌습니다.**

  * **책임의 실종:** `OrderService`가 `Product`와 `Member`의 비즈니스 로직(재고 차감, 포인트 적립)까지 모두 알아야 합니다.
  * **강한 결합:** 만약 `Product` 팀이 `Product` 엔티티의 `decreaseStock` 메서드 시그니처를 변경하는 순간, 아무 상관없어 보이는 `OrderService` 코드가 컴파일조차 되지 않습니다.
  * **유지보수 지옥:** `member-service`로 시작했던 이 프로젝트는 이제 `ecommerce-service`라는 '진흙탕 괴물'이 되었습니다. 신입 개발자는 이 거대한 코드 덩어리 속의 복잡한 상호 의존성을 파악하는 데만 몇 달을 소모할 것입니다.

-----

### 문제점 2: '단일 DB의 저주' - 트랜잭션 결합

위 코드의 더 심각한 문제는 `@Transactional`입니다.

모놀리스의 장점은 '단일 DB 트랜잭션'이라고 했습니다. 하지만 이는 곧 '저주'가 됩니다. `createOrder` 메서드는 **단 하나의 거대한 트랜잭션** 하에서 실행됩니다.

이 트랜잭션은 `orders` 테이블, `products` 테이블, `members` 테이블에 동시에 `Row-Level Lock`을 설정할 수 있습니다.

**시나리오:**

1.  `User A`가 `createOrder` (주문 생성) API를 호출합니다. (트랜잭션 1 시작)
2.  `products` 테이블의 '나이키 티셔츠' Row에 `Lock`이 걸립니다.
3.  `User B`가 '나이키 티셔츠'의 '상품 설명'을 수정하는 API( `productService.updateDescription` )를 호출합니다. (트랜잭션 2 시작)
4.  `User B`의 트랜잭션 2는 `User A`의 트랜잭션 1이 끝날 때까지 `products` 테이블의 `Lock`이 풀리기를 하염없이 기다립니다. (DB 블로킹 발생)

'주문'이라는 핵심 로직이 '상품 설명 수정'이라는 사소한 비핵심 로직의 성능에까지 직접적인 악영향을 미칩니다. 시스템 전체의 처리량(Throughput)이 급격히 저하됩니다.

-----

### 문제점 3: '비효율적인 확장' - 리소스 결합

03장 00절에서 언급한 이론적인 문제가 이제 현실이 됩니다.

우리의 '상품' 기능에 '실시간 인기 검색어' 기능이 추가되어 CPU 사용량이 폭증했다고 가정합시다. 이 기능을 확장하기 위해 우리는 `ecommerce-service.jar`를 10대 더 배포해야 합니다.

그 결과, 거의 사용되지 않는 `MemberService` 로직과 메모리만 차지하는 `Member` 캐시까지 10배로 복제되는 막대한 자원 낭비가 발생합니다.

-----

이 '고통'을 분석한 결과, 우리의 결론은 명확합니다.

'회원', '상품', '주문'은 **서로 다른 생명주기, 서로 다른 성능 요구사항, 서로 다른 비즈니스 책임**을 가집니다. 이들을 하나의 모놀리스에 묶어두는 것은 재앙을 초래할 뿐입니다.

우리는 이 '고통'을 해결하기 위해, 지금이라도 '진흙탕 괴물'이 되는 것을 멈추고 02장의 DDD '청사진'으로 돌아가야 합니다.