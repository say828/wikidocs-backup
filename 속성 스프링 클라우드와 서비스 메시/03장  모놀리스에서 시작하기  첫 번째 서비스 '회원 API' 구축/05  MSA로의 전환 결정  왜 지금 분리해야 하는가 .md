## MSA로의 전환 결정: 왜 지금 분리해야 하는가?

03장 04절에서 분석한 '모놀리스의 고통'은 단순한 이론이 아닙니다. `상품`과 `주문` 기능을 `회원` 코드베이스에 추가하는 순간 우리가 겪게 될 **명백한 미래**입니다.

우리는 지금 '갈림길'에 서 있습니다.

* **선택 1 (모놀리스 유지):** 개발의 '편의성'을 위해 이대로 `상품`과 `주문` 코드를 추가한다. 6개월 뒤, 아무도 손대지 못하는 '진흙탕 괴물(Big Ball of Mud)'을 떠안고, 성능 저하와 배포 장애로 고통받는다.
* **선택 2 (MSA로의 전환):** 지금이 '고통'을 막을 수 있는 마지막 골든타임임을 인정한다. 02장에서 설계한 DDD '청사진'이 왜 필요했는지 다시 상기하고, **즉시 마이크로서비스 아키텍처로의 전환을 결정한다.**

이 책의 저자이자 수석 아키텍트로서, 우리는 **선택 2**를 결정합니다.

---

### 왜 '지금' 분리해야 하는가? (Why Now?)

"아직 서비스가 크지도 않은데 너무 이른 결정 아닌가?"라고 반문할 수 있습니다. 그렇지 않습니다. '모놀리스 퍼스트(Monolith First)' 전략의 핵심은 '모놀리스가 거대해질 때까지 기다리는 것'이 아니라, **'도메인의 경계가 명확해지는 첫 순간에 분리하는 것'**입니다.

02장의 DDD 설계를 통해, 우리는 이미 '회원', '상품', '주문'의 경계가 명확히 다르다는 것을 알고 있습니다. '회원' API를 완성하고 '상품/주문'을 설계하는 '지금'이 바로 그 순간입니다.

**1. 비용의 문제: '기술 부채'는 이자가 붙는다**
지금 `member-service`에서 `product-service`를 분리하는 비용은 10입니다. 하지만 1년 뒤, 두 도메인이 스파게티처럼 얽힌 '진흙탕 괴물'에서 `product-service`를 분리하는 비용은 1000입니다. '기술 부채(Technical Debt)'는 복리로 쌓입니다. 우리는 가장 이자가 쌀 때 이 부채를 갚아야 합니다.

**2. 고통의 증명: 이미 설계가 불가능하다**
03장 04절에서 보았듯, 우리는 `OrderService`가 `ProductRepository`와 `MemberRepository`를 직접 참조하는 '나쁜 설계' 외에는 뾰족한 수가 없음을 이미 확인했습니다. 도메인 결합과 트랜잭션 결합 문제는 **코드를 짜기 전, 설계 단계에서부터 이미 명백해졌습니다.** 이 설계가 잘못되었음을 안다면, 코드를 작성해서는 안 됩니다.

**3. 전략적 우선순위: '핵심 도메인'의 분리**
02장 04절에서 우리는 '주문'과 '상품'을 **핵심 도메인(Core Domain)**으로, '회원'을 **지원 서브 도메인(Supporting Subdomain)**으로 식별했습니다. 핵심 도메인은 가장 많은 변경과 가장 높은 성능을 요구합니다. 이 핵심 도메인을 지원 도메인과 같은 모놀리스에 묶어두는 것은, 우리의 '핵심 경쟁력'에 '족쇄'를 채우는 것과 같습니다.

---

### 전환 결정: 그리고 새로운 질문들

우리는 이 `member-service`를 우리의 **첫 번째 마이크로서비스**로 삼고, '상품'과 '주문' 기능은 **별개의 새로운 마이크로서비스**로 구축할 것을 결정합니다.

이 결정은 03장의 '고통'을 해결하는 동시에, 모놀리스 시절에는 겪어보지 못한 **새로운 차원의 문제**들을 눈앞에 가져옵니다.

1.  모놀리스에서는 `localhost:8080` 하나만 호출하면 되었습니다. 이제 `member-service`, `product-service`, `order-service`가 각각 `localhost:8081`, `8082`, `8083`에서 실행됩니다. 클라이언트(앱/웹)는 **이 모든 주소를 다 알아야 할까요?**
2.  사용자가 '주문'을 위해 로그인을 합니다. 이 '인증(Authentication)' 처리는 3개의 서비스에서 **각각 3번 수행해야 할까요?** 어떻게 JWT 같은 인증 토큰을 '한 번'만 검증하고 이 신뢰를 모든 서비스에 전파할 수 있을까요?
3.  '주문' 서비스가 '상품' 정보가 필요할 때, 모놀리스처럼 `productService.getProduct()` 메서드를 호출할 수 없습니다. 이제 **어떻게 네트워크 너머의 다른 서비스를 호출**해야 할까요?

이 새로운 질문들이 바로 04장부터 우리가 해결해야 할 MSA의 '진짜' 과제들입니다.

03장을 마칩니다. 우리는 '모놀리스'라는 안락한 집을 떠나, 'MSA'라는 거칠지만 가능성이 무한한 도시로 첫발을 내디뎠습니다. 이제 이 도시의 '관문(Gateway)'부터 건설할 차례입니다.