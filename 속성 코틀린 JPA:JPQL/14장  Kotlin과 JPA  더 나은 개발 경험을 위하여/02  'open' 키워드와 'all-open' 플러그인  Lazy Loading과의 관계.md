## 02\. 'open' 키워드와 'all-open' 플러그인: Lazy Loading과의 관계

JPA 성능 최적화의 핵심 기술 중 하나는 단연 \*\*지연 로딩(Lazy Loading)\*\*이다. 지연 로딩은 연관된 엔티티를 실제 사용하는 시점까지 조회를 미루는 방식으로, 불필요한 데이터베이스 접근을 막아준다.

그런데 이 지연 로딩의 내부 동작 원리는 코틀린의 기본 철학과 정면으로 충돌하여, 별도의 설정 없이는 런타임 오류를 발생시킨다. 그 이유와 해결책을 알아보자.

-----

### **지연 로딩의 비밀: 프록시(Proxy) 객체**

JPA(하이버네이트)가 지연 로딩을 구현하는 방식은 바로 **프록시(Proxy)** 기술을 사용하는 것이다.
`Member` 엔티티가 `Team` 엔티티를 지연 로딩으로 참조하고 있다고 가정해 보자.

1.  `memberRepository.findById(1L)`를 호출하면, JPA는 `Team` 데이터를 가져오지 않는다.
2.  대신, `member.team` 필드에 실제 `Team` 객체가 아닌, **`Team` 클래스를 상속받아 만들어진 가짜 프록시 객체**를 주입해 둔다.
3.  이후 개발자가 `member.team.name`처럼 프록시 객체의 메서드를 최초로 호출하는 순간, 이 프록시 객체는 자신이 진짜인 척 연기하는 것을 멈추고, 데이터베이스에 `SELECT` 쿼리를 보내 실제 `Team` 객체의 데이터를 가져와 자신을 초기화한다.

**여기서 핵심은 프록시 객체가 '원본 엔티티 클래스를 상속받아' 만들어진다는 점이다.**

-----

### **코틀린의 `final`과 JPA 프록시의 충돌**

자바와 달리, \*\*코틀린의 모든 클래스와 메서드는 기본적으로 `final`\*\*이다. `final` 키워드는 해당 클래스가 더 이상 상속될 수 없음을 의미한다.

이제 문제가 명확해진다.

  * **JPA**: 지연 로딩을 위해 `Team` 클래스를 **상속**받아 프록시 객체를 만들어야 한다.
  * **코틀린**: `Team` 클래스는 기본적으로 \*\*`final`\*\*이라 상속이 불가능하다.

이 충돌로 인해, 아무런 처리도 하지 않은 코틀린 엔티티의 지연 로딩 필드에 접근하면, 하이버네이트는 프록시 객체를 생성할 수 없다는 오류를 뿜어내며 애플리케이션이 멈춰버린다.

-----

### **해결책 1: 수동으로 `open` 키워드 붙이기**

가장 원시적인 해결책은 상속이 필요한 클래스와 메서드에 직접 `open` 키워드를 붙여주는 것이다.

```kotlin
// 수동으로 open 키워드를 추가하는 방식 (번거롭고 비추천)
open class Member(
    // ...
    @ManyToOne(fetch = FetchType.LAZY)
    open var team: Team? = null
)
```

이 방법은 동작은 하지만, 모든 엔티티와 지연 로딩 필드마다 `open`을 붙여야 하는 것은 매우 번거롭고 실수하기 쉽다.

### **해결책 2: `all-open` 플러그인 사용하기 (⭐️ 권장)**

코틀린 진영은 이 문제를 해결하기 위해 **`all-open` 컴파일러 플러그인**을 제공한다. 이 플러그인은 특정 어노테이션이 붙은 클래스와 그 멤버들을 컴파일 시점에 자동으로 `open` 상태로 바꿔주는 마법 같은 역할을 한다.

우리가 00장에서 설정했던 `kotlin("plugin.spring")` 플러그인이 바로 이 `all-open` 플러그인을 스프링 환경에 맞게 미리 설정해 놓은 것이다. 이 플러그인은 `@Component`, `@Service`, `@Transactional`, 그리고 우리가 사용하는 **`@Entity`**, `@MappedSuperclass` 등이 붙은 클래스를 모두 `open`으로 만들어준다.

**`build.gradle.kts`**

```groovy
plugins {
    // ...
    kotlin("plugin.spring") version "1.9.23" // 내부적으로 all-open 플러그인을 포함
}
```

이 플러그인 덕분에, 우리는 `open` 키워드를 전혀 신경 쓰지 않고도 코틀린 클래스를 엔티티로 선언하고 JPA의 지연 로딩을 포함한 모든 기능을 완벽하게 사용할 수 있었던 것이다.

이제 코틀린과 JPA의 근본적인 충돌을 해결했으니, 다음으로는 코틀린의 확장 함수를 사용하여 반복적인 JPA 코드를 어떻게 더 우아하게 개선할 수 있는지 알아보자.