## 01\. `fetch` 전략: EAGER(즉시 로딩) vs. LAZY(지연 로딩)

JPA가 `Member` 엔티티를 조회할 때, 연관된 `Team` 엔티티도 함께 조회해야 할까? 아니면 `member.getTeam()`처럼 실제로 `Team`을 사용하는 시점에 조회해야 할까? 이처럼 연관된 엔티티를 언제 데이터베이스에서 조회할지를 결정하는 옵션이 바로 **페치(Fetch) 전략**이다. JPA는 두 가지 전략을 제공하며, 이 선택은 애플리케이션의 성능에 지대한 영향을 미친다.

-----

### **EAGER: 즉시 로딩 (미리 다 가져와)**

\*\*즉시 로딩(Eager Loading)\*\*은 이름 그대로 엔티티를 조회할 때 연관된 엔티티도 **즉시 함께 조회**하는 전략이다.

`Member`와 `Team`의 관계를 즉시 로딩으로 설정하면, `entityManager.find(Member.class, 1L)`을 호출하는 순간 JPA는 `Member`와 `Team`을 조인(JOIN)하는 SQL을 생성하여 한 번에 모든 데이터를 가져온다.

```kotlin
@ManyToOne(fetch = FetchType.EAGER)
@JoinColumn(name = "team_id")
var team: Team? = null
```

  * **장점**:
      * 연관된 엔티티를 사용할 것이 거의 확실한 경우, 추가 쿼리 없이 데이터를 바로 사용할 수 있어 편리하다.
  * **치명적인 단점**:
      * **불필요한 데이터 로딩**: `Team` 정보가 필요 없는 비즈니스 로직에서도 항상 `Team`을 함께 조회하므로 리소스가 낭비된다.
      * **성능 저하의 주범**: 연관된 엔티티가 많거나 복잡할수록 조인으로 인한 오버헤드가 커진다.
      * **N+1 문제 발생 가능성**: JPQL 사용 시 개발자의 의도와 다르게 동작하며 수많은 추가 쿼리를 유발하는 N+1 문제의 원인이 되기도 한다. (11장에서 자세히 다룬다.)

**즉시 로딩은 사용이 간편해 보이지만, 예측하지 못한 성능 문제를 일으키는 경우가 많아 실무에서는 사용을 기피하는 전략이다.**

-----

### **LAZY: 지연 로딩 (필요할 때 가져와)**

\*\*지연 로딩(Lazy Loading)\*\*은 연관된 엔티티를 실제 사용하는 시점까지 데이터베이스 조회를 미루는 전략이다.

`Member`와 `Team`의 관계를 지연 로딩으로 설정하면, `entityManager.find(Member.class, 1L)`을 호출할 때는 `MEMBER` 테이블만 조회하는 단순한 `SELECT` SQL이 실행된다. JPA는 `member.team` 필드에 실제 `Team` 객체 대신, **프록시(Proxy) 객체**라는 가짜 객체를 넣어둔다.

```kotlin
@ManyToOne(fetch = FetchType.LAZY)
@JoinColumn(name = "team_id")
var team: Team? = null
```

이후 개발자가 `member.getTeam().getName()`처럼 실제로 `team` 객체의 데이터를 사용하려고 **최초로 접근하는 순간**, 프록시 객체는 자신을 초기화하기 위해 데이터베이스에 `SELECT * FROM TEAM WHERE ID = ?` 와 같은 쿼리를 보내 실제 `Team` 데이터를 로딩한다.

  * **장점**:
      * **성능 최적화**: 불필요한 조인을 피하고, 꼭 필요한 시점에만 데이터를 로딩하므로 초기 로딩 속도가 빠르고 시스템 리소스를 효율적으로 사용할 수 있다.
  * **단점**:
      * 연관 엔티티를 사용할 때마다 추가 쿼리가 발생할 수 있다. (N+1 문제의 또 다른 원인이 될 수 있으나, 이는 '페치 조인'으로 제어 가능하다.)
      * 영속성 컨텍스트가 종료된 후(준영속 상태) 프록시 객체를 초기화하려고 하면 `LazyInitializationException` 예외가 발생한다.

-----

### **권장 전략: 모든 연관관계는 LAZY로 설정하라**

JPA의 기본 페치 전략은 다음과 같다.

  * `@ManyToOne`, `@OneToOne`: **`FetchType.EAGER`**
  * `@OneToMany`, `@ManyToMany`: **`FetchType.LAZY`**

하지만 실무에서는 이 기본값을 믿어서는 안 된다. **성능 문제를 피하기 위한 가장 중요한 원칙은 "모든 연관관계의 페치 전략을 `FetchType.LAZY`(지연 로딩)으로 설정하는 것"이다.**

그리고 특정 비즈니스 로직에서 연관된 엔티티가 반드시 함께 필요하다면, JPQL의 \*\*페치 조인(fetch join)\*\*을 사용하여 해당 로직에서만 명시적으로 함께 조회하는 것이 바람직하다. 이렇게 하면 전역적으로는 성능을 최적화하고, 국소적으로는 필요한 데이터를 효율적으로 가져오는 두 마리 토끼를 모두 잡을 수 있다.

이제 이 페치 전략을 염두에 두고, 가장 기본이 되는 다대일 관계 매핑부터 다음 절에서 자세히 알아보자.