## 03\. TABLE\_PER\_CLASS (테이블별 클래스 전략): 비권장 이유

마지막 전략인 \*\*클래스별 테이블 전략(Table Per Class Strategy)\*\*은 이름 그대로 각각의 자식 클래스마다 독립적인 테이블을 생성하는 방식이다. 이 전략은 부모 클래스가 추상 클래스일 경우, 부모 클래스를 위한 테이블은 만들지 않는다.

언뜻 보면 직관적인 것 같지만, 이 전략은 데이터베이스 설계와 JPA 양쪽 모두에서 **가장 추천되지 않는 방식**이다. 조인 전략과 단일 테이블 전략의 단점만을 합쳐놓은 것과 같은 여러 문제점을 안고 있기 때문이다.

-----

### **매핑 코드와 테이블 구조**

이 전략을 사용하려면 부모 클래스에 `@Inheritance(strategy = InheritanceType.TABLE_PER_CLASS)`를 명시한다.

**Item.kt (부모)**

```kotlin
@Entity
@Inheritance(strategy = InheritanceType.TABLE_PER_CLASS)
abstract class Item(
    @Id @GeneratedValue(strategy = GenerationType.TABLE) // ID 관리가 복잡해 TABLE 전략을 사용해야 할 수 있다.
    val id: Long = 0,
    var name: String,
    var price: Int
)
```

  * **주의**: 이 전략에서는 모든 자식 테이블에 걸쳐 ID의 유일성을 보장해야 하므로, `IDENTITY`나 `SEQUENCE` 전략 대신 별도의 키 생성 테이블을 사용하는 `TABLE` 전략을 고려해야 할 수 있다. 이 자체로 이미 복잡성과 성능 저하의 원인이 된다.

**생성되는 테이블 구조**
[그림: 클래스별 테이블 전략의 구조]
이 매핑은 `ITEM` 테이블을 생성하지 않고, `BOOK`과 `ALBUM` 테이블만 생성한다.

**BOOK (자식 테이블)**
| ID (PK) | NAME | PRICE | AUTHOR | ISBN |
| :--- | :--- | :--- | :--- | :--- |
| 1 | JPA 정복 | 35000 | 김영한 | 123-456 |

**ALBUM (자식 테이블)**
| ID (PK) | NAME | PRICE | ARTIST |
| :--- | :--- | :--- | :--- |
| 2 | BTS 앨범| 28000 | BTS |

`name`, `price`와 같은 공통 속성들이 각 자식 테이블에 **중복으로 생성**된 것을 확인할 수 있다.

-----

### **치명적인 단점: 왜 사용하면 안 되는가?**

**1. 최악의 조회 성능**
이 전략의 가장 큰 문제는 **부모 타입으로 데이터를 조회할 때 발생**한다. 예를 들어, `entityManager.find(Item.class, 1L)`을 실행한다고 가정해 보자. JPA는 이 `ID=1`인 아이템이 `BOOK` 테이블에 있는지, `ALBUM` 테이블에 있는지, 아니면 또 다른 자식 테이블에 있는지 알 길이 없다.

따라서 JPA는 모든 자식 테이블을 뒤지는 **`UNION`** 쿼리를 실행할 수밖에 없다.

```sql
SELECT * FROM BOOK WHERE ID = ?
UNION ALL
SELECT * FROM ALBUM WHERE ID = ?
UNION ALL
SELECT * FROM MOVIE WHERE ID = ?
-- ... (모든 자식 테이블을 상대로)
```

자식 클래스가 늘어날수록 `UNION` 해야 할 테이블도 늘어나며, 이는 데이터베이스에 엄청난 부담을 주는 재앙적인 쿼리로 이어진다.

**2. 데이터 중복과 관리의 어려움**
공통 속성을 관리하는 부모 테이블이 없으므로, 모든 공통 컬럼이 각 자식 테이블에 중복으로 존재하게 된다. 만약 `Item`에 `stockQuantity`라는 공통 속성을 하나 추가해야 한다면, `BOOK`, `ALBUM`, `MOVIE` 등 모든 자식 테이블의 스키마를 일일이 수정해야 하는 유지보수의 악몽이 시작된다.

-----

> **So What? (그래서 어쩌라고?)**
> **클래스별 테이블 전략은 사용하지 않는 것이 좋다.** 데이터베이스 설계 측면에서는 정규화를 위반하고, JPA 활용 측면에서는 최악의 성능을 보여준다. 조인 전략은 정규화의 장점을, 단일 테이블 전략은 성능의 장점을 가지고 있지만, 이 전략은 양쪽의 장점은 모두 놓치고 단점만을 극대화한 방식에 가깝다.
>
> -----

지금까지 살펴본 세 가지 상속 매핑 전략은 모두 장단점이 명확했다. 하지만 때로는 상속 관계는 아니면서, 여러 엔티티에 걸쳐 공통된 필드들을 우아하게 재사용하고 싶을 때가 있다. 다음 절에서는 바로 이런 경우를 위한 `@MappedSuperclass`에 대해 알아보자.