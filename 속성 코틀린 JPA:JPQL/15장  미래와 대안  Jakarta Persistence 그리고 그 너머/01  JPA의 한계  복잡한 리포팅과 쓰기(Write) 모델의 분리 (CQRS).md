## 01. JPA의 한계: 복잡한 리포팅과 쓰기(Write) 모델의 분리 (CQRS)

JPA는 객체지향 도메인 모델과 관계형 데이터베이스를 매핑하여, 트랜잭션 안에서 비즈니스 로직을 처리하는 **OLTP(Online Transaction Processing)** 환경에 최적화된 기술이다. `Order` 애그리거트를 조회해서 상태를 변경하고 저장하는 등의 작업에 있어서 JPA는 최고의 생산성과 안정성을 보여준다.

하지만 모든 애플리케이션의 요구사항이 이런 트랜잭션 처리에만 국한되지는 않는다. JPA의 객체 중심적인 설계는 특정 시나리오에서는 오히려 족쇄가 되기도 한다.

---

### **한계 1: 복잡한 통계 및 리포팅 쿼리**

월별/일별 매출 통계, 사용자 그룹별 평균 주문액, 카테고리별 재고 현황 등 수많은 테이블을 조인하고 그룹화하여 복잡한 집계(Aggregation)를 수행해야 하는 **OLAP(Online Analytical Processing)** 성격의 쿼리를 생각해 보자.

이런 쿼리를 JPA로 처리하려면 몇 가지 문제가 발생한다.
* **비효율성**: 통계 데이터를 얻기 위해 수많은 엔티티를 영속성 컨텍스트에 로딩하는 것은 엄청난 메모리 낭비와 성능 저하를 유발한다. 우리가 필요한 것은 단 몇 개의 집계 값일 뿐, 영속 상태의 엔티티 객체가 아니다.
* **표현력의 한계**: JPQL은 윈도우 함수, PIVOT, 공통 테이블 표현식(CTE) 등 현대 SQL이 제공하는 강력한 분석용 기능을 대부분 지원하지 않는다. 결국 이런 쿼리는 네이티브 SQL에 의존할 수밖에 없다.

JPA는 애초에 이런 종류의 대규모 데이터 분석을 위해 설계된 기술이 아니다. **복잡한 리포팅 쿼리는 JPA의 엔티티 모델을 우회하여, SQL을 더 직접적으로 다룰 수 있는 도구(jOOQ, MyBatis, JDBC Template 등)를 사용하는 것이 훨씬 효율적이다.**

---

### **한계 2: 조회(Read)와 변경(Write) 모델의 강한 결합**

전통적인 JPA 아키텍처에서는 데이터를 등록/수정/삭제할 때 사용하는 모델(엔티티)과, 화면에 보여주기 위해 데이터를 조회할 때 사용하는 모델이 동일하다. `Order` 애그리거트는 주문을 생성(Write)할 때도 사용되고, 주문 목록(Read)을 보여줄 때도 사용된다.

이는 다음과 같은 비효율을 낳는다.
* **쓰기 모델(Write Model)의 목적**: 데이터의 일관성과 비즈니스 규칙(불변식)을 지키는 것이 최우선이다. 따라서 `Order`, `OrderItem`, `ShippingInfo` 등 여러 객체가 복잡하게 얽힌 애그리거트 구조를 갖는다.
* **읽기 모델(Read Model)의 목적**: 사용자에게 필요한 데이터를 최대한 빠르고 효율적으로 보여주는 것이 최우선이다. 주문 목록 화면에서는 주문의 전체 애그리거트가 필요한 것이 아니라, 주문 번호, 상품명, 가격, 상태 등 몇 개의 필드만 담긴 가볍고 평면적인 데이터 구조(DTO)가 필요하다.

읽기 작업을 위해 굳이 복잡하고 무거운 쓰기 모델(엔티티)을 로딩하고 DTO로 변환하는 과정은 비효율적이다.

---

### **대안: CQRS (Command Query Responsibility Segregation)**

이 문제를 해결하기 위한 아키텍처 패턴이 바로 **CQRS(명령과 조회의 책임 분리)**다. CQRS는 시스템을 두 부분으로 나눈다.

* **명령(Command) 측**: 데이터의 상태를 변경하는 모든 작업(Create, Update, Delete)을 담당한다. 이 부분은 데이터의 일관성이 매우 중요하므로, **JPA와 애그리거트 모델을 사용하기에 최적의 환경**이다.
* **조회(Query) 측**: 데이터를 조회하는 모든 작업(Read)을 담당한다. 이 부분은 속도가 중요하므로, JPA 엔티티를 거치지 않고 **데이터베이스에 직접 SQL을 실행하여 화면에 최적화된 DTO를 즉시 반환**하는 방식을 사용한다. (이때 jOOQ나 MyBatis 같은 SQL 매퍼가 매우 유용하다.)



CQRS를 도입하면, 우리는 JPA의 장점(트랜잭션, 도메인 모델링)은 쓰기 모델에서 극대화하고, 단점(복잡한 조회, 성능 이슈)은 조회 모델에서 다른 기술을 사용하여 보완하는, 유연하고 확장성 있는 아키텍처를 구축할 수 있다.

이제 JPA의 한계를 보완해 줄 수 있는 구체적인 대안 기술들을 다음 절부터 하나씩 살펴보자.