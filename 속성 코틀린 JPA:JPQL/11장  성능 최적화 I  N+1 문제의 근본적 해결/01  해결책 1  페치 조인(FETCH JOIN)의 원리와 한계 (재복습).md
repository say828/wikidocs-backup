## 01\. 해결책 1: 페치 조인(FETCH JOIN)의 원리와 한계 (재복습)

N+1 문제라는 질병을 진단했으니, 이제 첫 번째 처방전을 꺼내 들 차례다. 우리가 7장에서 이미 그 위력을 맛보았던 \*\*페치 조인(Fetch Join)\*\*은 N+1 문제를 해결하는 가장 직관적이고 확실한 방법이다. 이번 절에서는 페치 조인의 원리를 다시 한번 복습하고, 그 명확한 한계까지 확실하게 짚고 넘어가자.

-----

### **페치 조인의 원리: 프록시가 아닌 진짜를 가져온다**

페치 조인의 핵심 원리는 단순하다. **SQL 조인을 사용하여 연관된 엔티티를 함께 조회하되, 그 결과를 가지고 프록시 객체가 아닌 실제 엔티티 객체를 조립하여 반환**하는 것이다. 즉, 조회 시점부터 객체 그래프를 완성시켜 버린다.

`JOIN` 키워드 뒤에 `FETCH` 하나를 붙여주는 것만으로, JPQL의 동작은 근본적으로 달라진다.

**일반 조인**

```jpql
-- SQL 조인은 일어나지만, SELECT 절에는 팀(t)만 포함된다.
-- 따라서 t.members는 여전히 프록시다.
SELECT t FROM Team t JOIN t.members m
```

**페치 조인**

```jpql
-- SQL 조인이 일어나고, 그 결과(팀과 멤버)를 모두 영속성 컨텍스트에 로드한다.
-- t.members는 이제 실제 멤버 객체들로 채워진 컬렉션이다.
SELECT t FROM Team t JOIN FETCH t.members
```

페치 조인을 사용하면, JPA는 `Team`과 `Member`를 조인하는 단 한 번의 SQL을 실행하여 모든 데이터를 가져온다. 그리고 그 결과를 바탕으로 `Team` 객체와, 그 `Team`이 참조하는 `members` 컬렉션을 **완전히 초기화된 상태**로 만들어 영속성 컨텍스트에 올린다.

따라서 페치 조인으로 조회된 `Team` 리스트를 순회하며 `team.members`에 접근해도, 이미 모든 데이터가 메모리에 로드되어 있으므로 지연 로딩을 위한 추가 쿼리는 전혀 발생하지 않는다. N+1 문제는 이렇게 단 한 줄의 키워드로 해결된다.

-----

### **페치 조인의 명확한 한계 (재복습)**

페치 조인은 이처럼 강력하지만, 무분별하게 사용할 수 있는 은탄환(Silver Bullet)은 아니다. 7장에서 언급했던 치명적인 한계점들을 다시 한번 상기하자.

**1. 별칭(Alias) 사용 불가**
페치 조인의 대상이 된 엔티티(예: `JOIN FETCH t.members m`에서 `m`)는 `WHERE` 절이나 `ORDER BY` 절에서 별칭을 사용하여 참조할 수 없다. 페치 조인의 목적은 오직 연관된 엔티티를 함께 로딩하는 것이지, 쿼리 자체를 필터링하거나 정렬하는 것이 아니기 때문이다.

**2. 둘 이상의 컬렉션 페치 조인 불가**
`Team`이 `members` 컬렉션과 `orders` 컬렉션을 모두 가지고 있을 때, `JOIN FETCH t.members`, `JOIN FETCH t.orders` 처럼 두 개 이상의 컬렉션을 한 번에 페치 조인할 수 없다. 데이터 뻥튀기(Cartesian Product)가 너무 심해져서 데이터 정합성이 깨질 위험이 크기 때문에 하이버네이트는 이를 허용하지 않는다.

**3. 컬렉션 페치 조인 시 페이징 API 사용 불가 (가장 중요\!)**
일대다 관계처럼 컬렉션을 페치 조인하는 경우, `setFirstResult`, `setMaxResults`와 같은 페이징 API를 함께 사용할 수 없다. 데이터베이스 레벨에서 `LIMIT`, `OFFSET`을 적용하면 데이터가 뻥튀기된 상태에서 잘려나가 데이터 정합성이 깨지기 때문이다. 하이버네이트는 이 경우 경고를 출력하고, 모든 데이터를 메모리로 가져온 뒤 페이징을 시도하므로 `OutOfMemoryError`의 직접적인 원인이 된다.

-----

페치 조인은 N+1 문제를 해결하는 가장 확실한 첫 번째 카드다. 하지만 특히 페이징이 필수적인 컬렉션 조회에서는 사용할 수 없다는 명확한 한계를 가지고 있다. 그렇다면 페이징이 필요한 상황에서 N+1 문제는 어떻게 해결해야 할까? 다음 절에서는 이 문제를 해결하는 두 번째 카드, `@BatchSize`에 대해 알아본다.