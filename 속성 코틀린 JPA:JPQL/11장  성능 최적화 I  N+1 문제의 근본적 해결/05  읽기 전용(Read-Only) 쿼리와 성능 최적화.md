## 05\. 읽기 전용(Read-Only) 쿼리와 성능 최적화

지금까지의 성능 최적화는 주로 불필요한 SQL을 줄이는 데 초점이 맞춰져 있었다. 하지만 JPA 내부의 동작을 미세하게 조정하여 성능을 개선할 여지도 남아있다. 그중 하나가 바로 **읽기 전용(Read-Only) 쿼리**를 활용하는 것이다.

이름 그대로, 조회된 엔티티를 수정할 목적이 전혀 없는, 순수하게 '읽기'만 하는 쿼리임을 JPA에게 알려주어 불필요한 내부 작업을 생략하게 만드는 최적화 기법이다.

-----

### **읽기 전용 쿼리의 최적화 원리**

`@Transactional` 환경에서 엔티티를 조회하면, JPA는 이 엔티티의 변경 여부를 추적하기 위해 1차 캐시에 **스냅샷**을 함께 저장한다고 2장에서 배웠다. 그리고 트랜잭션이 커밋될 때, 현재 엔티티와 스냅샷을 비교하는 **변경 감지(Dirty Checking)** 작업을 수행한다.

만약 우리가 조회한 엔티티를 절대 수정하지 않을 것이 확실하다면, 이 스냅샷을 저장하고 나중에 비교하는 모든 과정은 불필요한 메모리 및 CPU 낭비가 된다.

**읽기 전용 쿼리는 JPA에게 "이 쿼리의 결과는 수정될 일이 없으니, 스냅샷을 만들지도 말고 변경 감지도 하지 마라"고 알려주는 힌트**다. 이를 통해 JPA는 스냅샷을 위한 메모리 사용을 줄이고, 커밋 시점의 변경 감지 로직을 건너뛰어 약간의 성능 이점을 얻을 수 있다.

-----

### **적용 방법**

스프링 환경에서 읽기 전용 쿼리를 적용하는 가장 간단하고 일반적인 방법은 `@Transactional` 어노테이션의 `readOnly` 속성을 `true`로 설정하는 것이다.

**1. `@Transactional(readOnly = true)` - ⭐️ 권장**

```kotlin
@Service
class MemberQueryService(
    private val memberRepository: MemberRepository
) {
    // 이 트랜잭션은 읽기 전용임을 명시한다.
    @Transactional(readOnly = true)
    fun findMemberById(id: Long): MemberDto {
        val member = memberRepository.findById(id).orElseThrow()
        // DTO로 변환하여 반환. 엔티티를 수정하는 로직이 전혀 없다.
        return MemberDto(member.username, member.team.name)
    }
}
```

서비스 계층의 조회 메서드에 `@Transactional(readOnly = true)`를 붙여주는 것이 가장 이상적이다. 이 어노테이션은 단순히 JPA 최적화뿐만 아니라, 데이터베이스 드라이버 레벨에서도 불필요한 오버헤드를 줄이는 등 다양한 읽기 전용 최적화를 유도할 수 있다.

**2. `@QueryHint` 사용**
스프링 데이터 JPA의 `@Query` 어노테이션과 함께 `@QueryHint`를 사용하여 특정 쿼리만 읽기 전용으로 지정할 수도 있다.

```kotlin
interface MemberRepository : JpaRepository<Member, Long> {

    @Query("SELECT m FROM Member m")
    @QueryHint(name = "org.hibernate.readOnly", value = "true")
    fun findAllReadOnly(): List<Member>
}
```

이 방법은 더 세밀한 제어가 가능하지만, 코드가 지저분해지고 하이버네이트에 종속적인 힌트 이름을 사용해야 한다는 단점이 있다.

### **성능 향상 효과는?**

솔직히 말해, 단일 쿼리에 대한 읽기 전용 최적화의 성능 향상 폭은 아주 미미하다. 대부분의 경우 마이크로초(µs) 단위의 차이일 뿐이다.

하지만 수백만 건의 데이터를 처리하는 배치 작업이나, 초당 수천 건의 요청이 몰리는 API에서는 이 작은 차이가 모여 전체 시스템의 응답성과 처리량에 의미 있는 영향을 줄 수 있다. 무엇보다 `@Transactional(readOnly = true)`를 붙이는 것은 \*\*"이 메서드는 데이터를 변경하지 않습니다"\*\*라는 명확한 의도를 코드에 표현하는 좋은 습관이기도 하다.

-----

이것으로 N+1 문제로부터 시작된 JPA 읽기 성능 최적화의 여정을 마친다. 우리는 N+1이 발생하는 근본 원인을 파헤쳤고, 페치 조인, 배치 사이즈, 엔티티 그래프라는 세 가지 강력한 해결책을 배웠다. 또한 OSIV의 위험성과 올바른 아키텍처, 그리고 읽기 전용 쿼리를 통한 미세 최적화까지, 조회 성능을 향상시키는 데 필요한 모든 기술을 마스터했다.

하지만 애플리케이션의 성능은 조회(Read)만으로 결정되지 않는다. 여러 사용자가 동시에 데이터를 수정(Write)하려고 할 때 발생하는 동시성 문제를 어떻게 제어하고, 데이터베이스에 대한 반복적인 조회를 어떻게 근본적으로 줄일 수 있을까? 다음 12장에서는 \*\*캐시(Cache)\*\*와 \*\*잠금(Lock)\*\*이라는, 성능 최적화의 또 다른 두 거대한 축을 탐험해 볼 것이다.