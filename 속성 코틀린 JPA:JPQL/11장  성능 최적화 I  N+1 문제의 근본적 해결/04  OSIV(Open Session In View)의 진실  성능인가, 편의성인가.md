## 04. OSIV(Open Session In View)의 진실: 성능인가, 편의성인가

JPA를 사용하다 보면 `LazyInitializationException`이라는 예외를 한 번쯤은 만나게 된다. 이 예외는 영속성 컨텍스트가 닫힌 준영속 상태의 엔티티에서 지연 로딩(`LAZY`)으로 설정된 연관 필드를 초기화하려고 할 때 발생한다. 컨트롤러나 뷰(View) 계층에서 이런 일이 자주 발생하는데, 많은 개발자들이 이 문제를 해결하기 위해 페치 전략을 `EAGER`로 바꾸는 실수를 저지른다.

사실 스프링 부트를 사용하면 이 예외를 거의 볼 일이 없다. 그 이유는 **OSIV(Open Session In View)**라는 기능이 기본적으로 켜져 있기 때문이다. JPA에서는 'Session'을 'EntityManager'라고 부르므로, 정확히는 **OEMIV(Open EntityManager In View)**다.

---

### **OSIV란 무엇인가?**

OSIV는 영속성 컨텍스트의 생존 범위를 **트랜잭션 범위(`@Transactional`)가 아닌, HTTP 요청(Request)의 시작부터 끝까지**로 확장하는 전략이다.

* **OSIV ON (기본값)**: HTTP 요청이 들어오면 서블릿 필터나 인터셉터 단에서 영속성 컨텍스트와 트랜잭션을 시작한다. 서비스 계층의 `@Transactional` 메서드가 끝나도 트랜잭션과 영속성 컨텍스트는 계속 살아있다. 이후 컨트롤러와 뷰 렌더링(또는 API 응답 생성)이 모두 끝난 뒤에야 트랜잭션을 커밋하고 영속성 컨텍스트를 닫는다.
* **OSIV OFF**: 트랜잭션은 오직 `@Transactional`이 붙은 서비스 계층 내에서만 유지된다. 서비스 메서드가 종료되는 순간 트랜잭션과 영속성 컨텍스트도 함께 종료된다.

스프링 부트에서는 `spring.jpa.open-in-view` 옵션을 통해 이 기능을 켜고 끌 수 있으며, **기본값은 `true` (ON)**다.

### **OSIV의 장점: `LazyInitializationException`의 실종**

OSIV가 켜져 있으면 개발이 매우 편리해진다. 영속성 컨텍스트가 뷰를 렌더링하는 시점까지 살아있으므로, 컨트롤러나 타임리프(Thymeleaf) 같은 뷰 템플릿에서 지연 로딩을 사용해도 `LazyInitializationException`이 발생하지 않는다. 이를 **'지연 로딩 뷰'**라고도 부른다. 개발자는 N+1 같은 성능 문제를 신경 쓰지 않고도 일단 화면을 빠르게 개발할 수 있다.

---

### **OSIV의 치명적인 단점: 성능 저하의 주범**

이 편리함 뒤에는 무서운 대가가 따른다.
**1. 데이터베이스 커넥션 장기 점유**
가장 심각한 문제다. OSIV가 켜져 있으면, HTTP 요청의 시작부터 끝까지 데이터베이스 커넥션을 계속 물고 있게 된다. 컨트롤러가 외부 API를 호출하거나, 복잡한 뷰를 렌더링하는 동안에도 커넥션은 반환되지 않는다. 만약 실시간 트래픽이 몰리는 상황이라면, 애플리케이션 서버의 커넥션 풀이 순식간에 고갈되어 **시스템 전체가 응답 불능 상태**에 빠질 수 있다.

**2. 예측 불가능한 쿼리 발생**
컨트롤러나 뷰 계층은 본래 비즈니스 로직이 아닌 화면 처리 로직에 집중해야 한다. 그런데 OSIV가 켜져 있으면 이 계층에서 지연 로딩이 동작하면서 개발자가 전혀 의도하지 않은 SQL 쿼리가 발생할 수 있다. 특히 API 응답으로 엔티티를 직접 반환할 때, JSON 변환 라이브러리(Jackson 등)가 엔티티의 모든 필드를 읽으면서 수많은 N+1 쿼리를 유발하는 경우가 대표적이다. 이는 성능 문제를 추적하고 해결하기 매우 어렵게 만든다.

> **So What? (그래서 어쩌라고?)**
> **운영 환경에서는 반드시 OSIV를 꺼야 한다 (`spring.jpa.open-in-view: false`).**
>
> OSIV를 끄면 `LazyInitializationException`이 발생하기 시작할 것이다. 이것은 문제가 아니라, 오히려 지금까지 숨겨져 있던 성능 문제와 잘못된 아키텍처를 수면 위로 드러내는 **'건강한 예외'**다.
>
> OSIV를 끈 상태에서 개발하는 올바른 방법은 다음과 같다.
> 1.  **모든 지연 로딩은 트랜잭션 안에서 처리한다.** 즉, 컨트롤러에 데이터를 넘기기 전에 서비스 계층(`@Transactional`)에서 필요한 모든 데이터를 로딩해야 한다.
> 2.  **페치 조인 또는 `@EntityGraph`를 적극 활용**하여, 현재 비즈니스 로직에 꼭 필요한 연관 데이터만 명시적으로 함께 조회한다.
> 3.  **가장 좋은 방법은 DTO를 사용하는 것**이다. 컨트롤러가 엔티티를 직접 반환하는 대신, 서비스 계층에서 JPQL의 `new` 명령어 등을 사용해 화면에 필요한 데이터만 담은 DTO로 변환하여 반환한다. 이 방법은 프레젠테이션 계층과 도메인 모델을 완벽하게 분리하여, 지연 로딩 문제와 성능 이슈를 원천적으로 차단하는 가장 이상적인 아키텍처다.

---

OSIV는 달콤한 독과 같다. 단기적인 개발 편의성을 제공하지만, 장기적으로는 시스템의 성능과 안정성을 좀먹는다. 이 유혹을 이겨내고 OSIV를 끈 상태에서 DTO를 사용하는 습관을 들이는 것이, 확장 가능한 고성능 애플리케이션을 만드는 지름길이다.

이제 성능 최적화의 마지막 주제로, 읽기 전용 쿼리의 성능을 미세하게나마 더 끌어올리는 방법에 대해 알아보자.