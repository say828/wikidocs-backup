# 04장: 연관관계 매핑 II: 복잡한 관계와 고급 매핑 전략

3장에서 우리는 연관관계 매핑의 기본기를 다졌다. `@ManyToOne`과 `@OneToMany`를 통해 가장 흔한 관계를 표현하고, '연관관계의 주인'과 `mappedBy`라는 핵심 개념을 통해 양방향 관계를 완벽하게 제어하는 법을 배웠다. 이제 여러분은 JPA 연관관계의 80%를 해결할 수 있는 튼튼한 기초를 갖추게 된 셈이다.

이번 장에서는 그 나머지 20%에 해당하는, 더 섬세하고 복잡한 관계의 세계로 나아간다. 우리는 먼저 일대일(@OneToOne) 관계에서 외래 키를 어디에 두어야 하는지에 대한 중요한 설계 결정을 내리는 법을 배울 것이다. 그리고 실무에서 '지뢰'와도 같은 다대다(@ManyToMany) 관계를 왜 사용하면 안 되는지, 그리고 그에 대한 가장 이상적인 대안은 무엇인지 명확하게 제시할 것이다.

더 나아가, 연관된 엔티티의 생명주기를 함께 관리하는 영속성 전이(Cascade)와 고아 객체 제거(Orphan Removal)라는 강력한 기능을 탐구하고, 단순한 타입이 아닌 '값 타입(Value Type)'을 객체지향적으로 다루는 `@Embeddable`과 `@ElementCollection`의 가치와 위험성을 파헤쳐 볼 것이다. 이 장을 마치면 여러분은 JPA가 제공하는 거의 모든 연관관계 매핑 기술을 자유자재로 구사하는 전문가로 거듭나게 될 것이다.

-----

## 00\. 일대일(@OneToOne): 주 테이블과 대상 테이블의 선택 기준 (FK의 위치)

일대일 관계는 하나의 회원이 단 하나의 사물함을 갖거나, 하나의 주문이 단 하나의 배송 정보를 갖는 것처럼 두 엔티티가 1:1로만 매칭되는 관계를 의미한다. 개념 자체는 간단하지만, 다대일 관계와는 다른 중요한 고민거리를 안겨준다. 바로 **"외래 키(FK)를 어느 테이블에 두어야 하는가?"** 이다.

다대일 관계에서는 고민의 여지 없이 '다(N)' 쪽 테이블에 외래 키가 위치했지만, 일대일 관계에서는 이론적으로 양쪽 테이블 어디에나 외래 키를 둘 수 있다. 이 선택에 따라 개발 편의성, 성능, 데이터베이스 제약조건의 강점이 달라지므로 신중하게 결정해야 한다.

-----

### **전략 1: 주 테이블에 외래 키 (Main Table with FK)**

가장 객체지향적인 방식이다. `Member`가 `Locker`를 가지는 관계라면, `Member` 엔티티가 `Locker` 엔티티를 직접 참조하듯이, `MEMBER` 테이블이 외래 키 `LOCKER_ID`를 갖는 구조다.

**Member.kt (주인, 주 테이블)**

```kotlin
@Entity
class Member(
    // ...
    @OneToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "LOCKER_ID") // MEMBER 테이블에 FK 생성
    var locker: Locker? = null
)
```

**Locker.kt (하인)**

```kotlin
@Entity
class Locker(
    // ...
    @OneToOne(mappedBy = "locker")
    var member: Member? = null
)
```

  * **장점**: `Member`를 조회할 때 `Locker`를 함께 조회하기 위한 `JOIN`이 직관적이다. `Member`가 연관관계의 주인이 되어 객체지향 모델과 유사하게 느껴진다.
  * **단점**:
      * 사물함이 없는 회원도 있을 수 있으므로, `MEMBER` 테이블의 `LOCKER_ID` 컬럼은 `NULL`을 허용해야 한다.
      * **일대일 관계를 보장하려면 `LOCKER_ID` 컬럼에 반드시 `UNIQUE` 제약조건을 걸어야 한다.** 그렇지 않으면 여러 회원이 같은 사물함을 사용하는 다대일 관계가 되어버린다.

-----

### **전략 2: 대상 테이블에 외래 키 (Target Table with FK) - ⭐️ 권장**

데이터베이스 설계 관점에서 더 선호되는 방식이다. `Locker` 테이블이 자신을 사용하는 `Member`의 정보를 외래 키 `MEMBER_ID`로 갖는 구조다.

**Member.kt (하인, 주 테이블)**

```kotlin
@Entity
class Member(
    // ...
    @OneToOne(mappedBy = "member", fetch = FetchType.LAZY)
    var locker: Locker? = null
)
```

**Locker.kt (주인, 대상 테이블)**

```kotlin
@Entity
class Locker(
    // ...
    @OneToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "MEMBER_ID") // LOCKER 테이블에 FK 생성
    var member: Member? = null
)
```

  * **장점**:
      * **데이터베이스의 일대일 관계를 완벽하게 보장**할 수 있다. `LOCKER` 테이블의 `MEMBER_ID`를 \*\*기본 키(PK)이면서 동시에 외래 키(FK)\*\*로 설정하면, `MEMBER_ID` 값은 절대 중복될 수 없으므로 하나의 사물함은 반드시 하나의 회원에게만 할당된다. (`@Id @JoinColumn...` 은 불가능하므로 DB에서 직접 설정)
      * `MEMBER` 테이블이 `LOCKER`에 대한 정보를 갖지 않으므로 테이블이 더 깔끔해진다.
  * **단점**:
      * `Member`를 통해 `Locker`를 지연 로딩으로 조회할 때, JPA는 `Locker` 테이블에서 `MEMBER_ID`를 조건으로 조회하는 추가 쿼리를 실행해야 한다. (주 테이블에 FK가 있을 때보다 약간의 성능 저하 가능성)

### **결론: 누구를 주인으로 삼을 것인가?**

두 전략 모두 장단점이 있지만, **대부분의 경우 데이터 무결성을 확실하게 보장하는 '전략 2 (대상 테이블에 외래 키)'를 사용하는 것이 좋다.** 이는 관계형 데이터베이스의 설계 원칙과도 더 잘 부합한다. 개발 편의성보다는 데이터의 정합성을 우선하는 것이 장기적으로 더 안정적인 시스템을 만드는 길이다.

일대일 관계의 미묘한 선택지를 이해했다면, 이제 가장 까다로운 관계로 알려진 다대다 관계의 문제점과 해결책을 다음 절에서 살펴보자.