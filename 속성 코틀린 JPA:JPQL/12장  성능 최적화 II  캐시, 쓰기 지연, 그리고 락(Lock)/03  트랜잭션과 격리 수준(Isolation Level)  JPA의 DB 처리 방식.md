## 03\. 트랜잭션과 격리 수준(Isolation Level): JPA의 DB 처리 방식

캐시는 조회 성능을 향상시키는 기술이지만, 데이터의 수정(Write)이 일어나는 지점에서는 아무런 힘을 발휘하지 못한다. 여러 사용자가 동시에 데이터를 수정하려고 할 때, 데이터의 일관성과 정합성을 보장하는 것은 전적으로 \*\*데이터베이스 트랜잭션(Transaction)\*\*의 역할이다.

JPA의 모든 데이터 변경 작업(등록, 수정, 삭제)은 반드시 트랜잭션 안에서 이루어져야 한다. 우리는 스프링의 `@Transactional` 어노테이션 덕분에 이 과정을 편리하게 사용해왔다. 이번 절에서는 이 트랜잭션의 핵심 속성 중 하나인 \*\*격리 수준(Isolation Level)\*\*에 대해 알아보고, 이것이 JPA의 동작 방식과 어떤 관련이 있는지 이해해 보자.

-----

### **트랜잭션 격리 수준이란?**

트랜잭션 격리 수준이란, **여러 트랜잭션이 동시에 실행될 때, 특정 트랜잭션이 다른 트랜잭션의 변경 내용을 얼마나 볼 수 있도록 허용할 것인지**를 결정하는 단계다. 격리 수준은 데이터의 일관성(Consistency)과 동시성(Concurrency) 사이에 존재하는 트레이드오프(trade-off) 관계를 조절하는 중요한 설정이다.

  * **격리 수준이 높을수록**: 데이터의 일관성은 높아지지만, 여러 트랜잭션이 서로를 기다리게 되어(락 경합) 동시 처리 성능은 떨어진다.
  * **격리 수준이 낮을수록**: 동시 처리 성능은 높아지지만, 데이터의 일관성이 깨지는 여러 문제가 발생할 수 있다.

ANSI 표준은 네 가지 격리 수준을 정의하며, 각각은 다음과 같은 데이터 불일치 문제를 해결한다.

| 격리 수준 | Dirty Read | Non-Repeatable Read | Phantom Read |
| :--- | :--- | :--- | :--- |
| **READ UNCOMMITTED** | 발생 가능 | 발생 가능 | 발생 가능 |
| **READ COMMITTED** | **방지** | 발생 가능 | 발생 가능 |
| **REPEATABLE READ** | **방지** | **방지** | 발생 가능 |
| **SERIALIZABLE** | **방지** | **방지** | **방지** |

  * **Dirty Read**: 다른 트랜잭션이 **커밋하지 않은** 변경 내용을 읽는 현상. 만약 해당 트랜잭션이 롤백되면, 나는 존재하지도 않았던 '더러운' 데이터를 읽은 셈이 된다.
  * **Non-Repeatable Read**: 한 트랜잭션 안에서 \*\*같은 로우(row)\*\*를 두 번 읽었는데, 그 사이에 다른 트랜잭션이 해당 로우를 수정하고 커밋하여 두 조회 결과가 다르게 나타나는 현상.
  * **Phantom Read**: 한 트랜잭션 안에서 **특정 범위**를 두 번 읽었는데, 그 사이에 다른 트랜잭션이 새로운 로우를 추가하여 첫 번째 조회에서는 없었던 '유령' 같은 로우가 두 번째 조회에서 나타나는 현상.

-----

### **JPA와 스프링에서의 격리 수준 설정**

JPA는 트랜잭션 관리와 격리 수준 설정을 직접 다루지 않고, 데이터 소스(DataSource)와 트랜잭션 매니저에게 위임한다. 스프링을 사용하는 우리는 `@Transactional` 어노테이션의 `isolation` 속성을 통해 이 격리 수준을 매우 간단하게 지정할 수 있다.

```kotlin
@Transactional(isolation = Isolation.READ_COMMITTED)
fun someBusinessLogic() {
    // 이 메서드는 READ_COMMITTED 격리 수준으로 동작한다.
}
```

`Isolation` 열거형을 통해 `READ_UNCOMMITTED`, `READ_COMMITTED`, `REPEATABLE_READ`, `SERIALIZABLE`을 선택할 수 있다.

> **결론: 대부분의 경우, 데이터베이스 기본값을 신뢰하라.**
>
>   * Oracle, PostgreSQL, SQL Server 등 대부분의 상용 데이터베이스는 \*\*`READ_COMMITTED`\*\*를 기본 격리 수준으로 사용한다.
>   * MySQL(InnoDB)은 \*\*`REPEATABLE_READ`\*\*를 기본 격리 수준으로 사용한다.
>
> 대부분의 웹 애플리케이션은 데이터베이스가 기본으로 제공하는 격리 수준(주로 `READ_COMMITTED`)으로 충분히 안정적으로 동작한다. **특별한 이유 없이 격리 수준을 `SERIALIZABLE` 등으로 올리는 것은 심각한 성능 저하를 유발할 수 있으므로 매우 신중해야 한다.**
>
> 오히려 데이터베이스의 격리 수준에만 의존하기보다, 애플리케이션 레벨에서 동시성을 더 정교하게 제어하는 것이 더 나은 해결책일 때가 많다. 다음 절에서는 바로 이 애플리케이션 레벨 동시성 제어 기법인 '낙관적 락'에 대해 알아본다.