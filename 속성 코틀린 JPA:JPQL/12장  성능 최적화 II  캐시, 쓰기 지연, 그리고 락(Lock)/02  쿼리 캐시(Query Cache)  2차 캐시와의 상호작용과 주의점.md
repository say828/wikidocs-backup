## 02\. 쿼리 캐시(Query Cache): 2차 캐시와의 상호작용과 주의점

2차 캐시가 엔티티의 ID를 키로 사용하여 엔티티 자체를 캐싱하는 기술이라면, \*\*쿼리 캐시(Query Cache)\*\*는 **쿼리 문장과 파라미터를 키로 사용하여 그 결과(ID 목록)를 캐싱**하는 기술이다.

예를 들어, `SELECT m FROM Member m WHERE m.age > 20` 이라는 JPQL을 실행하면, 쿼리 캐시는 `"SELECT ... WHERE age > 20"` 이라는 쿼리 자체를 키로, 그 결과로 나온 `Member`들의 ID 리스트 `[1L, 5L, 10L, ...]`를 값으로 저장한다.

-----

### **쿼리 캐시의 동작 방식 (2차 캐시와의 상호작용)**

쿼리 캐시는 2차 캐시와 함께 사용될 때 의미가 있다. 쿼리 캐시를 사용하는 조회는 다음과 같은 2단계 과정을 거친다.

1.  **쿼리 캐시 조회**: 실행하려는 쿼리(JPQL + 파라미터)가 쿼리 캐시에 있는지 확인한다.

      * **(Cache Hit)**: 캐시에 있다면, 결과로 저장된 **엔티티 ID 리스트**를 가져온다.
      * **(Cache Miss)**: 캐시에 없다면, 데이터베이스에 쿼리를 실행한다. 그 결과로 얻은 엔티티 ID 리스트를 쿼리 캐시에 저장하고, 실제 엔티티 데이터는 2차 캐시에 저장한다.

2.  **2차 캐시 조회**: 1단계에서 얻은 ID 리스트를 가지고, 각 ID에 해당하는 엔티티를 **2차 캐시에서 조회**한다. 만약 2차 캐시에 없는 엔티티가 있다면, 해당 엔티티만 DB에서 추가로 조회한다.

**설정 방법**
쿼리 캐시를 사용하려면, 2차 캐시 설정에 더해 다음 두 가지 설정이 추가로 필요하다.

**1. `application.yml`에 쿼리 캐시 활성화**

```yaml
spring:
  jpa:
    properties:
      hibernate:
        cache:
          use_second_level_cache: true
          use_query_cache: true # 쿼리 캐시 활성화
          # ...
```

**2. 쿼리 실행 시 캐시 사용 힌트 추가**

```kotlin
// 쿼리를 생성할 때, 이 쿼리가 쿼리 캐시를 사용하도록 힌트를 주어야 한다.
val query = entityManager.createQuery(jpql, Member.class.java)
    .setHint("org.hibernate.cacheable", true)
```

-----

### **치명적인 단점과 사용 비권장 이유**

설명만 들으면 쿼리 캐시도 매우 유용해 보인다. 하지만 쿼리 캐시는 **매우 치명적인 약점**을 가지고 있어 실무에서 거의 사용되지 않는다.

> **쿼리 캐시의 약점: 캐시된 쿼리와 관련된 테이블에 단 하나의 데이터 변경(INSERT, UPDATE, DELETE)이라도 발생하면, 해당 테이블과 관련된 모든 쿼리 캐시 항목이 전부 삭제(Invalidated)된다.**

예를 들어, `Member` 엔티티에 대한 10개의 각기 다른 쿼리 결과를 캐싱하고 있었다고 가정하자. 이때, `Member` 테이블에 새로운 회원 한 명이 추가되거나, 기존 회원의 이름이 변경되는 등 아주 사소한 `UPDATE` 쿼리 하나만 실행되어도, 하이버네이트는 `Member` 테이블과 관련된 **10개의 쿼리 캐시를 모조리 날려버린다.**

이러한 'All or Nothing' 방식의 비효율적인 캐시 무효화 전략 때문에, 데이터 변경이 조금이라도 발생하는 테이블에 대한 쿼리 캐시는 캐시 히트율(Cache Hit Ratio)이 극도로 낮아져 의미가 없다. 오히려 캐시를 관리하는 데 드는 비용이 더 커지는 배보다 배꼽이 더 큰 상황이 발생한다.

> **결론: 쿼리 캐시는 사용하지 마라.**
> 쿼리 캐시는 데이터 변경이 절대 없는 완전한 읽기 전용 테이블에 대한 조회에나 제한적으로 유용할 뿐, 일반적인 웹 애플리케이션 환경에서는 실용성이 거의 없다. 성능 개선을 원한다면 쿼리 캐시를 쳐다보지 말고, **2차 캐시를 정밀하게 사용하거나 조회 로직 자체를 최적화**하는 데 집중하는 것이 훨씬 현명한 선택이다.

이제 캐시를 통한 조회 성능 최적화를 마쳤다. 다음으로는 데이터베이스의 심장부로 들어가, 여러 트랜잭션이 동시에 실행될 때 데이터의 일관성을 어떻게 유지하는지, 트랜잭션과 격리 수준에 대해 알아보자.