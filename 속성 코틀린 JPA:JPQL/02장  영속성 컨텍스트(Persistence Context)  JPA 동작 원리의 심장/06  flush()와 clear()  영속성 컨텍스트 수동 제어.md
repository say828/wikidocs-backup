## 06\. `flush()`와 `clear()`: 영속성 컨텍스트 수동 제어

지금까지 우리는 영속성 컨텍스트가 트랜잭션 커밋 시점에 자동으로 플러시(flush)되면서 모든 변경사항을 데이터베이스에 반영한다는 사실을 배웠다. 대부분의 경우, 이 자동화된 메커니즘에 모든 것을 맡겨두는 것이 가장 좋다. 하지만 때로는 개발자가 직접 영속성 컨텍스트를 제어하고 싶은 특별한 상황이 발생한다. 이때 사용하는 메서드가 바로 `entityManager.flush()`와 `entityManager.clear()`다.

-----

### **`flush()`: 강제로 SQL을 전송하라**

\*\*플러시(Flush)\*\*란 **영속성 컨텍스트의 변경 내용을 데이터베이스에 동기화하는 작업**을 의미한다. 더 구체적으로는 쓰기 지연 SQL 저장소에 쌓여있는 `INSERT`, `UPDATE`, `DELETE` 쿼리들을 데이터베이스에 전송하는 것을 말한다.

**중요한 것은, 플러시가 트랜잭션을 커밋하는 것은 아니라는 점이다.** 플러시는 단지 쿼리들을 DB에 보낼 뿐, 데이터베이스 트랜잭션의 커밋과는 무관하다. 따라서 플러시를 실행해도 커밋을 하지 않으면 모든 작업은 롤백될 수 있다.

**플러시가 자동으로 호출되는 경우**는 다음과 같다.

1.  `transaction.commit()`: 트랜잭션 커밋 시점. 가장 일반적인 경우다.
2.  `entityManager.flush()`: 개발자가 직접 호출하는 경우.
3.  **JPQL 쿼리 실행 시**: JPQL 쿼리는 기본적으로 데이터베이스에서 데이터를 조회한다. 만약 영속성 컨텍스트에 아직 DB에 반영되지 않은 변경사항이 있다면, JPQL 쿼리 결과가 부정확할 수 있다. 이를 방지하기 위해 JPA는 JPQL 쿼리가 실행되기 직전에 영속성 컨텍스트를 자동으로 플러시한다.

**그렇다면 언제 `flush()`를 직접 호출해야 할까?**
대표적으로 **별도의 DB 커넥션으로 무언가를 조회해야 할 때**나, **JPQL이 아닌 순수 JDBC나 MyBatis 같은 기술을 JPA와 함께 사용할 때** 필요하다. 또는 테스트 코드에서 `persist` 직후에 생성된 ID를 가지고 다른 작업을 하기 전에 `INSERT` 쿼리가 실행되었음을 보장하고 싶을 때 유용하게 사용할 수 있다.

```kotlin
// memberA와 memberB를 영속화. 아직 INSERT SQL은 나가지 않은 상태.
entityManager.persist(memberA)
entityManager.persist(memberB)

// 아직 커밋 시점이 아니지만, INSERT 쿼리를 미리 DB에 보내고 싶다.
entityManager.flush() 
// 이 시점에 INSERT SQL 두 개가 실행된다.

// 이제 다른 로직을 수행...

// 트랜잭션 커밋
transaction.commit() 
```

-----

### **`clear()`: 영속성 컨텍스트를 초기화하라**

\*\*`clear()`\*\*는 이름 그대로 **영속성 컨텍스트를 깨끗하게 비우는 역할**을 한다. `clear()`를 호출하면 영속성 컨텍스트의 1차 캐시와 쓰기 지연 SQL 저장소에 있던 모든 내용이 사라진다. 즉, **모든 영속 상태의 엔티티가 준영속 상태가 된다.**

**언제 `clear()`를 사용해야 할까?**
주로 **아주 긴 트랜잭션 안에서 대량의 데이터를 반복적으로 조회하고 처리해야 할 때** 메모리 사용량을 최적화하기 위해 사용한다. 예를 들어, 100만 건의 데이터를 루프를 돌며 조회하고 수정하는 배치(batch) 작업을 상상해 보자. `clear()`를 호출하지 않으면 100만 건의 엔티티가 모두 1차 캐시에 쌓여 `OutOfMemoryError`를 유발할 수 있다. 이때 일정 단위(예: 1000건)마다 `flush()`로 DB에 반영하고 `clear()`로 영속성 컨텍스트를 비워주면, 메모리 누수 없이 안정적으로 작업을 완료할 수 있다.

또한, 테스트 환경에서 이전 작업의 영속성 컨텍스트가 다음 테스트에 영향을 주지 않도록 격리하고 싶을 때도 유용하게 사용된다.

```kotlin
// 1. member 조회 (영속 상태, 1차 캐시에 저장됨)
val member1 = entityManager.find(Member::class.java, 1L)

// 2. 영속성 컨텍스트 초기화
entityManager.clear() // member1은 이제 준영속 상태

// 3. 다시 같은 member 조회
// 1차 캐시가 비었으므로, DB에 SELECT 쿼리를 다시 실행한다.
val member2 = entityManager.find(Member::class.java, 1L) 

println(member1 === member2) // 결과는? false!
```

`clear()` 호출 후 다시 조회한 `member2`는 `member1`과 다른 새로운 객체 인스턴스다. `clear()`를 통해 1차 캐시가 완전히 비워졌기 때문이다.

-----

이것으로 JPA의 심장부인 영속성 컨텍스트의 모든 비밀을 파헤쳤다. 우리는 엔티티의 생명주기부터 시작해, 1차 캐시와 동일성 보장, 쓰기 지연과 변경 감지, 그리고 `merge()`의 위험한 진실과 수동 제어 방법까지, JPA가 내부적으로 어떻게 동작하는지 그 핵심 원리를 모두 이해했다.

이제 우리의 엔티티는 혼자가 아니다. 여러 엔티티들이 서로 관계를 맺기 시작할 것이다. 회원(Member)은 팀(Team)에 소속되고, 주문(Order)은 상품(Item)을 포함한다. 다음 3장에서는 객체 세계의 '연관관계'와 테이블 세계의 '외래 키'라는 두 패러다임의 차이를 JPA가 어떻게 매핑하는지, 그 흥미로운 여정을 떠나보자.