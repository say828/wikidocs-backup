# 01장: 엔티티(Entity) 매핑 기초: 객체와 테이블의 첫 만남

00장에서 우리는 `@Entity` 어노테이션이 붙은 `Member` 클래스가 순식간에 데이터베이스 테이블로 변신하는 마법을 목격했다. 하지만 그 과정은 블랙박스에 가까웠다. `@Id`는 정확히 무엇이며, `GenerationType.IDENTITY` 외에 다른 전략은 없을까? `name` 프로퍼티는 어떻게 `name` 컬럼이 되었을까? 만약 테이블이나 컬럼 이름을 바꾸고 싶다면 어떻게 해야 할까?

이번 장은 바로 이 블랙박스를 환하게 밝히는 여정이다. JPA 매핑의 가장 기본이 되는 어노테이션들을 하나씩 정복하며, 평범한 코틀린/자바 객체의 속성들이 어떤 규칙에 따라 데이터베이스 테이블의 컬럼으로 변환되는지 그 원리를 파헤친다. 객체에 '영속성'이라는 새로운 생명을 불어넣는 이 과정을 이해하는 것은 JPA 마스터로 가는 첫 번째 관문이다.

우리는 엔티티의 탄생을 알리는 `@Entity`부터 시작해, 객체의 정체성을 부여하는 `@Id`와 다양한 기본 키 생성 전략, 일반 필드를 매핑하는 `@Column`, 날짜나 열거형 타입을 다루는 `@Enumerated`와 `@Temporal`, 그리고 특정 필드를 영속성 관리에서 제외하는 `@Transient`까지, 가장 핵심적인 매핑 어노테이션들을 학습할 것이다.

더 나아가, 개발 환경의 축복이자 운영 환경의 재앙이 될 수 있는 `ddl-auto` 옵션의 위험성을 경고하고, 코틀린 데이터 클래스를 JPA 엔티티로 사용할 때 왜 `no-arg` 플러그인이 필수적인지 그 이유까지 명확하게 짚어준다. 이 장을 마치고 나면, 당신은 어떤 평범한 객체라도 자신감 있게 데이터베이스 테이블과 연결시킬 수 있는 기본기를 갖추게 될 것이다.

-----

## 00\. @Entity: 평범한 코틀린/자바 객체가 영속성을 얻는 순간

JPA의 세계는 `@Entity` 어노테이션으로부터 시작된다. 아무리 잘 설계된 클래스라도 이 어노테이션이 없다면 JPA에게는 그저 스쳐 지나가는 평범한 객체(POJO)일 뿐이다. `@Entity`는 JPA에게 "이 클래스를 주목하라\! 내가 지금부터 관리해야 할 대상이다\!"라고 알려주는 출생신고와 같다.

```kotlin
import jakarta.persistence.Entity
import jakarta.persistence.Id
import jakarta.persistence.Table

@Entity // JPA, 이 클래스를 관리해줘!
@Table(name = "MEMBERS") // DB에는 'MEMBERS'라는 이름의 테이블과 매핑해줘.
class Member(
    @Id
    val id: Long = 0,
    var name: String
)
```

`@Entity`가 붙은 클래스는 이제 JPA의 영속성 컨텍스트에 의해 관리될 수 있는 자격을 얻는다. 즉, 데이터베이스에 저장되고, 조회되고, 수정되고, 삭제될 수 있는 특별한 존재가 되는 것이다.

### **`@Entity`의 속성과 `@Table`**

`@Entity` 어노테이션 자체에도 `name`이라는 속성이 있다.
`@Entity(name = "Member")`
여기서 주의할 점이 있다. 이 `name` 속성은 데이터베이스 **테이블 이름을 지정하는 것이 아니다.** 이것은 JPQL(Java Persistence Query Language)에서 사용할 **엔티티의 이름**을 지정하는 것이다. 예를 들어, `SELECT m FROM Member m` 과 같은 JPQL 쿼리를 작성할 때, 여기서 `Member`가 바로 엔티티의 이름이다. 이 속성을 생략하면 기본값으로 클래스 이름이 사용된다. 특별한 경우가 아니라면 굳이 설정할 필요는 없다.

실제 데이터베이스 테이블의 이름을 지정하고 싶을 때는 **`@Table`** 어노테이션을 함께 사용해야 한다.

`@Table` 어노테이션은 다음과 같은 주요 속성을 가진다.

  * `name`: 매핑할 테이블의 이름을 직접 지정한다. (예: `@Table(name = "MBR_TBL")`) 지정하지 않으면 엔티티 이름을 테이블 이름으로 사용한다.
  * `catalog`, `schema`: 데이터베이스의 `catalog`나 `schema`를 지정해야 할 때 사용한다.
  * `uniqueConstraints`: DDL 생성 시점에 `UNIQUE` 제약조건을 추가할 때 사용한다. 여러 컬럼을 묶어 복합 유니크 제약조건을 만들 수 있다.

<!-- end list -->

```kotlin
@Entity
@Table(name = "USER_ACCOUNT", uniqueConstraints = [
    UniqueConstraint(name = "UK_EMAIL", columnNames = ["email"])
])
class User(
    // ...
    val email: String
)
```

위 코드는 `USER_ACCOUNT` 테이블의 `email` 컬럼에 `UK_EMAIL`이라는 이름의 유니크 제약조건을 설정하는 예시다.

### **@Entity 사용 시 주의사항**

JPA 명세에 따라 `@Entity` 클래스는 몇 가지 규칙을 따라야 한다.

1.  **기본 생성자가 반드시 필요하다.** 파라미터가 없는 `public` 또는 `protected` 생성자가 필요하다. 이는 JPA 구현체(하이버네이트 등)가 리플렉션을 통해 객체를 생성해야 하기 때문이다. 코틀린에서는 `jpa` 플러그인이 이 역할을 대신해준다.
2.  **`final` 클래스일 수 없다.** JPA는 엔티티 클래스를 상속하여 프록시 객체를 만드는 경우가 많다(지연 로딩 등). `final`은 상속을 막기 때문에 사용할 수 없다. 코틀린에서는 `spring` 플러그인(`all-open`)이 이 문제를 해결해준다.
3.  **`enum`, `interface`, `inner class` 에는 사용할 수 없다.**
4.  **저장할 필드에 `final`을 사용해서는 안 된다.**

`@Entity`라는 작은 어노테이션 하나로 우리의 객체는 영속성을 가질 준비를 마쳤다. 하지만 모든 엔티티는 서로를 구분할 수 있는 고유한 식별자, 즉 '주민등록번호'가 필요하다. 다음 절에서는 바로 이 식별자를 정의하는 `@Id`와 기본 키 생성 전략에 대해 깊이 있게 알아보자.