## 03\. 패치 조인의 한계: 컬렉션 조인과 페이징 문제 (Cartesian Product)

페치 조인은 N+1 문제를 해결하는 강력한 무기지만, 만능은 아니다. 특히 **일대다(@OneToMany) 관계처럼 컬렉션을 대상으로 페치 조인을 사용할 때**는 몇 가지 심각한 한계점과 주의사항이 따른다. 이를 모르고 남용하면 데이터 정합성이 깨지거나, 최악의 경우 메모리 초과로 애플리케이션이 멈춰버릴 수 있다.

-----

### **1. 데이터 뻥튀기 (Cartesian Product)**

가장 핵심적인 문제는 데이터베이스의 조인 원리에서 비롯된다. 일대다 관계를 조인하면 '일(1)'에 해당하는 데이터가 '다(N)'에 해당하는 데이터의 수만큼 **중복되어 조회**된다.

예를 들어, 1개의 팀(`Team A`)에 10명의 회원(`Member`)이 소속되어 있다고 가정하자. `Team`과 `Member`를 페치 조인하면 어떤 결과가 나올까?

```jpql
SELECT t FROM Team t JOIN FETCH t.members
```

SQL 조인 결과는 10개의 로우(row)가 생성된다. 각 로우는 `Team A`의 정보와 `Member 1`부터 `Member 10`까지의 정보를 각각 담고 있다.

JPA는 이 10개의 로우를 바탕으로 `Team` 객체를 생성하려고 시도한다. 그 결과, 똑같은 `Team A` 객체가 메모리 상에 **10개** 생성되는 것처럼 보인다. (물론 영속성 컨텍스트가 동일성을 보장하므로 실제로는 같은 참조를 갖게 되지만, 결과 집합 자체는 뻥튀기된다.)

이것이 바로 **카테시안 곱(Cartesian Product)** 문제다. 이 문제는 둘 이상의 컬렉션을 함께 페치 조인할 때 더욱 심각해진다. 만약 팀이 주문(Order) 컬렉션도 가지고 있고, 한 팀에 회원이 10명, 주문이 5개 있다면 `1 * 10 * 5 = 50`개의 로우가 조회되는 데이터 폭증이 발생한다.

**해결책 1: `DISTINCT` 사용**
JPQL은 이 중복 문제를 해결하기 위해 `DISTINCT` 키워드를 제공한다.

```jpql
SELECT DISTINCT t FROM Team t JOIN FETCH t.members
```

`DISTINCT`는 두 가지 역할을 한다.

1.  **SQL `DISTINCT`**: 먼저 SQL에 `DISTINCT`를 추가하여 중복된 로우를 제거한다. (데이터베이스에 따라 효과가 없을 수도 있다.)
2.  **애플리케이션 레벨 중복 제거**: JPA가 조회 결과에서 `@Id` 값이 같은 엔티티를 중복으로 간주하고 애플리케이션 레벨에서 제거해준다.

`DISTINCT`를 사용하면 뻥튀기된 결과 집합에서 중복된 `Team` 객체를 제거하고 유일한 `Team` 객체만 반환받을 수 있다.

-----

### **2. 페이징 API 사용 불가 (치명적 단점)**

컬렉션 페치 조인의 **가장 치명적인 한계는 페이징 API(`setFirstResult`, `setMaxResults`)를 함께 사용할 수 없다**는 점이다.

`Team` 100개가 있고, 각 팀마다 회원이 5명씩 있다고 가정해 보자. `Team`을 기준으로 10개씩 페이징 처리하여 첫 페이지를 조회하고 싶다.

```kotlin
// 잘못된 사용 예시 - 의도대로 동작하지 않는다!
val jpql = "SELECT DISTINCT t FROM Team t JOIN FETCH t.members"
val query = entityManager.createQuery(jpql, Team.class.java)
    .setFirstResult(0)
    .setMaxResults(10)
```

이 쿼리는 데이터베이스 레벨에서 `LIMIT 10 OFFSET 0`을 적용할 수 없다. 왜냐하면 조인으로 인해 데이터가 뻥튀기된 상태에서 10개의 로우만 잘라내면, 어떤 팀은 소속 회원이 5명 모두 포함되지만, 어떤 팀은 1\~2명만 포함되는 등 데이터 정합성이 완전히 깨져버리기 때문이다.

이 때문에 하이버네이트는 컬렉션 페치 조인에 페이징 API를 사용하면 경고 로그를 남기며, **모든 데이터를 데이터베이스에서 메모리로 불러온 뒤, 애플리케이션 메모리 상에서 페이징 처리**를 시도한다. 만약 전체 데이터가 수만 건이라면, `OutOfMemoryError`가 발생하며 애플리케이션이 즉시 다운될 것이다.

> **결론: 컬렉션 페치 조인과 페이징은 함께 사용할 수 없다.**
> 이 문제를 해결하려면 페치 조인을 포기하고 다른 방법을 사용해야 한다.
>
> 1.  `@BatchSize` 어노테이션을 사용하여 지연 로딩 시 N+1이 아닌 지정된 크기만큼 `IN` 쿼리를 날리도록 최적화한다. (11장에서 자세히 다룸)
> 2.  쿼리를 분리한다. 먼저 일반 조인으로 대상 엔티티(`Team`)만 페이징하여 조회하고, 그 결과로 얻은 ID 리스트를 사용하여 두 번째 쿼리에서 연관된 컬렉션(`Member`)을 조회하는 방식이다.

-----

페치 조인은 강력하지만, 이처럼 명확한 한계가 존재한다. 이제 데이터를 특정 기준으로 묶어 집계하는 `GROUP BY`와 `HAVING` 절에 대해 알아보자.