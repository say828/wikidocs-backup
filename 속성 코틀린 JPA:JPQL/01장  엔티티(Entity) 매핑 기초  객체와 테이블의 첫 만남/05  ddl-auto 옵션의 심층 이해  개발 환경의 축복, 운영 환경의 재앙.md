## 05. `ddl-auto` 옵션의 심층 이해: 개발 환경의 축복, 운영 환경의 재앙

우리가 `application.yml`에 무심코 추가했던 `spring.jpa.hibernate.ddl-auto: create` 설정은 사실 JPA를 사용하는 개발자가 가장 신중하게 다루어야 할 옵션 중 하나다. 이 옵션은 엔티티 클래스의 매핑 정보를 바탕으로 하이버네이트가 데이터베이스 스키마를 자동으로 생성하거나 변경하는 방법을 지정한다. 이 기능은 개발 초기 단계에는 엄청난 생산성을 제공하는 축복이지만, 그 위험성을 제대로 이해하지 못하고 운영 환경에서 사용했다가는 돌이킬 수 없는 재앙을 맞이하게 된다.

`ddl-auto` 옵션에는 다음과 같은 값들을 설정할 수 있다.

| 옵션 | 설명 | 권장 사용 환경 |
| --- | --- | --- |
| **`create`** | 애플리케이션 시작 시점에 기존 테이블 스키마를 **모두 삭제(DROP)한 후, 다시 생성(CREATE)**한다. | **초기 개발, 로컬 PC 환경.** 데이터가 모두 사라져도 상관없을 때 사용. |
| **`create-drop`** | `create`와 동일하게 시작 시점에 스키마를 삭제 후 생성하지만, 애플리케이션 **종료 시점에도 생성했던 스키마를 모두 삭제**한다. | **테스트 환경.** 특히 매번 독립적인 DB 상태에서 실행되어야 하는 통합 테스트에 매우 유용하다. |
| **`update`** | 애플리케이션 시작 시점에 엔티티와 데이터베이스 스키마를 비교하여, 변경된 부분(새로운 필드 추가 등)만 스키마에 **반영**한다. | **초기 개발 단계.** 스키마를 유지하면서 필드를 추가/변경할 때 편리하지만, 한계가 명확하다. |
| **`validate`** | 애플리케이션 시작 시점에 엔티티와 데이터베이스 스키마가 일치하는지 **검증**만 한다. 만약 일치하지 않으면 예외를 발생시키고 애플리케이션을 중단시킨다. | **개발 후반, 스테이징/QA 환경.** 또는 운영 환경에서 안전장치로 사용할 수 있다. |
| **`none`** | 아무런 기능도 작동하지 않는다. DDL 관련 기능이 완전히 비활성화된다. | **운영(Production) 환경.** **운영 환경에서는 `none` 또는 `validate`만 사용해야 한다.** |

---

### **왜 운영 환경에서 `create`, `update`는 재앙인가?**

상상해 보자. 수백만 명의 고객 데이터가 들어있는 운영 데이터베이스에 연결된 애플리케이션을 배포하는데, `ddl-auto` 옵션이 `create`로 설정되어 있었다면? 애플리케이션이 시작되는 순간, **모든 고객 데이터는 영원히 사라진다.** `update` 옵션은 그나마 낫지 않을까? 천만의 말씀이다. `update`는 완벽한 스키마 마이그레이션 도구가 아니다. 컬럼명 변경, 타입 변경, 제약조건 삭제 등 복잡한 변경 사항을 제대로 처리하지 못하며, 때로는 개발자가 의도치 않은 방향으로 스키마를 변경하여 데이터를 유실시키거나 시스템 전체를 장애 상태에 빠뜨릴 수 있다.

**운영 환경의 데이터베이스 스키마는 절대 애플리케이션에 의해 자동으로 변경되어서는 안 된다.** 스키마 변경은 매우 신중하게 검토되고, 잘 작성된 스크립트를 통해 DBA나 개발자가 직접 통제하며 이루어져야 한다.

### **현명한 개발자의 전략: 환경별 프로필 분리**

가장 이상적인 전략은 스프링의 프로필(`application-local.yml`, `application-test.yml`, `application-prod.yml` 등) 기능을 활용하여 각 환경에 맞는 `ddl-auto` 값을 명시적으로 지정하는 것이다.

* **로컬 개발 환경 (`local`)**: 빠르게 스키마를 변경하며 테스트해야 하므로 `create` 또는 `update`를 사용한다. 개인적으로는 매번 깔끔한 상태에서 시작하는 `create`를 선호한다.
* **통합 테스트 환경 (`test`)**: 다른 테스트에 영향을 주지 않고 독립적인 실행을 보장하기 위해 `create-drop`을 사용한다.
* **운영 환경 (`prod`)**: 실제 데이터를 절대 건드리지 않도록 `none` 또는 `validate`를 사용한다.

### **운영 스키마 변경의 정답: 마이그레이션 도구**

그렇다면 운영 환경의 스키마는 어떻게 변경해야 할까? 정답은 **Flyway**나 **Liquibase** 같은 데이터베이스 마이그레이션 도구를 사용하는 것이다. 이 도구들은 버전 관리되는 SQL 스크립트를 통해 데이터베이스 스키마를 체계적으로, 그리고 안전하게 변경하고 그 이력을 관리해준다. 이를 통해 개발자는 운영 DB 스키마를 실수 없이, 예측 가능하게 관리할 수 있다.

`ddl-auto`는 분명 매력적인 기능이다. 하지만 그 칼날은 양면을 가지고 있음을 명심해야 한다. 개발 환경에서는 그 편리함을 마음껏 누리되, 운영 환경에서는 칼집에 고이 넣어두는 지혜가 필요하다. 이제 엔티티 매핑의 마지막 주제로, 코틀린 환경에서 JPA를 사용할 때 마주하게 되는 특별한 이슈에 대해 알아보자.