# Part 4: 동시성 프로그래밍: 코루틴의 세계

현대 애플리케이션의 핵심은 \*\*응답성(Responsiveness)\*\*입니다. 사용자는 네트워크에서 데이터를 가져오거나, 파일을 디스크에 쓰는 동안 화면이 멈추는 것을 기다려주지 않습니다. 이러한 '시간이 걸리는 작업'들을 메인 스레드(UI를 담당하는 주 작업 흐름)를 막지 않고 백그라운드에서 처리하는 기술을 **동시성(Concurrency) 프로그래밍**이라고 합니다.

전통적인 동시성 모델은 \*\*스레드(Thread)\*\*를 기반으로 합니다. 하지만 스레드는 생성과 컨텍스트 스위칭 비용이 비싸고, 여러 스레드가 공유 자원에 접근할 때 발생하는 레이스 컨디션이나 데드락 같은 문제들을 개발자가 직접 관리해야 하는 복잡성과 어려움을 안고 있습니다.

Part 4에서는 코틀린이 이 동시성 문제를 얼마나 혁신적이고 우아하게 해결하는지를 보여주는 \*\*코루틴(Coroutines)\*\*의 세계로 떠납니다. 코루틴은 스레드보다 훨씬 가볍고 유연하며, 복잡한 비동기 코드를 마치 간단한 동기 코드처럼 작성할 수 있게 해주는 코틀린의 가장 강력한 기능 중 하나입니다. 코루틴을 이해하고 나면, 당신은 더 이상 비동기 프로그래밍을 두려워하지 않게 될 것입니다.

-----

## 12장: 코루틴 기초: 비동기를 동기처럼

"비동기 코드를 동기 코드처럼 작성한다."

이것이 코루틴의 핵심 철학이자, 개발자에게 주는 가장 큰 선물입니다. 콜백(callback)이 중첩되어 코드의 흐름을 파악하기 어려운 '콜백 지옥(Callback Hell)'에서 벗어나, 위에서 아래로 순차적으로 실행되는 것처럼 보이는 직관적인 코드로 비동기 작업을 처리할 수 있습니다.

이번 장에서는 스레드라는 전통적인 패러다임을 넘어 코루틴이 무엇인지, 어떤 장점을 가지는지 그 기본 개념을 확실히 다지고, 코루틴을 구성하는 가장 기본적인 요소인 일시 중단 함수, 코루틴 빌더, 그리고 디스패처에 대해 학습하며 코루틴의 세계에 첫발을 내디뎌 보겠습니다.