### 표현식 위주의 프로그래밍

코틀린이 자바와 같은 기존 언어와 구별되는 가장 근본적인 철학 중 하나는 \*\*'표현식 위주(Expression-Oriented)'\*\*의 언어라는 점입니다.

  * **문 (Statement):** 어떤 작업을 수행하지만, 어떠한 값도 반환하지 않는 코드 단위입니다. (예: 자바의 `if`문, `for` 반복문, 변수 선언)
  * **식 (Expression):** 연산 후, 반드시 **특정 값을 반환**하는 코드 단위입니다. (예: `5 + 3`, `person.name`, `if (a > b) a else b`)

자바에서는 대부분의 제어 구문이 '문'이지만, 코틀린에서는 `if`, `when`, 심지어 `try-catch` 블록까지 거의 모든 것이 '식'입니다.

-----

#### `if`와 `when`을 값으로 사용하기

이 철학이 가져다주는 가장 큰 이점은 **불필요한 임시 변수(`var`)의 사용을 제거**하고, 코드를 더 선언적이며 불변하게 만들 수 있다는 것입니다.

**Before (명령형/문(Statement) 스타일)**
자바와 유사한 이 스타일은, 결과를 담기 위한 `var` 변수를 외부에 먼저 선언하고, 조건문 내부에서 이 변수의 상태를 변경(mutate)해야 합니다.

```kotlin
fun getGrade(score: Int): String {
    var grade: String // 1. 변경 가능한 var 변수 선언
    
    if (score >= 90) {
        grade = "A" // 2. 조건에 따라 변수의 상태를 변경
    } else if (score >= 80) {
        grade = "B"
    } else {
        grade = "C"
    }
    
    return grade // 3. 변경된 변수 반환
}
```

**After (표현식(Expression) 스타일)**
코틀린에서는 `if`나 `when` 자체가 값을 반환하는 '식'이므로, 변수 선언과 동시에 값 할당이 가능합니다. 이는 `var` 대신 `val`을 사용할 수 있게 해줍니다.

```kotlin
fun getGrade(score: Int): String {
    // 1. when 표현식 자체가 값을 반환하여
    //    불변 변수 grade에 즉시 할당된다.
    val grade = when {
        score >= 90 -> "A"
        score >= 80 -> "B"
        else -> "C"
    }
    return grade
}

// 단일 표현식 함수로 만들면 더욱 간결해집니다.
fun getGradeConcise(score: Int) = when {
    score >= 90 -> "A"
    score >= 80 -> "B"
    else -> "C"
}
```

이 코드는 "grade는 이 `when` 조건의 **결과이다**"라고 선언적으로 읽히며, 상태 변경이 일어나는 `var` 변수가 없어 훨씬 더 안전하고 예측 가능합니다.

-----

#### `try-catch`도 표현식이다

이러한 철학은 예외 처리에도 동일하게 적용됩니다. 코틀린에서 `try-catch` 블록은 값을 반환할 수 있습니다. `try` 블록의 마지막 표현식 또는 `catch` 블록의 마지막 표현식이 `try-catch` 표현식 전체의 결과 값이 됩니다.

```kotlin
fun parseNumberSafe(text: String): Int {
    // try-catch 표현식의 결과가 number 변수에 직접 할당됩니다.
    val number: Int = try {
        Integer.parseInt(text) // 성공 시 이 값이 반환됨
    } catch (e: NumberFormatException) {
        0 // 예외 발생 시 이 값(0)이 기본값으로 반환됨
    }
    return number + 1
}

println(parseNumberSafe("123")) // 출력: 124
println(parseNumberSafe("abc")) // 출력: 1
```

이 패턴은 예외가 발생할 수 있는 연산에 대해, 외부에 `null`이나 임시 변수를 선언할 필요 없이 안전하게 기본값을 제공하는 매우 간결하고 강력한 방법을 제시합니다.

'표현식 위주의 프로그래밍'은 단순한 문법 설탕이 아닙니다. 이는 개발자가 명령형 스타일(`무엇을, 어떻게 해라`)에서 벗어나 선언형 스타일(`이것은, 저것이다`)로 생각하도록 유도합니다. 이는 불변성을 촉진하고, 사이드 이펙트를 줄이며, 코드의 의도를 훨씬 더 명확하게 드러내는 코틀린 장인의 핵심 사고방식입니다.