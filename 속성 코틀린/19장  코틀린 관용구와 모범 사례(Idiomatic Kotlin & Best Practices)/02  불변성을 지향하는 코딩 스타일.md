### 불변성을 지향하는 코딩 스타일

코틀린 장인이 되기 위한 여정에서 가장 중요한 마음가짐을 하나 꼽으라면, 그것은 바로 \*\*"불변성(Immutability)을 지향하는 것"\*\*입니다. 이는 2장에서 배운 `val`과 `var`의 문법적 차이를 넘어선, 코드의 안전성과 예측 가능성을 결정짓는 핵심적인 철학입니다.

관용적인 코틀린 코드는 "모든 것은 `val`로 선언하되, 꼭 필요할 때만 `var`로 변경한다"는 원칙을 따릅니다.

-----

#### 1\. `val`의 힘: 예측 가능한 코드

상태가 변할 수 있는 `var` 변수는 코드에 '시간'이라는 복잡성 차원을 끌어들입니다. `var`로 선언된 변수를 볼 때마다 개발자는 "이 변수가 이 코드 블록의 어느 시점에서, 누구에 의해, 어떻게 변경될 수 있는가?"를 항상 추적해야 합니다. 이는 엄청난 인지적 부담이며 버그의 온상입니다.

반면 `val`로 선언된 변수(또는 프로퍼티)는 그 값이 불변임을 보장합니다. 코드를 읽는 순간 그 값은 영원히 고정됩니다. 우리는 더 이상 그 변수의 상태 변경을 추적할 필요가 없으며, 코드는 훨씬 더 단순하고 예측 가능해집니다.

앞선 섹션에서 배운 \*\*'표현식 위주의 프로그래밍'\*\*이 바로 이 불변성을 지향하는 스타일을 강력하게 뒷받침합니다. `if`나 `when`의 결과를 `var` 변수에 할당하는 대신, 표현식의 결과를 `val`에 직접 할당함으로써 우리는 더 안전하고 간결한 코드를 작성할 수 있습니다.

-----

#### 2\. 불변 컬렉션: API의 명확한 계약

코틀린은 컬렉션을 명확하게 두 종류로 분리하여 제공합니다.

  * **읽기 전용 인터페이스:** `List<T>`, `Set<T>`, `Map<K, V>`
  * **변경 가능 인터페이스:** `MutableList<T>`, `MutableSet<T>`, `MutableMap<K, V>`

장인의 코드는 항상 **읽기 전용 인터페이스를 우선적으로 사용합니다.** 함수나 프로퍼티를 외부에 노출할 때, `List`로 노출하는 것은 "이 함수(또는 프로퍼티)는 내부의 데이터를 변경하지 않을 것이며, 호출자(caller) 역시 이 데이터를 변경할 수 없다"는 명확한 **계약**을 만드는 것입니다.

데이터의 변경은 오직 클래스 내부에서, 명시적인 메서드를 통해서만 이루어져야 합니다.

```kotlin
class UserManager {
    // 1. 내부 구현체는 변경 가능한 MutableList로 데이터를 관리 (private)
    private val _users = mutableListOf<User>()

    // 2. 외부에 노출할 때는 변경이 불가능한 'List' 타입으로만 노출
    val users: List<User> = _users

    // 3. 데이터 변경은 오직 이 클래스가 제공하는 명시적인 함수를 통해서만 가능
    fun addUser(user: User) {
        _users.add(user)
    }
}
```

이 **'Backing Property'** 패턴은 캡슐화를 지키면서 불변성을 보장하는 가장 표준적인 코틀린 관용구입니다. 외부에서는 `userManager.users` 리스트에 절대로 요소를 추가하거나 삭제할 수 없습니다.

-----

#### 3\. 불변성이 빛을 발하는 순간: 스레드 안전성

불변성의 가장 큰 장점은 **동시성 프로그래밍**에서 나타납니다. **불변 객체(Immutable Object)는 그 자체로 100% 스레드 안전(Thread-safe)합니다.**

값이 절대 변하지 않는 데이터는 여러 코루틴이나 스레드가 동시에 접근하여 읽어도 아무런 문제가 발생하지 않습니다. 복잡한 `synchronized` 블록이나 `Lock` 같은 동기화 메커니즘이 전혀 필요 없습니다. 이는 Part 4에서 배운 코루틴 환경에서 코드를 극도로 단순하게 만들고, 레이스 컨디션(Race Condition)이나 동시 수정 오류 같은 가장 잡기 힘든 버그들을 원천적으로 제거해 줍니다.

-----

#### 4\. 상태 변경의 해법: `data class`의 `copy()`

물론 앱은 상태를 변경해야만 동작합니다. 불변성을 지향한다는 것은 상태를 변경하지 않는다는 뜻이 아니라, \*\*"기존 객체의 상태를 직접 변경하는 대신, 변경된 값을 가진 새로운 객체를 생성하여 대체한다"\*\*는 의미입니다.

이때 5장에서 배운 `data class`의 **`copy()`** 메서드가 핵심적인 역할을 합니다.

```kotlin
data class UserState(val name: String, val isLoggedIn: Boolean, val visitCount: Int)

val guestState = UserState("Guest", false, 0)

// 사용자가 로그인을 시도함 (상태 변경 발생)
// guestState.isLoggedIn = true // 이렇게 직접 수정하는 대신...

// copy()를 사용하여 isLoggedIn 값만 변경된 '새로운 객체'를 생성
val loggedInState = guestState.copy(isLoggedIn = true, visitCount = 1)

println(guestState)    // 원본은 전혀 변경되지 않음 (불변)
println(loggedInState) // 변경된 값을 가진 새로운 사본
```

**출력:**

```
UserState(name=Guest, isLoggedIn=false, visitCount=0)
UserState(name=Guest, isLoggedIn=true, visitCount=1)
```

이 패턴은 Jetpack Compose의 상태 관리나 현대적인 UI 프로그래밍의 핵심 원리이며, 프로그램의 상태 변경을 추적하기 쉽게 만들고 버그를 극적으로 줄여줍니다.

불변성은 코드를 작성할 때 스스로에게 거는 유익한 '제약'입니다. `val`, 불변 컬렉션, 그리고 `copy()`를 습관화하는 것은 더 안전하고, 더 예측 가능하며, 동시성 환경에 완벽하게 대비된 코드를 작성하는 장인의 길입니다.