### 효과적인 예외 처리 전략

견고한 소프트웨어는 예상치 못한 오류, 즉 \*\*예외(Exception)\*\*가 발생했을 때도 무너지지 않고 우아하게 대처할 수 있어야 합니다. 코틀린은 예외 처리에 대해 자바와는 근본적으로 다른, 매우 실용적인 철학을 가지고 있습니다.

#### 코틀린의 철학: 검사 예외(Checked Exceptions)는 없다

자바를 경험한 개발자라면 `throws IOException`과 같은 \*\*검사 예외(Checked Exception)\*\*에 익숙할 것입니다. 자바 컴파일러는 이러한 예외를 던질 가능성이 있는 메서드를 호출할 때마다, 개발자에게 `try-catch`로 감싸거나 자신도 `throws`로 선언하도록 강제했습니다. 이는 안정성을 높이려는 의도였지만, 실제로는 불필요한 보일러플레이트 코드와 의미 없는 예외 전가만을 양산한다는 비판을 받았습니다.

코틀린은 이 문제를 과감하게 해결했습니다. **코틀린에는 검사 예외가 존재하지 않습니다.** `IOException`이든 `SQLException`이든, 코틀린의 모든 예외는 \*\*검사되지 않은 예외(Unchecked Exception)\*\*로 취급됩니다. 컴파일러는 개발자에게 `try-catch`를 강요하지 않습니다.

이러한 자유에는 더 현명하게 대처해야 할 책임이 따릅니다. 코틀린의 관용적인 예외 처리 전략은 '모든 것을 잡으려' 하는 것이 아니라, \*\*'예측 가능한 실패는 타입 시스템으로 처리하고, 예외는 진정 예외적인 상황에만 사용한다'\*\*는 것입니다.

-----

#### 1\. `try-catch`를 표현식으로 활용하기

예외를 반드시 잡아서 처리해야 한다면, 코틀린은 `try-catch` 블록 역시 19.2에서 배운 \*\*표현식(Expression)\*\*으로 사용할 수 있게 합니다. 이는 `try`가 성공했을 때의 값 또는 `catch`가 잡았을 때의 대체 값을 변수에 직접 할당할 수 있게 해줍니다.

**Before (명령형 스타일)**

```kotlin
fun parseNumber(input: String): Int {
    var result: Int
    try {
        result = input.toInt()
    } catch (e: NumberFormatException) {
        result = 0 // 예외 발생 시 var 변수에 기본값 할당
    }
    return result
}
```

**After (표현식 스타일)**
`var` 변수 선언 없이 `val`에 직접 결과를 할당할 수 있습니다.

```kotlin
fun parseNumber(input: String): Int {
    val result = try {
        input.toInt() // try 블록의 마지막 표현식이 결과
    } catch (e: NumberFormatException) {
        0 // catch 블록의 마지막 표현식이 결과
    }
    return result
}
```

이 패턴은 예외가 발생할 수 있는 코드에 대한 '안전한 기본값'을 제공하는 가장 간결한 방법입니다.

-----

#### 2\. 예외 대신 `null` 반환하기 (널 안정성 활용)

더 코틀린스러운 방법은, 예측 가능한 실패(예: '값을 찾지 못함')를 예외로 간주하지 않는 것입니다. `UserNotFoundException`을 던지는 대신, 단순히 **`null`을 반환**하면 됩니다.

**Before (예외 사용)**

```kotlin
fun findUser(id: String): User {
    val user = db.find(id)
    if (user == null) {
        throw UserNotFoundException() // 예외 발생
    }
    return user
}
// 호출부: try-catch가 강제됨
// try { ... } catch (e: UserNotFoundException) { ... }
```

**After (널 가능 타입 반환)**

```kotlin
fun findUser(id: String): User? { // 반환 타입을 Nullable로 변경
    return db.find(id) // 찾으면 User 반환, 없으면 null 반환
}

// 호출부: 컴파일러가 널 처리를 강제함 (try-catch 대신)
val user = findUser("123")
user?.let {
    println("${it.name}님 환영합니다.")
} ?: println("사용자를 찾을 수 없습니다.")
```

코틀린의 강력한 널 안정성(`?.`, `?:` 등)을 활용하면, `try-catch` 블록 없이도 실패 케이스를 훨씬 더 우아하고 안전하게 처리할 수 있습니다.

-----

#### 3\. 예외 대신 `Result` 타입 반환하기 (Sealed 클래스 활용)

`null`을 반환하는 것은 '데이터가 없음'을 표현할 수는 있지만, '왜' 실패했는지(예: 네트워크 오류인지, 사용자를 못 찾은 것인지)에 대한 풍부한 정보를 전달하기는 어렵습니다.

가장 현대적이고 관용적인 코틀린 패턴은 5장에서 배운 \*\*`Sealed 클래스`\*\*를 활용하여, 성공과 실패의 모든 경우의 수를 담는 \*\*`Result` 래퍼(Wrapper)\*\*를 반환하는 것입니다. (Kotlin 1.3부터는 표준 라이브러리에 `kotlin.Result<T>`가 내장되어 있습니다.)

```kotlin
// 1. 성공과 실패를 표현하는 Sealed 클래스 정의
sealed class Result<out T> {
    data class Success<out T>(val data: T) : Result<T>()
    data class Error(val message: String, val cause: Exception? = null) : Result<Nothing>()
}

class UserService {
    fun register(username: String): Result<User> {
        if (username.length < 4) {
            // 2. 실패 케이스를 Error 객체로 반환
            return Result.Error("사용자 이름은 4자 이상이어야 합니다.")
        }
        
        try {
            val user = User(username)
            db.save(user)
            // 3. 성공 케이스를 Success 객체로 래핑하여 반환
            return Result.Success(user)
        } catch (e: DbException) {
            return Result.Error("데이터베이스 저장 실패", e)
        }
    }
}

// 호출부: when 표현식으로 모든 경우를 안전하게 처리 (else가 필요 없음)
val registrationResult = userService.register("abc")
when (registrationResult) {
    is Result.Success -> println("환영합니다! ${registrationResult.data.name}님")
    is Result.Error -> println("등록 실패: ${registrationResult.message}")
}
```

이 패턴은 **함수 시그니처만 보고도 이 함수가 어떤 종류의 성공과 실패를 반환할 수 있는지 명확히 알 수 있게** 해줍니다. 이는 `try-catch` 블록을 코드베이스에서 거의 완전히 추방하고, 실패를 '예외적인 버그'가 아닌 '예측 가능한 데이터 흐름'으로 다루게 하는 가장 진보한 코틀린 관용구입니다.

**결론:** 예외는 프로그래머의 실수나 복구 불가능한 시스템 오류(예: `OutOfMemoryError`)처럼 진정으로 **예외적인(exceptional)** 상황을 위해서만 남겨두고, 예측 가능한 실패(Not Found, Invalid Input 등)는 \*\*타입 시스템(`null` 또는 `Result`)\*\*으로 처리하는 것이 장인의 길입니다.