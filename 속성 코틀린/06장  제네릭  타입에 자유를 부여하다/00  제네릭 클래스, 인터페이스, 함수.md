### 제네릭 클래스, 인터페이스, 함수

제네릭은 클래스, 인터페이스, 함수 등 다양한 곳에 적용될 수 있습니다.

#### 제네릭 클래스 (Generic Class)

가장 대표적인 제네릭의 활용처입니다. 클래스를 정의할 때, 클래스 이름 뒤에 꺾쇠괄호(`< >`)를 사용하고 그 안에 \*\*타입 파라미터(Type Parameter)\*\*를 선언합니다. 타입 파라미터의 이름은 보통 `T`(Type)를 관례적으로 사용합니다.

어떤 타입의 값이든 담을 수 있는 `Box` 클래스를 제네릭으로 만들어 봅시다.

```kotlin
// T는 '어떤 타입이든 될 수 있다'는 의미의 플레이스홀더입니다.
class Box<T>(val item: T) {

    fun getItem(): T {
        return item
    }
}
```

이제 이 `Box` 클래스의 인스턴스를 만들 때, 타입 파라미터 `T`에 `Int`, `String` 등 원하는 실제 타입을 지정해주면 됩니다.

```kotlin
fun main() {
    // T를 Int로 지정하여 정수를 담는 상자를 만듭니다.
    val intBox = Box<Int>(100)
    val intValue: Int = intBox.getItem() // 꺼낼 때 타입 변환이 필요 없습니다.
    println(intValue) // 출력: 100

    // T를 String으로 지정하여 문자열을 담는 상자를 만듭니다.
    // 생성자 인자를 통해 T가 String임이 명확하므로, <String>은 생략 가능(타입 추론)
    val stringBox = Box("Hello Generic")
    val stringValue: String = stringBox.getItem() // 역시 타입 변환이 필요 없습니다.
    println(stringValue) // 출력: Hello Generic

    // intBox.item = "문자열" // 컴파일 오류! intBox는 Int 타입만 담을 수 있습니다.
}
```

제네릭 클래스 덕분에 우리는 단 하나의 `Box` 클래스 정의만으로, 어떤 타입에 대해서도 타입 안전성을 보장받는 상자를 만들 수 있게 되었습니다.

#### 제네릭 인터페이스 (Generic Interface)

인터페이스 역시 제네릭을 사용하여 일반화된 규약을 정의할 수 있습니다.

```kotlin
interface Serializer<T> {
    fun serialize(item: T): String
    fun deserialize(source: String): T
}
```

이 인터페이스를 구현하는 클래스는 `T`에 특정 타입을 지정하여 해당 타입에 대한 직렬화/역직렬화 로직을 완성해야 합니다.

```kotlin
class PersonSerializer : Serializer<Person> {
    override fun serialize(item: Person): String {
        // Person 객체를 JSON 문자열 등으로 변환하는 로직
        return "{ 'name': '${item.name}' }"
    }

    override fun deserialize(source: String): Person {
        // JSON 문자열을 Person 객체로 변환하는 로직
        return Person("Deserialized Name", 0) // 간단한 예시
    }
}
```

#### 제네릭 함수 (Generic Function)

클래스나 인터페이스 전체가 아닌, 특정 함수만 제네릭으로 만들고 싶을 때 사용합니다. 이때는 **함수 이름 앞에** 타입 파라미터를 선언합니다.

```kotlin
// 함수 이름 앞에 타입 파라미터 <T>를 선언합니다.
fun <T> printItem(item: T) {
    println("Item is: $item")
}

fun main() {
    // 함수를 호출할 때 전달하는 인자의 타입을 보고 컴파일러가 T의 타입을 추론합니다.
    printItem(42)          // T는 Int로 추론됨
    printItem("Kotlin")    // T는 String으로 추론됨
    printItem(Person("Alice", 30)) // T는 Person으로 추론됨
}
```

제네릭 함수를 사용하면, 다양한 타입의 인자를 받아 동일한 로직을 수행하면서도 완전한 타입 안전성을 유지하는 유틸리티 함수를 손쉽게 만들 수 있습니다.

제네릭은 코드의 중복을 줄이고 유연성과 재사용성을 극대화하는 동시에, 컴파일러가 타입을 검사하여 런타임 오류를 방지해주는 강력한 도구입니다. 이는 코틀린으로 견고하고 확장성 있는 소프트웨어를 만드는 데 필수적인 개념입니다.