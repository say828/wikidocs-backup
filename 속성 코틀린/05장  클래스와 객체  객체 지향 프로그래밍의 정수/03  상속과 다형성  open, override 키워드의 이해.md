### 상속과 다형성: open, override 키워드의 이해

객체 지향 프로그래밍의 강력한 기둥 중 하나는 \*\*상속(Inheritance)\*\*입니다. 상속은 기존의 클래스(**부모 클래스** 또는 **슈퍼클래스**)를 기반으로, 그 속성과 기능을 물려받는 새로운 클래스(**자식 클래스** 또는 **서브클래스**)를 만들 수 있는 메커니즘입니다.

'개'는 '동물'의 한 종류이고, '고양이' 역시 '동물'의 한 종류입니다. 이때 '개'와 '고양이' 클래스는 '이름'이라는 속성이나 '먹는다'라는 행동을 가진 '동물' 클래스로부터 이러한 공통된 특징을 물려받을 수 있습니다. 이를 통해 코드의 중복을 줄이고, 클래스 간에 논리적인 **'is-a(은/는 \~이다)'** 관계를 형성하여 프로그램을 더 체계적으로 구조화할 수 있습니다.

-----

#### 상속을 위한 준비: `open` 키워드

자바와 달리, **코틀린의 모든 클래스와 메서드는 기본적으로 `final`입니다.** `final`이라는 것은 '마지막'이라는 의미로, 더 이상 변경하거나 확장할 수 없음을 뜻합니다. 즉, 코틀린에서는 어떤 클래스도 기본적으로는 다른 클래스가 상속받을 수 없도록 굳게 닫혀 있습니다.

이는 '상속을 위해 특별히 설계하고 문서화하지 않았다면, 상속을 금지하는 것이 좋다'라는 이펙티브 자바의 철학을 따른, 안정성을 위한 코틀린의 중요한 설계 결정입니다.

만약 어떤 클래스를 다른 클래스가 상속할 수 있도록 허용하고 싶다면, 반드시 **`open`** 키워드를 사용하여 상속에 대해 '열려 있음'을 명시적으로 선언해야 합니다.

```kotlin
// open 키워드를 사용하여 이 클래스가 상속될 수 있음을 알립니다.
open class Animal(val name: String) {

    // 메서드 또한 기본적으로 final이므로, 오버라이딩을 허용하려면 open을 붙여야 합니다.
    open fun makeSound() {
        println("동물이 소리를 냅니다.")
    }
}
```

#### 클래스 상속하기: `:` 와 `override` 키워드

자식 클래스를 정의할 때는 클래스 이름 뒤에 콜론(`:`)을 붙이고, 상속받을 부모 클래스의 생성자를 호출하는 형식으로 작성합니다.

부모 클래스로부터 물려받은 `open`된 메서드를 자식 클래스에서 자신만의 방식으로 재정의하는 것을 \*\*오버라이딩(Overriding)\*\*이라고 합니다. 이때, 자식 클래스의 메서드 앞에는 반드시 **`override`** 키워드를 붙여야 합니다.

`open`과 `override`는 짝을 이루는 계약과 같습니다. 부모는 `open`으로 변경을 허락하고, 자식은 `override`로 변경 사실을 명확히 알려야 합니다.

```kotlin
// Animal 클래스를 상속받는 Dog 클래스
class Dog(name: String) : Animal(name) {

    // Animal의 makeSound() 메서드를 재정의합니다. override는 필수입니다.
    override fun makeSound() {
        println("멍멍!")
    }
}

class Cat(name: String) : Animal(name) {

    override fun makeSound() {
        println("야옹~")
    }
}
```

-----

#### 다형성 (Polymorphism): 여러 얼굴을 가진 객체

상속의 진정한 힘은 \*\*다형성(Polymorphism)\*\*에서 발현됩니다. 다형성은 '여러(poly) 가지 형태(morph)'라는 의미로, **하나의 타입(부모 클래스 타입)으로 여러 가지 다른 형태의 객체(자식 클래스 객체)를 참조**할 수 있는 성질을 말합니다.

```kotlin
fun main() {
    // 변수의 타입은 Animal이지만, 실제 객체는 Dog입니다.
    val myPet: Animal = Dog("해피")
    
    // 변수의 타입은 Animal이지만, 실제 객체는 Cat입니다.
    val streetCat: Animal = Cat("길냥이")

    // myPet.makeSound()를 호출하면 어떤 메서드가 실행될까요?
    myPet.makeSound()     // 출력: 멍멍!
    streetCat.makeSound() // 출력: 야옹~
}
```

`myPet`과 `streetCat` 변수는 모두 `Animal` 타입으로 선언되었지만, `makeSound()` 메서드를 호출하자 실제 담겨있는 객체인 `Dog`와 `Cat`의 오버라이딩된 메서드가 각각 실행되었습니다. 이처럼 컴파일 시점에는 변수가 `Animal` 타입으로 보이지만, 실제 실행 시점에는 각 객체의 실제 타입에 맞는 메서드가 호출되는 것이 바로 다형성의 핵심입니다.

이를 활용하면 다양한 종류의 동물들을 `Animal`이라는 단일 타입의 리스트에 담아두고, 각 동물의 종류를 신경 쓰지 않고도 "모두 소리를 내봐\!"라는 동일한 메시지를 보내 각자 알아서 소리를 내게 만들 수 있습니다.

```kotlin
val animals: List<Animal> = listOf(Dog("멍멍이"), Cat("야옹이"), Dog("바둑이"))

for (animal in animals) {
    animal.makeSound() // 각 동물이 알아서 자신의 소리를 냅니다.
}
```

출력:

```
멍멍!
야옹~
멍멍!
```

상속과 다형성은 코드를 유연하고 확장 가능하게 만들어주는 객체 지향의 근간입니다. 코틀린은 `open`과 `override` 키워드를 통해 이를 더욱 명시적이고 안전하게 만들어 줍니다.