### 클래스, 프로퍼티, 메서드 정의

객체를 만들기 위한 설계도, 즉 클래스를 정의하는 것부터 시작해 봅시다. 클래스는 객체의 상태를 나타내는 \*\*프로퍼티(Property)\*\*와 객체의 행동을 나타내는 \*\*메서드(Method)\*\*로 구성됩니다.

#### 클래스와 객체 생성

`class` 키워드를 사용하여 클래스를 정의합니다. 가장 간단한 형태의 `Person` 클래스를 만들어 보겠습니다.

```kotlin
// 'Person'이라는 이름의 클래스(설계도)를 정의
class Person {
    // 클래스의 멤버(프로퍼티와 메서드)가 이 안에 위치합니다.
}
```

이 설계도를 바탕으로 실제 `Person` 객체를 만들려면, 생성자를 호출하듯 클래스 이름을 호출하면 됩니다. 자바와 달리 코틀린에서는 객체를 생성할 때 `new` 키워드를 사용하지 않습니다.

```kotlin
fun main() {
    // Person 클래스의 인스턴스(객체)를 생성하여 변수 john에 할당
    val john = Person()
    val alice = Person()

    println(john)
    println(alice)
}
```

`john`과 `alice`는 똑같은 `Person` 클래스로부터 만들어졌지만, 서로 다른 고유한 객체입니다.

#### 프로퍼티 (Properties): 객체의 상태

**프로퍼티**는 객체가 가지는 데이터나 상태를 나타냅니다. 클래스 내부에 변수를 선언하는 것과 동일한 방식으로 정의하며, `val` 또는 `var`를 사용할 수 있습니다.

```kotlin
class Person {
    // 프로퍼티 정의
    var name: String = "익명" // 이름 (변경 가능)
    val birthYear: Int = 2000 // 태어난 해 (변경 불가능)
}
```

자바에서는 필드를 `private`으로 선언하고 `getter/setter` 메서드를 수동으로 만드는 것이 일반적이지만, 코틀린에서는 프로퍼티를 선언하는 것만으로 이 모든 것이 간결하게 처리됩니다.

이렇게 정의된 프로퍼티는 객체를 통해 점(`.`)을 찍어 접근할 수 있습니다.

```kotlin
fun main() {
    val person = Person()
    
    // 프로퍼티 값 읽기
    println(person.name) // 출력: 익명
    
    // var 프로퍼티 값 변경하기
    person.name = "홍길동"
    println(person.name) // 출력: 홍길동

    // person.birthYear = 2001 // 컴파일 오류! val 프로퍼티는 값을 변경할 수 없습니다.
}
```

#### 메서드 (Methods): 객체의 행동

**메서드**는 클래스 내부에 정의된 함수로, 객체가 수행할 수 있는 행동이나 기능을 나타냅니다.

`Person` 클래스에 자기소개를 하는 `introduce()` 메서드를 추가해 봅시다.

```kotlin
class Person {
    var name: String = "익명"
    val birthYear: Int = 2000

    // 메서드 정의
    fun introduce() {
        // 메서드 내부에서는 클래스의 프로퍼티에 직접 접근할 수 있습니다.
        println("안녕하세요, 저는 ${name}입니다. ${birthYear}년에 태어났습니다.")
    }
}
```

메서드 역시 객체를 통해 점(`.`)을 찍어 호출합니다.

```kotlin
fun main() {
    val person = Person()
    person.name = "김코틀"
    
    // person 객체의 introduce 메서드 호출
    person.introduce() 
    // 출력: 안녕하세요, 저는 김코틀입니다. 2000년에 태어났습니다.
}
```

이처럼 클래스는 관련된 데이터(프로퍼티)와 로직(메서드)을 하나의 단위로 묶어줌으로써, 코드를 더 체계적이고 이해하기 쉽게 만들어주는 객체 지향 프로그래밍의 핵심적인 출발점입니다.