### 추상 클래스(Abstract Classes)와 인터페이스(Interfaces)

상속을 사용하다 보면, 부모 클래스의 역할이 공통된 속성과 기능을 물려주는 것일 뿐, 그 자체로 온전한 객체가 될 수 없는 경우가 있습니다. '동물'이라는 개념은 존재하지만, 세상에 '그냥 동물'이라는 실체는 없습니다. '개', '고양이'와 같이 구체적인 종류가 있을 뿐입니다.

이처럼, **불완전한 설계도** 역할을 하여 다른 클래스들이 무엇을 구현해야 하는지에 대한 \*\*규약(Contract)\*\*을 정의할 때 사용하는 것이 **추상 클래스**와 **인터페이스**입니다.

-----

#### 추상 클래스 (Abstract Class): 미완성된 설계도

**추상 클래스**는 이름 그대로 '추상적인' 클래스입니다. `abstract` 키워드를 사용하여 정의하며, 스스로는 객체(인스턴스)를 만들 수 없고 오직 다른 클래스에게 상속될 목적으로만 존재합니다.

**특징:**

  * **추상 메서드**: 본문(`{...}`)이 없는 미완성된 메서드를 가질 수 있습니다. 추상 클래스를 상속받는 자식 클래스는 이 추상 메서드를 **반드시 오버라이딩**하여 완성해야 합니다.
  * **일반 메서드**: 완성된 형태의 일반 메서드도 가질 수 있습니다. 이는 자식 클래스들이 공통으로 사용할 기능을 미리 구현해 놓은 것입니다.
  * **프로퍼티**: 상태를 저장하는 프로퍼티를 가질 수 있습니다.

**비유:** 추상 클래스는 '자동차 조립 키트 🚗'와 같습니다. 엔진이나 바퀴처럼 모든 자동차에 공통으로 필요한 부품(일반 메서드)은 이미 만들어져 있지만, 차체의 디자인이나 색상(추상 메서드)은 비어있어서, 이를 기반으로 '세단'이나 'SUV'를 만드는 사람이 직접 결정하고 완성해야 하는 것과 같습니다.

```kotlin
// abstract 키워드로 추상 클래스 정의
abstract class Animal(val name: String) {

    // 일반 메서드 (구현이 완료됨)
    fun eat() {
        println("${name}이(가) 밥을 먹습니다.")
    }

    // 추상 메서드 (본문이 없음)
    // 자식 클래스는 반드시 makeSound를 오버라이딩 해야 함
    abstract fun makeSound()
}

class Dog(name: String) : Animal(name) {
    override fun makeSound() {
        println("멍멍!")
    }
}

fun main() {
    // val animal = Animal("동물") // 컴파일 오류! 추상 클래스는 객체를 만들 수 없습니다.
    val dog = Dog("해피")
    dog.eat()       // 부모로부터 물려받은 일반 메서드 호출
    dog.makeSound() // 자식이 직접 구현한 추상 메서드 호출
}
```

-----

#### 인터페이스 (Interface): 지켜야 할 약속

**인터페이스**는 어떤 객체가 가져야 할 행동, 즉 기능의 \*\*명세(Specification)\*\*만을 정의한 순수한 규약입니다. 클래스는 이 인터페이스를 \*\*구현(implement)\*\*함으로써, "나는 인터페이스에 명시된 모든 기능을 제공할 것을 약속합니다"라고 선언하는 것과 같습니다.

**특징:**

  * **다중 구현**: 클래스는 단 하나의 부모 클래스만 상속받을 수 있지만, 인터페이스는 **여러 개를 동시에 구현**할 수 있습니다. 이것이 추상 클래스와의 가장 결정적인 차이점입니다.
  * **상태 저장 불가**: 인터페이스는 추상 클래스와 달리 그 자체로 상태(프로퍼티의 값을 저장하는 백킹 필드)를 가질 수 없습니다.
  * **디폴트 메서드**: 코틀린의 인터페이스는 메서드의 기본 구현(**디폴트 메서드**)을 포함할 수 있어, 이를 구현하는 클래스가 선택적으로 오버라이딩할 수 있도록 합니다.

**비유:** 인터페이스는 '운전면허증 📜'이나 '비행 자격증'과 같습니다. '사람'과 '로봇'은 전혀 다른 클래스이지만, 둘 다 '운전'이라는 인터페이스를 구현하여 `drive()` 기능을 제공할 수 있습니다. 또한, '새'는 '동물'을 상속받으면서 동시에 '비행' 인터페이스를 구현하여 `fly()` 기능을 가질 수 있습니다.

```kotlin
interface Flyable {
    fun fly() // 본문이 없는 추상 메서드
}

interface Swimmable {
    // 기본 구현을 가진 디폴트 메서드
    fun swim() {
        println("첨벙첨벙 헤엄칩니다.")
    }
}

// 오리는 Animal을 상속받고, Flyable과 Swimmable 인터페이스를 모두 구현합니다.
class Duck(name: String) : Animal(name), Flyable, Swimmable {
    override fun makeSound() {
        println("꽥꽥!")
    }

    override fun fly() {
        println("힘차게 날아오릅니다.")
    }

    // Swimmable의 swim()은 디폴트 구현이 있지만, 오리만의 방식으로 재정의할 수도 있습니다.
    override fun swim() {
        println("우아하게 물 위를 떠다닙니다.")
    }
}
```

-----

#### 추상 클래스 vs. 인터페이스: 언제 무엇을 쓸까?

| 구분 | 추상 클래스 (Abstract Class) | 인터페이스 (Interface) |
| :--- | :--- | :--- |
| **핵심 목적** | **공통된 속성과 기능**을 공유 | **행동(기능)에 대한 규약**을 정의 |
| **관계** | 강한 **is-a** 관계 (개는 동물이다) | 약한 **can-do** 관계 (새는 날 수 있다) |
| **다중 상속** | **불가능** (단일 상속만 허용) | **가능** (여러 인터페이스 구현) |
| **상태 저장** | **가능** (프로퍼티 소유) | **불가능** (백킹 필드 없는 프로퍼티만) |
| **생성자** | **있음** | **없음** |

  * **추상 클래스를 사용해야 할 때:** 연관성이 높은 클래스들 사이에서 많은 코드나 상태를 공유하고 싶을 때. 클래스 계층 구조를 명확히 하고 싶을 때.
  * **인터페이스를 사용해야 할 때:** 서로 관련 없는 클래스들에게 공통된 기능(행동)을 부여하고 싶을 때. 다중 상속의 효과가 필요할 때.

많은 경우, 이 둘은 함께 사용되어 유연하고 확장성 있는 설계를 만들어냅니다.