### 코틀린에서 자바 코드 호출하기

코틀린에서 자바 코드를 호출하는 경험은 너무나 자연스러워서, 이것이 '상호운용성'이라는 특별한 기능이라는 사실조차 잊게 만들 정도입니다. 코틀린 컴파일러는 자바 코드를 코틀린의 관용구에 맞게 자동 변환하여 개발자에게 보여줍니다.

#### 1\. 마법처럼 느껴지는 '합성 프로퍼티(Synthetic Properties)'

자바는 필드(field)를 `private`으로 선언하고, 이에 접근하기 위한 `getter`와 `setter` 메서드(예: `getName()`, `setName()`)를 만드는 것이 표준적인 관례(JavaBeans convention)입니다.

코틀린은 이러한 관례를 인지하고, 이 `getter/setter` 쌍을 코틀린의 네이티브 \*\*프로퍼티(property)\*\*로 자동 변환하여 노출합니다. 이를 **합성 프로퍼티**라고 합니다.

**[자바 코드 예시: `JavaPerson.java`]**

```java
public class JavaPerson {
    private final String name; // final 필드는 getter만 가짐
    private int age;           // non-final 필드는 getter/setter 모두 가짐

    public JavaPerson(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public void sayHello() {
        System.out.println("Hello from Java!");
    }
}
```

**[코틀린에서 위 자바 코드 호출하기: `Main.kt`]**

```kotlin
fun main() {
    // 자바 클래스 임포트 및 생성 (new 키워드 없음)
    val javaPerson = JavaPerson("Duke")

    // 1. 합성 프로퍼티 활용
    // javaPerson.getName() 대신 'name' 프로퍼티로 접근
    val name = javaPerson.name 

    // javaPerson.setAge(45) 대신 'age' 프로퍼티에 값 할당
    javaPerson.age = 45

    println("이름: $name, 나이: ${javaPerson.age}") // age 프로퍼티로 값 읽기

    // 2. 일반 메서드는 그대로 호출
    javaPerson.sayHello()
}
```

개발자는 더 이상 `get`/`set` 접두사를 사용할 필요 없이, 자바 클래스를 마치 코틀린 `data class`처럼 자연스럽게 다룰 수 있습니다.

#### 2\. 상호운용성의 가장 큰 위험: 플랫폼 타입(Platform Types)

코틀린의 가장 큰 축복은 컴파일 시점의 널 안정성(`String` vs `String?`)입니다. 하지만 자바에는 이런 구분이 없습니다. 자바의 모든 참조 타입은 `null`이 될 수 있습니다.

코틀린 컴파일러가 널 정보가 없는 자바 타입을 만나면, 이를 `String`으로 처리해야 할지 `String?`로 처리해야 할지 결정할 수 없습니다. 이때 코틀린이 사용하는 특별한 타입이 바로 \*\*플랫폼 타입(Platform Type)\*\*이며, IDE에서는 보통 \*\*`String!`\*\*처럼 느낌표(`!`)로 표시됩니다.

`String!`의 의미는 이렇습니다: **"이것은 자바에서 온 타입이라 널일 수도, 아닐 수도 있습니다. 컴파일러는 일단 당신(개발자)을 믿고 널 검사를 통과시키겠습니다. 책임은 당신에게 있습니다."**

이는 코틀린의 널 안정성 시스템에 일시적으로 구멍을 내는 것과 같으며, 코틀린 코드에서 `NullPointerException`(NPE)이 터질 수 있는 거의 유일한 통로입니다.

**[위험한 코드]**

```java
// JavaUtils.java
public class JavaUtils {
    public static String getPossibleNullName() {
        return null; // 자바에서는 null 반환이 합법적
    }
}
```

```kotlin
// Main.kt
fun printNameLength() {
    // javaName은 'String!' 타입 (플랫폼 타입)
    val javaName = JavaUtils.getPossibleNullName() 

    // 💥 런타임 오류: NullPointerException 발생!
    // 컴파일러는 javaName을 Non-null처럼 다루는 것을 막지 않는다.
    println(javaName.length) 
}
```

#### 3\. 장인의 해법: 플랫폼 타입을 즉시 교정하기

자바 코드에서 값을 받아오는 즉시, 해당 플랫폼 타입을 코틀린의 명시적인 널 가능/불가능 타입으로 변환하여 널 안정성 시스템의 통제 하에 두는 것이 관용적인 해법입니다.

```kotlin
fun printNameLengthSafe() {
    val javaName: String? = JavaUtils.getPossibleNullName() // 1. 즉시 Nullable 타입으로 받기
    
    // 2. 이제 코틀린의 안전한 널 처리 메커니즘을 사용할 수 있음
    println(javaName?.length ?: 0)
}
```

자바 API를 호출할 때는 반환 값이 `null`일 수 있다는 가정 하에, 항상 `Nullable(?)` 타입으로 먼저 받거나 엘비스 연산자(`?:`)로 기본값을 제공하여, `NPE`가 코틀린 코드베이스로 전파되는 것을 즉시 차단해야 합니다.