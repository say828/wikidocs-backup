### 플랫폼 타입과 널 가능성 어노테이션

앞서 `21.1`에서 코틀린-자바 상호운용성의 가장 큰 위험은 코틀린의 널 안정성을 무력화시키는 \*\*플랫폼 타입(`String!`)\*\*이라고 강조했습니다. 코틀린 컴파일러는 자바 코드의 `null` 가능 여부를 알지 못하기 때문에, 개발자에게 모든 책임을 떠넘깁니다.

그렇다면 이 위험한 '추측의 영역'을 없애고, 자바 API조차 코틀린의 널 안정성 시스템 안으로 완벽하게 끌어들일 방법은 없을까요?

해답은 자바 코드에 \*\*널 가능성 어노테이션(Nullability Annotations)\*\*을 추가하는 것입니다.

-----

#### 코틀린 컴파일러와 어노테이션의 계약

코틀린 컴파일러는 `org.jetbrains.annotations`(@NotNull, @Nullable)나 JSR 305(@Nonnull, @Nullable) 등 표준 널 가능성 어노테이션을 인지하도록 설계되었습니다. 자바 코드에 이 어노테이션들이 붙어있으면, 코틀린 컴파일러는 플랫폼 타입을 사용하는 대신 이 '힌트'를 절대적으로 신뢰하여 해당 타입을 명확한 코틀린 타입으로 변환합니다.

  * **Java `@NotNull`** + `String` → **Kotlin `String`** (Non-nullable)
  * **Java `@Nullable`** + `String` → **Kotlin `String?`** (Nullable)
  * **Annotation 없음** + `String` → **Kotlin `String!`** (Platform Type - 위험\!)

-----

#### 예제: 어노테이션으로 자바 API 교정하기

자바 API가 다음과 같이 작성되어 있다고 가정해 봅시다.

**[어노테이션이 적용된 자바 코드: `JavaUserApi.java`]**

```java
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

public class JavaUserApi {

    // 이 메서드는 절대 null을 반환하지 않음을 보장합니다.
    @NotNull
    public String findUserName(int id) {
        return "User" + id;
    }

    // 이 메서드는 null을 반환할 수도 있음을 명시합니다.
    @Nullable
    public String findUserNickname(int id) {
        if (id == 1) {
            return "Duke";
        }
        return null; // null 반환이 합법적
    }

    // 어노테이션이 없는 레거시 메서드
    public String getLegacyStatus(int id) {
        return "Legacy";
    }
}
```

**[위 API를 호출하는 코틀린 코드]**

```kotlin
fun main() {
    val api = JavaUserApi()

    // 1. @NotNull 처리
    // 컴파일러가 API를 'fun findUserName(Int): String' (Non-null)으로 인식합니다.
    val name: String = api.findUserName(1)
    // val nullableName: String? = api.findUserName(1) // 경고는 뜨지만 할당은 가능

    // 2. @Nullable 처리
    // 컴파일러가 API를 'fun findUserNickname(Int): String?' (Nullable)로 인식합니다.
    val nickname: String? = api.findUserNickname(1)
    
    // val errorName: String = api.findUserNickname(1) 
    // 💥 컴파일 오류! Type mismatch.
    // Nullable 타입을 Non-null 변수에 할당할 수 없습니다.

    // 3. 어노테이션 없는 레거시 처리
    // 컴파일러는 이 API를 'fun getLegacyStatus(Int): String!' (플랫폼 타입)으로 인식합니다.
    val status: String = api.getLegacyStatus(1) // 컴파일은 통과하지만, 런타임 NPE 위험!
}
```

가장 주목해야 할 부분은 2번(`@Nullable`)입니다. 자바 코드에 `@Nullable` 어노테이션 하나를 붙여준 덕분에, 코틀린 개발자가 실수로 널 값을 Non-null 변수에 할당하려는 시도가 \*\*런타임 `NPE`\*\*에서 **컴파일 타임 오류**로 바뀌었습니다. 즉, 자바 API를 코틀린의 널 안정성 시스템 안으로 완벽하게 편입시킨 것입니다.

-----

**장인의 황금률:**
만약 당신이 코틀린에서 호출해야 할 자바 라이브러리나 레거시 코드를 직접 제어할 수 있다면, **모든 public 메서드의 파라미터와 반환 타입에 `@NotNull` 또는 `@Nullable` 어노테이션을 붙이는 것**이 상호운용성을 위한 가장 중요하고 가치 있는 작업입니다. 이는 코틀린 생태계 전체의 안전성에 기여하는 일입니다.

이것으로 자바와의 상호운용성을 다루는 21장을 마칩니다. 코틀린은 자바를 매끄럽게 호출하지만(`합성 프로퍼티`), `플랫폼 타입`이라는 위험을 안고 있습니다. 반대로 자바는 코틀린의 고급 기능을 직접 이해하지 못하므로 `@JvmStatic` 같은 어노테이션 번역기가 필요합니다. 그리고 이 두 세계를 잇는 다리를 가장 안전하게 만드는 시멘트가 바로 `@Nullable`과 `@NotNull` 어노테이션입니다.