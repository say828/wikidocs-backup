### 지연 연산(Lazy Operations): Sequence의 힘

`map`, `filter`와 같은 컬렉션 함수들은 매우 편리하지만, 각 연산이 실행될 때마다 중간 결과를 담는 **새로운 컬렉션**을 생성한다는 특징이 있습니다. 데이터의 크기가 작을 때는 문제가 되지 않지만, 수백만 개의 요소를 가진 거대한 컬렉션을 여러 단계에 걸쳐 처리한다면 어떨까요?

```kotlin
val bigList = (1..1_000_000).toList()

val result = bigList
    .filter { it % 2 == 0 } // 1. 50만 개의 요소를 가진 새로운 List 생성
    .map { it * 2 }        // 2. 50만 개의 요소를 가진 또 다른 List 생성
    .take(5)               // 3. 5개의 요소를 가진 최종 List 생성

println(result)
```

위 코드는 최종적으로 5개의 요소만 필요함에도 불구하고, 중간 과정에서 두 번에 걸쳐 총 100만 개의 요소를 담는 거대한 리스트를 생성합니다. 이는 메모리와 계산 시간 측면에서 매우 비효율적입니다.

이러한 문제를 해결하기 위해 코틀린은 \*\*지연 연산(Lazy Operation)\*\*을 지원하는 \*\*`Sequence`\*\*를 제공합니다.

-----

#### Sequence란?

\*\*`Sequence`\*\*는 컬렉션의 데이터를 **한 번에 하나씩** 처리하는 특별한 타입의 컬렉션입니다. 일반적인 컬렉션 연산이 **조급한(Eager) 연산**으로 전체 데이터를 한 번에 처리하고 중간 컬렉션을 만드는 반면, `Sequence`는 **게으른(Lazy) 연산**을 수행합니다.

**비유:**

  * **`List` (Eager)**: 빵 공장에서 밀가루를 모두 반죽하여 빵 1000개를 한 번에 만든 뒤(1단계), 그 빵 1000개에 모두 크림을 바르고(2단계), 그중 5개를 포장하는(3단계) 방식입니다.
  * **`Sequence` (Lazy)**: 빵을 딱 1개만 만듭니다. 그 빵에 크림을 바르고(2단계), 포장까지 마칩니다(3단계). 이 과정을 필요한 빵 5개를 모두 얻을 때까지 딱 5번만 반복합니다.

`Sequence`는 최종 연산(예: `toList()`, `count()`, `first()`)이 호출되기 전까지는 아무런 계산도 하지 않고 대기합니다. 최종 연산이 호출되는 순간, 각 요소는 전체 파이프라인(`filter` -\> `map` -\> `take`)을 개별적으로 통과하며, 중간 컬렉션은 전혀 생성되지 않습니다.

-----

#### Sequence 사용하기

기존 컬렉션을 `Sequence`로 바꾸는 것은 매우 간단합니다. `asSequence()` 확장 함수를 호출하기만 하면 됩니다.

```kotlin
val bigList = (1..1_000_000).toList()

val result = bigList.asSequence() // 👈 Sequence로 전환!
    .filter {
        // println("filtering $it") // 이 로그는 필요한 만큼만 출력됨
        it % 2 == 0
    }
    .map {
        // println("mapping $it")
        it * 2
    }
    .take(5) // 최종 연산. 여기서 5개의 요소만 요청
    .toList() // Sequence를 다시 List로 변환하여 결과를 저장

println(result) // 출력: [4, 8, 12, 16, 20]
```

위 코드를 실행하면, `filter`와 `map`은 `take(5)`가 만족될 때까지, 즉 5개의 최종 결과가 나올 때까지만 최소한으로 동작합니다. 1부터 10까지의 숫자만 검사하고 연산을 멈추게 되며, 100만 개의 요소를 담는 중간 리스트는 전혀 생성되지 않습니다.

또한, `generateSequence()` 함수를 사용하면 무한한 시퀀스를 만들 수도 있습니다.

```kotlin
// 1부터 시작하여 2씩 곱해지는 무한 시퀀스
val infiniteSequence = generateSequence(1) { it * 2 }

// 그중 처음 10개만 가져와서 리스트로 변환
println(infiniteSequence.take(10).toList())
// 출력: [1, 2, 4, 8, 16, 32, 64, 128, 256, 512]
```

-----

#### 언제 Sequence를 사용해야 할까?

  * **대용량 데이터 처리:** 처리할 요소의 개수가 매우 많을 때.
  * **여러 단계의 연산 체이닝:** `map`, `filter`, `flatMap` 등의 연산이 여러 단계에 걸쳐 연결될 때.
  * **계산 비용이 큰 연산:** 각 연산(`map`이나 `filter`의 람다)의 계산 비용이 클 때.
  * **무한 시퀀스:** 잠재적으로 무한한 데이터를 다룰 때.

반대로, 데이터의 크기가 작고 연산 단계가 단순하다면, `Sequence`를 만드는 오버헤드가 더 클 수 있으므로 일반 컬렉션을 사용하는 것이 더 효율적일 수 있습니다.

`Sequence`는 불필요한 계산과 메모리 사용을 줄여, 복잡한 데이터 파이프라인의 성능을 최적화하는 강력한 도구입니다.