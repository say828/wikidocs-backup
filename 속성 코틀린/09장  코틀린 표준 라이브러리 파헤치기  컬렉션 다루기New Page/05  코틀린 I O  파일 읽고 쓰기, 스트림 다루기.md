### 코틀린 I/O: 파일 읽고 쓰기, 스트림 다루기

프로그램은 종종 파일 시스템과 상호작용하여 데이터를 읽거나 저장해야 합니다. 코틀린은 JVM 위에서 동작하므로 자바의 강력하고 안정적인 I/O 라이브러리(`java.io`)를 그대로 사용합니다. 하지만 코틀린은 여기에 머무르지 않고, 자바의 다소 장황한 I/O 작업을 훨씬 더 간결하고 안전하게 만들어주는 유용한 **확장 함수**들을 표준 라이브러리에 대거 추가했습니다.

이를 통해 우리는 복잡한 `try-catch-finally` 블록이나 스트림 수동 관리 없이도 파일 I/O를 손쉽게 처리할 수 있습니다.

-----

#### 파일 읽기

`java.io.File` 객체를 생성하는 것으로 파일 작업을 시작합니다.

```kotlin
import java.io.File

// 프로젝트 루트 경로에 있는 my_file.txt 파일을 가리키는 File 객체 생성
val file = File("my_file.txt")
```

##### 파일 전체를 한 번에 읽기: `readText()`

파일의 크기가 크지 않다면, `readText()` 확장 함수를 사용하여 파일의 모든 내용을 `String`으로 한 번에 읽어올 수 있습니다.

```kotlin
// 파일이 존재하지 않으면 FileNotFoundException 발생
val content: String = file.readText()
println(content)
```

##### 파일을 줄 단위로 읽기: `readLines()`

파일의 각 줄을 요소로 하는 `List<String>`을 얻고 싶다면 `readLines()`를 사용합니다.

```kotlin
val lines: List<String> = file.readLines()
lines.forEachIndexed { index, line ->
    println("${index + 1}: $line")
}
```

##### 대용량 파일을 효율적으로 처리하기: `useLines`

`readText()`나 `readLines()`는 파일의 모든 내용을 메모리에 올리기 때문에, 매우 큰 파일을 다룰 때는 메모리 부족(Out of Memory) 문제가 발생할 수 있습니다.

**`useLines`** 함수는 이러한 문제를 해결합니다. 이 함수는 파일을 한 줄씩 **지연(lazily)** 처리하는 `Sequence<String>`를 제공하며, **람다 블록이 끝나면 파일을 자동으로 닫아줍니다.** 이를 통해 메모리 사용을 최소화하고 리소스 누수를 방지할 수 있습니다.

```kotlin
// 1GB 크기의 로그 파일에서 'ERROR'가 포함된 줄만 찾아서 출력
File("huge_logfile.log").useLines { lines ->
    lines.filter { it.contains("ERROR") }
         .take(5) // 에러 5개만 찾으면
         .forEach { println(it) } // 출력하고 종료
} // 람다가 끝나면 파일 스트림은 자동으로 닫힙니다.
```

-----

#### 파일 쓰기

파일에 데이터를 쓰는 작업 역시 매우 간단합니다.

##### 텍스트 파일 쓰기: `writeText()`

`writeText()`는 주어진 문자열을 파일에 씁니다. 파일이 이미 존재하면 **내용을 덮어씁니다.**

```kotlin
val outputFile = File("output.txt")
outputFile.writeText("코틀린 파일 쓰기 테스트입니다.")
```

##### 텍스트 이어 쓰기: `appendText()`

기존 파일의 내용 끝에 문자열을 추가하고 싶다면 `appendText()`를 사용합니다.

```kotlin
outputFile.appendText("\n새로운 줄을 추가합니다.")
```

-----

#### 안전한 자원 관리: `use` 함수

`useLines`에서 본 것처럼, 파일을 열거나 네트워크에 연결하는 등의 작업 후에는 반드시 자원을 닫아주어야(`close()`) 합니다. 코틀린은 `Closeable` 인터페이스를 구현하는 모든 자원에 대해 `use`라는 확장 함수를 제공합니다.

`use` 함수는 람다 블록을 인자로 받아 자원을 `this`로 넘겨주고, 람다 블록이 정상적으로 끝나거나 또는 예외가 발생하여 끝나더라도 **항상 자원의 `close()` 메서드 호출을 보장**합니다. 이는 자바의 `try-with-resources` 구문과 동일한 역할을 합니다.

```kotlin
// use 함수를 사용한 일반적인 파일 복사 예제
fun copyFile(sourcePath: String, destPath: String) {
    File(sourcePath).inputStream().use { input ->
        File(destPath).outputStream().use { output ->
            input.copyTo(output)
        }
    } // input과 output 스트림은 여기서 자동으로 닫힘
}
```

`use` 함수를 사용하는 습관은 리소스 누수를 방지하여 안정적인 프로그램을 만드는 데 매우 중요합니다.

-----

이것으로 컬렉션과 파일 I/O를 다루는 9장을 마칩니다. 당신은 이제 코틀린의 강력한 함수형 API를 활용하여 메모리 속 데이터와 파일 시스템의 데이터를 자유자재로, 그리고 안전하게 다룰 수 있는 능력을 갖추게 되었습니다.