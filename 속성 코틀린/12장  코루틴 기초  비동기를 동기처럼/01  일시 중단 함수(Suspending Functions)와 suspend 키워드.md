### 일시 중단 함수(Suspending Functions)와 suspend 키워드

코루틴의 마법은 **`suspend`** 라는 단 하나의 키워드에서 시작됩니다. 비동기 코드를 동기 코드처럼 보이게 만드는 모든 비밀이 이 키워드 안에 담겨있습니다.

\*\*일시 중단 함수(Suspending Function)\*\*는 말 그대로 실행 도중에 \*\*일시 중단(suspend)\*\*될 수 있는 특별한 함수입니다. 함수 선언 앞에 `suspend` 변경자를 붙여서 만듭니다.

-----

#### `suspend`의 역할과 의미

함수 앞에 `suspend`를 붙이는 것은 컴파일러에게 다음과 같은 신호를 보내는 것과 같습니다.
**"이 함수는 시간이 오래 걸리는 작업을 포함할 수 있습니다. 따라서 이 함수는 실행을 잠시 멈추고 나중에 다시 시작할 수 있는 능력이 필요합니다."**

`suspend` 함수는 일반 함수와 달리, \*\*실행을 멈추었다가 나중에 다시 재개할 수 있는 중단점(Suspension Point)\*\*을 가질 수 있습니다.

```kotlin
// suspend 키워드를 붙여 일시 중단 함수로 선언
suspend fun fetchDataFromServer(): String {
    println("데이터 다운로드 시작...")
    // delay는 코루틴 라이브러리에서 제공하는 특별한 suspend 함수입니다.
    // 지정된 시간(밀리초)만큼 코루틴을 '차단하지 않고' 기다립니다.
    delay(1000L) // 1초 동안 대기하는 중단점!
    println("데이터 다운로드 완료!")
    return "서버 데이터"
}
```

##### `suspend` 함수의 마법: 스레드를 막지 않는 대기

위 예제의 `delay(1000L)`는 `Thread.sleep(1000L)`과 근본적으로 다릅니다.

  * **`Thread.sleep(1000L)` (스레드 차단)**: 함수를 실행하는 스레드 자체를 1초 동안 **완전히 멈춰버립니다.** 이 시간 동안 스레드는 아무 다른 일도 할 수 없어 자원이 낭비됩니다. UI 스레드에서 호출하면 화면이 멈추는 현상(ANR)이 발생합니다.
  * **`delay(1000L)` (코루틴 일시 중단)**: 함수를 실행하는 코루틴만 1초 동안 **일시 중단**시킵니다. 코루틴이 쉬는 동안, 코루틴이 실행되던 스레드는 **자유롭게 다른 작업(다른 코루틴 실행 등)을 처리하러 갑니다.** 1초가 지나면, 대기하던 코루틴은 가용한 아무 스레드에서나 멈췄던 지점부터 실행을 재개합니다.

이것이 바로 코루틴이 수많은 작업을 적은 수의 스레드로 효율적으로 처리할 수 있는 핵심 원리입니다.

-----

#### `suspend` 함수의 호출 규칙

`suspend` 함수는 특별한 능력을 가진 만큼, 호출될 수 있는 환경에도 제약이 있습니다.

> **규칙: 일시 중단 함수는 오직 다른 일시 중단 함수 내에서 또는 코루틴 안에서만 호출할 수 있다.**

일반 함수는 코루틴의 '일시 중단과 재개'라는 개념을 이해하지 못하기 때문에, `suspend` 함수를 직접 호출할 수 없습니다.

```kotlin
suspend fun doSomethingSuspending() {
    delay(100)
}

fun myRegularFunction() {
    // doSomethingSuspending() // 컴파일 오류!
    // 일반 함수에서는 suspend 함수를 호출할 수 없습니다.
}
```

그렇다면, 이 `suspend` 함수의 연쇄 호출은 어디서부터 시작될 수 있을까요? 바로 다음 절에서 배울 \*\*코루틴 빌더(Coroutine Builder)\*\*가 그 최초의 출발점이 됩니다. 코루틴 빌더는 일반적인 세상과 `suspend` 함수가 사는 세상을 연결해주는 다리 역할을 합니다.