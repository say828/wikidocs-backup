### 안드로이드 개발을 위한 코루틴 고급 활용법

우리는 이미 `viewModelScope`를 사용해 백그라운드 작업을 시작하고, `withContext`로 스레드를 전환하며, Room이 `suspend`와 `Flow`를 지원한다는 사실을 확인했습니다. 이것만으로도 이미 안드로이드 개발은 혁신적으로 변했습니다. 하지만 진정으로 견고하고 효율적인 앱을 만들기 위해, 안드로이드 생태계에서 사용되는 몇 가지 코루틴 고급 패턴을 더 살펴보겠습니다.

-----

#### 1\. `lifecycleScope`와 `repeatOnLifecycle`: View 레이어에서의 안전한 Flow 수집

`ViewModel`의 `StateFlow`는 데이터를 제공할 준비가 되었지만, View(Activity, Fragment)는 언제 이 데이터를 구독(collect)해야 할까요? View는 사용자가 화면을 보고 있을 때만 데이터를 구독하고, 화면이 백그라운드로 내려가면 구독을 중지하여 배터리와 리소스를 아껴야 합니다.

과거에는 `lifecycleScope.launchWhenStarted` 등이 사용되었지만, 이는 수집만 '일시정지'할 뿐, 상위의 Flow(예: 네트워크 작업)는 계속 실행되는 문제가 있었습니다.

**최신의 공식 권장 방식:** `lifecycleScope.launch`와 **`repeatOnLifecycle`** API를 함께 사용하는 것입니다.

`repeatOnLifecycle`은 지정된 생명주기 상태(보통 `Lifecycle.State.STARTED`)가 되었을 때 코드 블록을 실행하고, 생명주기가 그 아래로 내려가면(예: `onStop()`) **실행 중인 블록을 자동으로 취소**합니다. 그리고 다시 사용자가 화면으로 돌아오면(`onStart()`), **새로운 코루틴을 시작하여 Flow를 재구독**합니다.

이는 리소스를 가장 효율적으로 사용하며, 데이터 수집이 UI가 보이는 동안에만 일어나도록 보장하는 가장 안전한 방법입니다.

```kotlin
// Activity의 onCreate() 또는 Fragment의 onViewCreated() 내부

// 1. View의 생명주기에 맞는 스코프에서 launch
lifecycleScope.launch {
    // 2. 이 Fragment/Activity가 최소 STARTED 상태일 때만 {} 안의 코드를 실행
    repeatOnLifecycle(Lifecycle.State.STARTED) {
        
        // 3. 이 블록은 STARTED 상태에서 시작되고, STOPPED 상태가 되면 자동으로 '취소'됨
        viewModel.uiState.collect { state ->
            // 수집된 상태(state)로 UI를 업데이트 (Compose 또는 XML View)
            when (state) {
                is UiState.Loading -> showLoading()
                is UiState.Success -> showData(state.data)
                is UiState.Error -> showError(state.message)
            }
        }
    }
}
```

-----

#### 2\. `SupervisorJob`: 독립적인 작업들을 위한 안전망

구조화된 동시성의 기본 원칙은 '자식 중 하나라도 실패하면 모두 실패'입니다. 즉, 하나의 `CoroutineScope` 내에서 실행된 여러 `launch` 작업 중 하나에서 예외가 발생하면, 해당 스코프 전체와 다른 형제 코루틴들까지 모두 취소됩니다.

하지만 `ViewModel`에서는 이러한 동작을 원하지 않을 때가 많습니다. 예를 들어, '사용자 프로필 정보 가져오기'와 '추천 뉴스 목록 가져오기'라는 두 개의 독립적인 작업을 동시에 시작했다고 가정해 봅시다. 만약 뉴스 목록 가져오기에 실패했다고 해서, 멀쩡히 성공할 수 있는 사용자 프로필 가져오기까지 취소되어야 할까요?

이를 방지하기 위해 \*\*`SupervisorJob`\*\*을 사용합니다. `SupervisorJob`은 예외 전파 정책이 다른 특별한 `Job`입니다. `SupervisorJob`을 부모로 둔 스코프에서는, **자식 코루틴의 실패가 부모나 다른 형제 코루틴에게 전파되지 않고** 고립됩니다.

**다행히도, `viewModelScope`는 기본적으로 `SupervisorJob`을 사용하도록 이미 설정되어 있습니다.**

덕분에 우리는 `viewModelScope` 내에서 여러 독립적인 작업을 안심하고 실행할 수 있습니다.

```kotlin
// ViewModel 내부
fun loadIndependentData() {
    val handler = CoroutineExceptionHandler { _, e -> println("잡힌 예외: $e") }

    // 작업 1: 성공
    viewModelScope.launch(handler) {
        delay(1000L)
        println("작업 1: 프로필 로드 성공")
    }

    // 작업 2: 500ms 후 실패
    viewModelScope.launch(handler) {
        delay(500L)
        throw RuntimeException("작업 2: 뉴스 피드 로드 실패!")
    }
}
```

**실행 결과:**

```
(500ms 후) 잡힌 예외: java.lang.RuntimeException: 작업 2: 뉴스 피드 로드 실패!
(1000ms 후) 작업 1: 프로필 로드 성공
```

'작업 2'가 실패했지만 '작업 1'은 취소되지 않고 성공적으로 완료되었습니다. 이것이 바로 `viewModelScope`가 `SupervisorJob`을 사용하는 이유입니다.

-----

#### 3\. `callbackFlow`: 콜백 기반 API를 Flow로 변환하기

많은 레거시 안드로이드 API나 Firebase 같은 서드파티 라이브러리는 `suspend`나 `Flow` 대신, 리스너를 등록하는 콜백(Callback) 방식으로 비동기 데이터를 제공합니다. (예: `LocationListener`, `ValueEventListener` 등)

\*\*`callbackFlow`\*\*는 이렇게 콜백 기반으로 동작하는 API를 현대적인 코틀린 `Flow`로 변환해주는 마법 같은 빌더입니다.

  * `callbackFlow` 블록 내에서 콜백 리스너를 등록합니다.
  * 리스너의 콜백 메서드가 호출될 때마다 `trySend()` (또는 `send()`)를 사용하여 값을 Flow 스트림으로 방출(`emit`)합니다.
  * **`awaitClose { ... }`** 블록은 Flow의 수집(collect)이 취소될 때 호출됩니다. 이 블록 안에 리스너를 해제하는 정리 코드를 반드시 넣어야 합니다.

**예시 (간략화된 위치 리스너):**

```kotlin
fun Context.getLocationUpdates(): Flow<Location> = callbackFlow {
    // 1. 실제 리스너 객체 생성
    val locationListener = object : LocationListener {
        override fun onLocationChanged(location: Location) {
            // 2. 콜백이 호출되면, Flow로 값을 방출
            trySend(location) 
        }
        // ... (onStatusChanged, onProviderEnabled 등)
    }

    // 3. API에 리스너 등록
    val locationManager = getSystemService(Context.LOCATION_SERVICE) as LocationManager
    locationManager.requestLocationUpdates(..., locationListener, Looper.getMainLooper())

    // 4. awaitClose 블록은 Flow가 취소될 때 실행됨 (필수!)
    awaitClose {
        // 리소스를 정리합니다 (리스너 제거)
        locationManager.removeUpdates(locationListener)
    }
}
```

이 `getLocationUpdates()` 함수는 이제 완벽한 콜드 스트림 `Flow`를 반환합니다. `viewModelScope` 내에서 이 Flow를 `repeatOnLifecycle`을 사용해 안전하게 수집하면, 생명주기에 맞춰 자동으로 위치 정보 수신이 시작되고 중단되는 깔끔한 코드를 완성할 수 있습니다.

-----

이것으로 16장을 마칩니다. 코틀린은 단순히 안드로이드 앱을 만드는 또 하나의 언어가 아니라, 안드로이드 개발의 패러다임 자체를 더 안전하고, 더 간결하며, 더 효율적으로 바꾸는 핵심 동력입니다. KTX, Jetpack Compose, 그리고 코루틴과 AAC의 결합은 현대 안드로이드 개발의 표준이며, 이 모든 것은 코틀린의 강력함 위에 세워져 있습니다.