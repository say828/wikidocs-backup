### 코틀린 기반의 함수형 라우팅

지금까지 살펴본 `@RestController`, `@GetMapping`과 같은 어노테이션 기반의 컨트롤러 작성 방식은 Spring MVC의 표준이며 매우 강력합니다. 하지만 Spring 5(WebFlux)부터는 이와 더불어, \*\*함수형 라우팅(Functional Routing)\*\*이라는 또 다른 엔드포인트 정의 방식을 제공합니다.

이 방식은 Ktor의 라우팅 DSL과 매우 유사하며, 코틀린의 강력한 DSL 기능과 함수형 프로그래밍 스타일을 적극적으로 활용하여 API를 '코드'로 직접 정의하는 방식입니다.

-----

#### 왜 함수형 라우팅을 사용하는가?

  * **중앙화된 라우팅 정의:** `@GetMapping` 어노테이션은 여러 컨트롤러 파일에 흩어져 있어 전체 API 구조를 파악하기 어려울 수 있습니다. 함수형 라우팅은 모든 라우트(주소) 정의를 하나의 설정 파일에 중앙화하므로, API의 전체 지도를 한눈에 파악하기 쉽습니다.
  * **불변성 및 함수형 스타일:** '마법'처럼 동작하는 어노테이션 대신, 순수한 함수(핸들러)와 라우팅 조합(라우터)으로 애플리케이션을 구성하여 더 예측 가능하고 테스트하기 쉬운 함수형 스타일을 촉진합니다.
  * **유연성:** 동적인 라우팅 규칙을 적용하거나 필터를 그룹화하는 등 프로그래밍 방식의 유연한 제어가 가능합니다.

-----

#### 두 가지 핵심 구성요소: Handler와 Router

함수형 라우팅은 두 가지 핵심 컴포넌트로 구성됩니다.

1.  **`HandlerFunction` (핸들러):** 실제 요청을 처리하는 로직. `@GetMapping`이 붙었던 메서드의 본문에 해당합니다. 코틀린에서는 이 역시 `suspend` 함수로 작성할 수 있습니다.
2.  **`RouterFunction` (라우터):** 특정 경로와 HTTP 메서드 요청을 어떤 핸들러 함수에 연결할지 정의하는 '지도'.

##### 1\. 핸들러 작성하기

먼저 요청을 실제로 처리할 로직을 담은 핸들러 클래스를 작성합니다.

```kotlin
@Component // 이 클래스도 Spring Bean으로 등록합니다.
class UserHandler(private val userRepository: UserRepository) {

    // 각 핸들러 함수는 요청(ServerRequest)을 받아 응답(ServerResponse)을 반환합니다.
    // 물론, suspend 함수로 선언하여 비동기 처리가 가능합니다.
    suspend fun getUserById(request: ServerRequest): ServerResponse {
        val id = request.pathVariable("id").toLongOrNull()
        
        return id?.let {
            userRepository.findById(it) // 리포지토리의 suspend 함수 호출
                ?.let { user -> ServerResponse.ok().bodyValueAndAwait(user) } // bodyValueAndAwait: suspend 버전의 body()
                ?: ServerResponse.notFound().buildAndAwait()
        } ?: ServerResponse.badRequest().buildAndAwait()
    }
    
    suspend fun getAllUsers(request: ServerRequest): ServerResponse {
        // DB에서 Flow로 반환받은 데이터를 응답 본문의 스트림으로 바로 연결
        return ServerResponse.ok().bodyFlowAndAwait(userRepository.findAll()) 
    }
}
```

##### 2\. 코루틴 라우터 DSL (`coRouter`)로 라우팅하기

이제 이 핸들러 함수들을 실제 URL 경로와 연결할 차례입니다. Spring은 코루틴을 완벽하게 지원하는 \*\*`coRouter`\*\*라는 코틀린 전용 DSL을 제공합니다.

```kotlin
@Configuration
class ApiRoutes(private val userHandler: UserHandler) { // 핸들러를 주입받음

    @Bean
    fun userRoutes() = coRouter { // 코루틴 라우터 DSL 시작
        
        // "/api/users" 경로 아래에 라우트를 중첩시킵니다.
        "/api/users".nest { 
            // GET /api/users/{id} 요청을 userHandler::getUserById 함수와 연결
            GET("/{id}", userHandler::getUserById)
            
            // GET /api/users 요청을 userHandler::getAllUsers 함수와 연결
            GET("/", userHandler::getAllUsers)
            
            // POST /api/users (다른 핸들러 함수와 연결...)
            // POST("/", userHandler::createUser) 
        }

        // "/api/products"와 같은 다른 도메인의 라우트도 여기에 정의할 수 있습니다.
        "/api/products".nest {
            // ... (ProductHandler와 연결) ...
        }
    }
}
```

`coRouter` DSL을 사용하면, Ktor에서 경험했던 것처럼 매우 직관적이고 타입 안전하며 구조화된 방식으로 전체 API 엔드포인트를 한곳에서 정의하고 관리할 수 있습니다.

-----

이것으로 17장을 마칩니다. 우리는 코틀린이 서버사이드 개발에서 얼마나 강력한지 두 가지 핵심 경로를 통해 확인했습니다. 하나는 코루틴 네이티브의 경량 프레임워크인 **Ktor**를 통해 밑바닥부터 고성능 비동기 서버를 구축하는 길입니다. 다른 하나는 검증된 엔터프라이즈 거인인 **Spring Boot** 생태계에 코틀린의 간결함, 안전성, 그리고 코루틴과 DSL이라는 현대적 무기를 탑재하여 시스템을 업그레이드하는 길입니다. 당신은 이제 어떤 요구사항의 백엔드 시스템이든 코틀린으로 자신 있게 구축할 수 있는 능력을 갖추었습니다.