### 비동기 서버 구축과 코루틴 활용

Ktor의 문법이 간결하다는 것도 장점이지만, Ktor를 선택하는 가장 근본적인 이유는 바로 **코루틴을 기반으로 한 비동기 논블로킹(Non-Blocking) 아키텍처** 때문입니다. 이는 서버의 성능과 확장성에 지대한 영향을 미칩니다.

-----

#### 전통적인 블로킹(Blocking) 서버의 한계

전통적인 서블릿 기반의 프레임워크(초기 Spring MVC 등)는 대부분 **'요청 당 스레드(Thread-per-Request)'** 모델을 따릅니다.

1.  사용자 요청이 들어오면, 서버는 해당 요청을 처리할 **스레드를 하나 할당**합니다.
2.  만약 이 스레드가 데이터베이스를 조회하거나 외부 API를 호출하느라 **10초를 기다려야 한다면**, 그 스레드는 10초 동안 아무 일도 하지 못하고 \*\*'블로킹(blocking)'\*\*된 채로 대기합니다.
3.  만약 이런 요청이 동시에 5,000개가 들어온다면, 서버는 5,000개의 스레드를 생성해야 합니다. 스레드는 메모리를 많이 차지하는 비싼 자원이므로, 이는 곧 서버의 한계(메모리 고갈, 과도한 컨텍스트 스위칭 비용)로 이어집니다.

-----

#### Ktor의 논블로킹(Non-Blocking) 서버와 코루틴

Ktor는 Netty와 같은 논블로킹 엔진 위에서 동작하며, CPU 코어 수에 비례하는 **매우 적은 수의 스레드**로 모든 요청을 처리합니다. 이것이 가능한 이유는 바로 **코루틴의 '일시 중단(Suspension)'** 덕분입니다.

Ktor의 모든 라우팅 핸들러(`get`, `post` 등)는 코루틴 스코프 내에서 실행됩니다.

1.  사용자 요청이 들어오면, Ktor는 코루틴을 하나 시작하여 적은 스레드 중 하나에 배정합니다.
2.  이 코루틴이 DB 조회나 외부 API 호출 같은 I/O 작업을 위해 `suspend` 함수(예: `delay`나 Ktor 클라이언트의 `get`)를 호출하면, **코루틴은 일시 중단되지만 스레드는 절대 블로킹되지 않습니다.**
3.  **스레드는 즉시 해방되어** 다음으로 들어오는 다른 사용자 요청을 처리하러 갑니다.
4.  I/O 작업이 완료되어 데이터가 준비되면, 중단되었던 코루틴이 다시 '준비' 상태가 되어 가용한 스레드에 배정받아 작업을 재개합니다.

이 모델을 통해 Ktor 서버는 단 몇 개의 스레드만으로 수만 개의 동시 접속을 효율적으로 처리할 수 있습니다.

```kotlin
routing {
    // 5초가 걸리는 비동기 작업
    get("/slow-task") {
        // delay()는 스레드를 '블로킹'하는 것이 아니라 코루틴을 '일시 중단'시킵니다.
        delay(5000L) 
        call.respondText("5초 후에 완료되었습니다!")
    }

    // 즉시 응답하는 작업
    get("/fast-task") {
        call.respondText("즉시 응답!")
    }
}
```

위 서버에서 한 사용자가 `/slow-task`에 접속해 5초를 기다리는 동안에도, 서버의 스레드는 전혀 막혀있지 않으므로 수천 명의 다른 사용자가 동시에 `/fast-task`에 접속해 즉각적인 응답을 받아 갈 수 있습니다.

#### 주의: 블로킹 코드를 호출해야 할 때

이 마법은 우리가 `suspend` 함수나 비동기 I/O 라이브러리를 사용할 때만 유효합니다. 만약 코루틴 내에서 `Thread.sleep()`이나 레거시 JDBC 드라이버의 블로킹 함수를 호출하면, 코루틴은 일시 중단되는 것이 아니라 **정말로 스레드를 블로킹**해버려 모든 장점을 잃게 됩니다.

만약 어쩔 수 없이 블로킹 코드를 호출해야 한다면, 반드시 `withContext`를 사용하여 **작업을 `Dispatchers.IO`로 옮겨야 합니다.**

```kotlin
get("/legacy-blocking-call") {
    // 이 블로킹 작업을 Ktor의 메인 스레드가 아닌,
    // I/O 전용 스레드 풀로 위임하여 서버 전체의 응답성을 보호합니다.
    val result = withContext(Dispatchers.IO) {
        Thread.sleep(3000L) // 레거시 JDBC 드라이버 호출 등을 시뮬레이션
        "오래된 시스템에서 가져온 데이터"
    }
    call.respondText(result)
}
```

`withContext(Dispatchers.IO)`를 사용하면, 해당 블로킹 작업이 별도의 I/O 스레드 풀에서 실행되도록 위임하므로, Ktor의 핵심 이벤트 루프 스레드는 안전하게 보호되어 다른 요청들을 계속 처리할 수 있습니다.