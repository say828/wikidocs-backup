### 라우팅, 요청/응답 처리, 플러그인 시스템

단순한 "Hello, World"를 넘어 실제 웹 애플리케이션을 만들려면 세 가지 핵심 기능이 필요합니다. 바로 **라우팅**(주소 설계), **요청/응답 처리**(데이터 송수신), 그리고 **플러그인**(기능 확장)입니다. Ktor는 이 모든 것을 지극히 코틀린답고 직관적인 방식으로 처리합니다.

-----

#### 라우팅(Routing): API의 주소록 만들기

라우팅은 특정 URL 경로와 HTTP 메서드(GET, POST 등)의 요청을 어떤 코드 블록이 처리할지 연결해주는 '교통 안내원'입니다. Ktor는 `routing` 블록 내부에 간결한 DSL(도메인 특화 언어)을 제공하여 API 주소를 계층적으로 설계할 수 있게 해줍니다.

  * **중첩 라우트:** `route("/path")`를 사용하여 관련 엔드포인트를 깔끔하게 그룹화할 수 있습니다.
  * **HTTP 메서드:** `get`, `post`, `put`, `delete` 등 직관적인 함수를 제공합니다.
  * **경로 파라미터:** `/{id}`와 같이 중괄호를 사용하여 URL 경로의 일부를 동적인 파라미터로 캡처할 수 있습니다.

<!-- end list -->

```kotlin
routing {
    get("/") {
        call.respondText("Root endpoint")
    }

    // "/users" 경로로 관련된 API들을 그룹화
    route("/users") {
        // GET /users
        get {
            call.respondText("List of all users")
        }

        // POST /users
        post {
            call.respondText("Create a new user")
        }

        // GET /users/{id}
        get("/{id}") {
            // 경로 파라미터 읽기
            val id = call.parameters["id"]
            call.respondText("Details for user $id")
        }
    }
}
```

-----

#### 플러그인 시스템과 JSON 처리 (ContentNegotiation)

실제 API는 단순 텍스트가 아닌 JSON과 같은 구조화된 데이터를 주고받아야 합니다. Ktor는 이 기능을 기본으로 내장하지 않고, \*\*플러그인(Plugin)\*\*으로 설치하도록 유도합니다. 우리는 JSON 처리를 위해 `ContentNegotiation` 플러그인을 설치하고, 이 플러그인이 `kotlinx.serialization`을 사용하도록 설정할 것입니다.

```kotlin
import io.ktor.serialization.kotlinx.json.*
import io.ktor.server.plugins.contentnegotiation.*
// ...

fun Application.module() { // main 함수 대신 모듈 함수로 분리하는 것이 일반적
    
    // 1. ContentNegotiation 플러그인 설치
    install(ContentNegotiation) {
        // 2. kotlinx.serialization 라이브러리를 사용하여 JSON을 처리하도록 설정
        json()
    }
    
    routing {
        // ... (라우팅 로직)
    }
}
```

이 `install` 코드 단 몇 줄만으로, 우리 서버는 이제 코틀린 데이터 클래스와 JSON 문자열 간의 자동 변환 기능을 탑재하게 되었습니다.

-----

#### 요청/응답 처리: `receive<T>` 와 `respond`

`ContentNegotiation` 플러그인을 설치하면, 요청을 받고 응답을 보내는 과정이 마법처럼 간단해집니다.

  * **`call.receive<T>()`**: `POST`나 `PUT` 요청의 본문(Body)에 담긴 JSON 문자열을 읽어, 지정된 코틀린 데이터 클래스 `T`의 객체로 **자동 역직렬화**해주는 `suspend` 함수입니다.
  * **`call.respond(data)`**: 코틀린 객체(데이터 클래스나 리스트 등)를 JSON 문자열로 **자동 직렬화**하여 HTTP 응답으로 전송합니다. `Content-Type: application/json` 헤더도 자동으로 설정됩니다.

##### 종합 예제: JSON을 사용하는 간단한 User API

```kotlin
import kotlinx.serialization.Serializable

// kotlinx.serialization이 인식할 수 있도록 @Serializable 어노테이션 추가
@Serializable
data class User(val id: Int, val name: String)

// 간단한 인메모리 데이터베이스 역할
val userDatabase = mutableListOf(User(1, "Alice"), User(2, "Bob"))

// ... Application.module() ...
    
    install(ContentNegotiation) { json() }

    routing {
        route("/users") {
            // GET /users : 모든 사용자 목록을 JSON 배열로 반환
            get {
                call.respond(userDatabase)
            }

            // POST /users : 새 사용자를 JSON으로 받아 등록
            post {
                // 1. JSON 요청 본문을 User 객체로 자동 변환
                val newUser = call.receive<User>()
                userDatabase.add(newUser)
                
                // 2. 생성된 객체를 JSON으로 자동 변환하여 응답
                call.respond(HttpStatusCode.Created, newUser)
            }

            // GET /users/{id} : 특정 사용자 반환
            get("/{id}") {
                val id = call.parameters["id"]?.toIntOrNull()
                val user = userDatabase.find { it.id == id }

                if (user != null) {
                    call.respond(user)
                } else {
                    call.respond(HttpStatusCode.NotFound)
                }
            }
        }
    }
```

이처럼 Ktor는 직관적인 라우팅 DSL과 강력한 플러그인 시스템, 그리고 `kotlinx.serialization`과의 완벽한 통합을 통해, 타입 안전하고 간결한 백엔드 API를 놀랍도록 빠르게 구축할 수 있게 해줍니다.