### 고차 함수(Higher-Order Functions): 함수를 인자로 받거나 반환하는 함수

\*\*고차 함수(Higher-Order Function)\*\*는 함수형 프로그래밍 패러다임의 심장과도 같은 개념입니다. 앞서 '함수는 일급 시민'이라고 했던 말을 기억하시나요? 고차 함수는 바로 이 원칙을 실제로 활용하는 함수를 말합니다.

> **고차 함수의 정의**
> 다음 조건 중 하나 이상을 만족하는 함수
>
> 1.  함수를 **파라미터**로 받는 함수
> 2.  함수를 **반환**하는 함수

일반 함수가 데이터(Int, String 등)를 가공하는 기계라면, 고차 함수는 그 기계의 **부품(함수)을 갈아 끼우거나** 아예 **새로운 맞춤형 기계(함수)를 만들어내는** 공장 관리자와 같습니다. 👨‍💼

-----

## 함수를 인자로 받는 함수

고차 함수의 가장 흔한 형태는 다른 함수(주로 람다)를 인자로 받아 로직의 일부로 사용하는 것입니다. 이를 통해 우리는 코드의 공통적인 구조는 유지하면서, 세부적인 동작은 외부에서 주입하여 자유롭게 변경할 수 있습니다.

### 예시: 코드 실행 시간 측정기

어떤 코드 블록이 실행되는 데 걸리는 시간을 측정하는 함수를 만들어 봅시다.

```kotlin
// block이라는 이름의 파라미터로, 파라미터 없고 반환도 없는 함수(() -> Unit)를 받습니다.
fun measureExecutionTime(block: () -> Unit) {
    val startTime = System.nanoTime()
    block() // 전달받은 함수(코드 블록)를 여기서 실행!
    val endTime = System.nanoTime()
    val elapsedTime = (endTime - startTime) / 1_000_000.0
    println("실행 시간: ${elapsedTime}ms")
}

fun main() {
    measureExecutionTime { 
        // 측정하고 싶은 코드를 람다로 전달
        var sum = 0L
        for (i in 1..1_000_000_000) {
            sum += i
        }
    }
    
    measureExecutionTime {
        Thread.sleep(1200) // 1.2초 동안 잠시 멈추는 코드
    }
}
```

**실행 결과:**

```
실행 시간: 315.486209ms
실행 시간: 1202.871583ms
```

`measureExecutionTime` 함수는 '무엇을' 실행할지는 전혀 신경 쓰지 않습니다. 오직 '어떻게' 시간을 측정할지에만 집중합니다. 우리는 이 재사용 가능한 측정 도구에, 시간을 재고 싶은 다양한 작업(람다)을 그저 전달하기만 하면 됩니다. 이처럼 고차 함수는 **로직의 뼈대와 살을 분리**하여 코드의 재사용성과 유연성을 극대화합니다.

-----

## 함수를 반환하는 함수

고차 함수는 새로운 함수를 동적으로 생성하여 반환할 수도 있습니다. 이는 특정 설정값이나 상태를 '기억'하는 맞춤형 함수를 만드는 데 유용합니다.

### 예시: 곱셈 함수 팩토리

숫자 하나를 인자로 받아, 그 숫자를 곱하는 새로운 함수를 반환하는 '함수 공장'을 만들어 봅시다.

```kotlin
// 'factor'를 인자로 받아, '(Int) -> Int' 타입의 함수를 반환합니다.
fun getMultiplier(factor: Int): (Int) -> Int {
    // 람다를 반환합니다. 이 람다는 외부의 factor 변수를 기억합니다(클로저).
    return { number -> number * factor }
}

fun main() {
    // 2를 곱하는 함수를 생성
    val double: (Int) -> Int = getMultiplier(2)
    
    // 3을 곱하는 함수를 생성
    val triple = getMultiplier(3)

    // 생성된 함수들을 사용
    println(double(10)) // 출력: 20
    println(double(25)) // 출력: 50

    println(triple(10)) // 출력: 30
    println(triple(25)) // 출력: 75
}
```

`getMultiplier` 함수는 직접 계산을 수행하지 않습니다. 대신 `factor`라는 특정 설정을 기억하는 새로운 함수(`double`, `triple`)를 만들어 반환합니다. 이렇게 만들어진 함수들은 자신만의 고유한 `factor` 값을 가지고 독립적으로 동작합니다.

고차 함수는 코드를 단순히 순차적인 명령어의 나열이 아닌, 추상화된 동작들의 유연한 조합으로 만들어주는 함수형 프로그래밍의 핵심 철학입니다. 코틀린의 표준 라이브러리는 `map`, `filter`, `forEach` 등 수많은 강력한 고차 함수로 가득 차 있으며, 이를 통해 우리는 놀랍도록 간결하고 표현력 넘치는 코드를 작성할 수 있게 됩니다.