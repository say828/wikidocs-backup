### 인라인 함수(inline): 람다 사용의 성능 오버헤드 제거

람다와 고차 함수는 코드를 놀랍도록 유연하고 표현력 있게 만들어 줍니다. 하지만 이러한 편리함에는 눈에 보이지 않는 약간의 비용이 따릅니다.

#### 람다의 숨겨진 비용

코틀린 코드가 JVM 바이트코드로 컴파일될 때, 람다 표현식은 사실 \*\*익명 클래스의 인스턴스(객체)\*\*로 변환됩니다. 즉, 고차 함수를 호출할 때마다 람다를 전달하는 것은 새로운 객체를 생성하여 전달하는 것과 같습니다.

```kotlin
// 이 람다 { println("실행") }는
// 내부적으로 Function0 인터페이스를 구현하는 익명 객체로 생성됩니다.
repeat(100) { println("실행") } 
```

대부분의 경우 이러한 객체 생성으로 인한 오버헤드는 무시할 수 있을 정도로 작습니다. 하지만 위 코드처럼 반복문 안에서 람다를 사용하거나, 성능에 매우 민감한 코드를 작성할 때는 이러한 작은 오버헤드가 쌓여 성능에 영향을 줄 수 있습니다.

#### `inline` 키워드의 해결책

코틀린은 이러한 오버헤드를 완벽하게 제거할 수 있는 **`inline`** 키워드를 제공합니다.

함수 선언 앞에 `inline` 키워드를 붙이면, 컴파일러는 그 함수를 호출하는 코드를 함수 호출문으로 바꾸는 대신, **함수의 본문 코드를 그대로 복사하여 호출 지점에 붙여넣습니다.** 만약 그 함수가 람다를 인자로 받는다면, **람다의 본문 코드까지 함께** 복사해서 붙여넣습니다.

**비유:** `inline`은 함수를 '호출'하는 것이 아니라, 함수의 코드를 그 자리에 '펼쳐놓는' 것과 같습니다.

##### `inline` 함수의 동작

`inline`으로 선언된 간단한 고차 함수를 살펴봅시다.

```kotlin
// inline 키워드를 붙인 고차 함수
inline fun runAndMeasure(block: () -> Unit) {
    println("실행 시작")
    block()
    println("실행 종료")
}
```

이제 이 함수를 호출하면,

```kotlin
fun main() {
    runAndMeasure {
        println("핵심 로직 수행 중...")
    }
}
```

컴파일러는 `main` 함수를 다음과 같이 코드를 직접 작성한 것처럼 변환합니다.

```kotlin
// 컴파일 후의 main 함수 (개념적으로)
fun main() {
    // runAndMeasure 함수 본문이 복사됨
    println("실행 시작")
    // 람다 본문이 복사됨
    println("핵심 로직 수행 중...")
    // runAndMeasure 함수 본문이 복사됨
    println("실행 종료")
}
```

결과적으로, `runAndMeasure` 함수에 대한 **함수 호출도 일어나지 않았고**, 람다를 위한 **객체 생성도 전혀 없었습니다.** 모든 성능 오버헤드가 마법처럼 사라진 것입니다.

#### `inline`의 또 다른 이점

`inline`은 단순히 성능 최적화만을 위한 기능이 아닙니다. 코드가 호출 지점에 그대로 복사되기 때문에, 다음과 같은 특별한 기능이 가능해집니다.

1.  **실체화된 타입 파라미터 (`reified`):** 6장에서 배운 것처럼, `inline` 함수는 `reified` 키워드를 통해 제네릭 타입 소거의 한계를 극복하고 런타임에 타입 정보를 유지할 수 있습니다.
2.  **람다 내부에서의 `return` (Non-local return):** 일반 람다 내부에서는 바깥 함수를 종료하는 `return`을 사용할 수 없지만, 인라인된 람다 안에서는 가능합니다. 람다 코드가 바깥 함수 코드의 일부가 되었기 때문입니다.

#### 언제 사용해야 할까?

  * **사용하기 좋은 경우:** 람다를 파라미터로 받는 고차 함수는 대부분 `inline` 후보입니다. 특히, `forEach`, `map`, `filter` 등 코틀린 표준 라이브러리의 많은 컬렉션 함수들은 이미 `inline`으로 선언되어 있어 우리가 안심하고 사용할 수 있습니다.
  * **주의해야 할 경우:** `inline`으로 선언된 함수가 매우 크고 복잡하다면, 그 함수의 코드가 호출될 때마다 복사되어 전체 코드의 크기가 비대해질 수 있습니다. `inline`은 함수 자체의 로직보다 람다 객체 생성 오버헤드가 더 클 것으로 예상되는 작은 함수에 사용하는 것이 가장 효과적입니다.

`inline` 함수는 코틀린이 어떻게 우아한 고수준의 추상화(람다, 고차 함수)와 저수준의 성능 최적화를 동시에 달성하는지를 보여주는 핵심적인 기능입니다.