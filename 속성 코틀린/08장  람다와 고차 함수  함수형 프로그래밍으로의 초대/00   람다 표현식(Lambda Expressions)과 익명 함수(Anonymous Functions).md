### 람다 표현식(Lambda Expressions)과 익명 함수(Anonymous Functions)

**람다 표현식**은 간단히 말해 \*\*'이름이 없는 함수'\*\*입니다. 정식으로 `fun` 키워드를 사용해 함수를 선언하는 대신, 코드 블록 형태로 간결하게 함수를 표현하고 이를 변수에 저장하거나 다른 함수에 바로 전달할 수 있습니다. 이를 '함수 리터럴(Function Literal)'이라고도 합니다.

## 람다 표현식의 구조

람다 표현식은 항상 중괄호(`{ ... }`)로 감싸이며, 그 구조는 다음과 같습니다.

`{ 파라미터 목록 -> 함수 본문 }`

  * **`{ ... }`**: 람다 표현식의 시작과 끝을 나타냅니다.
  * **`파라미터 목록`**: 함수가 받을 입력 값입니다. 파라미터가 없으면 비워둡니다. 타입은 보통 추론 가능하므로 생략하는 경우가 많습니다.
  * **`->`**: 파라미터 목록과 함수 본문을 구분하는 화살표입니다.
  * **`함수 본문`**: 실제 실행될 코드입니다. 본문의 마지막 표현식의 결과가 람다의 반환 값이 됩니다.

### 람다를 변수에 담기

두 정수를 더하는 간단한 람다를 만들어 변수에 할당해 봅시다.

```kotlin
// 변수 sum은 (Int, Int) -> Int 라는 '함수 타입'을 가집니다.
val sum: (Int, Int) -> Int = { a: Int, b: Int -> a + b }

// 람다가 담긴 변수는 일반 함수처럼 호출할 수 있습니다.
val result = sum(10, 5) // result는 15
println(result)
```

변수 `sum`은 이제 단순히 값을 담는 그릇이 아니라, '두 정수를 더하는 행동' 자체를 담고 있습니다.

-----

## 고차 함수에 람다 전달하기

람다의 진정한 힘은 고차 함수에 인자로 전달될 때 발휘됩니다. 다른 함수의 동작을 우리가 원하는 대로 즉석에서 커스터마이징할 수 있습니다.

```kotlin
// operation이라는 이름의 '함수'를 파라미터로 받는 고차 함수
fun calculate(a: Int, b: Int, operation: (Int, Int) -> Int): Int {
    return operation(a, b)
}

fun main() {
    // 1. 덧셈 람다를 전달
    val sumResult = calculate(10, 5, { a, b -> a + b })
    println(sumResult) // 출력: 15

    // 2. 뺄셈 람다를 전달
    val subtractResult = calculate(10, 5, { a, b -> a - b })
    println(subtractResult) // 출력: 5
}
```

### 후행 람다 (Trailing Lambda)

코틀린은 가독성을 위해 멋진 문법 설탕을 제공합니다. 만약 함수의 **마지막 파라미터가 람다 표현식**이라면, 그 람다를 **함수 호출 괄호(`()`) 밖으로** 빼낼 수 있습니다.

```kotlin
// 위 예제의 뺄셈 람다를 후행 람다로 표현
val subtractResult = calculate(10, 5) { a, b -> a - b }
```

이 문법 덕분에 코드가 마치 `calculate`라는 새로운 제어 구문을 만든 것처럼 자연스럽게 읽힙니다. 코틀린 표준 라이브러리와 DSL에서 매우 흔하게 사용되는 스타일입니다.

-----

## 익명 함수 (Anonymous Function)

람다와 비슷하게 이름 없이 함수를 정의하는 또 다른 방법으로 **익명 함수**가 있습니다. `fun` 키워드를 사용하지만 함수 이름만 생략하는 형태입니다.

```kotlin
// 익명 함수
val sum = fun(a: Int, b: Int): Int {
    return a + b
}
```

**람다와의 차이점**: 가장 큰 차이는 `return`의 동작입니다. 람다에서 `return`은 람다를 감싸고 있는 가장 가까운 함수를 빠져나가지만(non-local return), 익명 함수에서 `return`은 익명 함수 자체만 빠져나갑니다. 대부분의 경우 람다의 간결함이 선호되지만, `return` 동작을 명확히 제어하고 싶을 때 익명 함수가 사용될 수 있습니다.

람다 표현식은 코드 조각을 값처럼 다루어, 함수를 레고 블록처럼 자유롭게 조립하고 전달할 수 있게 해주는 함수형 프로그래밍의 첫걸음입니다. 이제 이 강력한 도구를 받아들이는 고차 함수에 대해 더 깊이 알아볼 시간입니다.