### CoroutineScope를 활용한 구조화된 동시성

동시성 프로그래밍의 가장 큰 골칫거리 중 하나는 '고아(orphan)'가 된 백그라운드 작업입니다. 예를 들어, 사용자가 특정 화면에서 데이터를 다운로드하는 코루틴을 시작했는데, 다운로드가 끝나기 전에 사용자가 그 화면을 나가버렸다고 상상해 봅시다. 만약 이 코루틴을 제대로 정리해주지 않는다면, 이미 사라진 화면을 위해 불필요한 작업을 계속 수행하며 메모리와 CPU를 낭비하는 \*\*리소스 누수(resource leak)\*\*를 유발할 것입니다.

\*\*구조화된 동시성(Structured Concurrency)\*\*은 이러한 문제를 해결하는 코틀린 코루틴의 핵심 패러다임입니다. 이는 **코루틴의 생명주기를 특정 범위(Scope)에 귀속시켜**, 범위가 끝날 때 그 안에서 실행되던 모든 코루틴이 함께 정리되도록 보장하는 원칙입니다.

#### CoroutineScope: 코루틴들의 부모

\*\*`CoroutineScope`\*\*는 새로운 코루틴을 시작할 수 있는 범위를 정의하고, 그 안에서 실행되는 모든 코루틴을 추적 관리하는 역할을 합니다. `launch`나 `async` 같은 코루틴 빌더는 사실 `CoroutineScope`의 확장 함수이므로, 항상 특정 스코프 안에서만 호출될 수 있습니다.

**비유:** `CoroutineScope`는 코루틴 '자식'들을 책임지는 '부모' 👨‍👩‍👧‍👦와 같습니다. 부모(Scope)가 자신의 생을 마감하면(`cancel`), 모든 자식(코루틴)들의 활동도 함께 정리됩니다. 덕분에 자식이 부모 없이 홀로 떠도는 '고아 코루틴'이 발생하는 것을 원천적으로 방지합니다.

#### `GlobalScope`를 사용하면 안 되는 이유

코틀린은 `GlobalScope`라는 최상위 스코프를 제공하지만, 이는 애플리케이션의 전체 생명주기와 동일하게 유지되므로 특별한 경우가 아니면 **절대 사용해서는 안 됩니다.** `GlobalScope`에서 시작된 코루틴은 어떤 특정 컴포넌트에도 묶여있지 않아, 애플리케이션이 종료될 때까지 무책임하게 실행될 수 있는 잠재적인 누수의 주범입니다.

#### 올바른 스코프 사용법

올바른 방법은, 동시성 작업이 필요한 컴포넌트의 생명주기에 맞춰 직접 `CoroutineScope`를 만드는 것입니다.

```kotlin
import kotlinx.coroutines.*

class MyComponent {
    // 이 컴포넌트의 생명주기에 묶인 CoroutineScope를 생성합니다.
    // Job()을 통해 이 스코프 내의 모든 코루틴을 한 번에 제어할 수 있습니다.
    private val scope = CoroutineScope(Dispatchers.Default + Job())

    fun performTask() {
        // 컴포넌트의 스코프에서 코루틴을 시작합니다.
        scope.launch {
            println("MyComponent의 작업 시작...")
            delay(2000L)
            println("MyComponent의 작업 완료!") // 이 메시지는 출력되지 않을 것입니다.
        }
    }

    // 컴포넌트가 파괴될 때 호출되는 메서드
    fun destroy() {
        println("컴포넌트가 파괴됩니다. 모든 작업을 취소합니다.")
        // 스코프를 취소하면, 이 스코프에서 시작된 모든 자식 코루틴들이 함께 취소됩니다.
        scope.cancel()
    }
}

fun main() = runBlocking {
    val component = MyComponent()
    component.performTask()
    delay(1000L) // 작업이 1초간 실행되도록 잠시 대기
    component.destroy()  // 1초 후 컴포넌트 파괴 (스코프 취소)
    delay(2000L) // 프로그램이 바로 끝나지 않도록 잠시 대기
}
```

**실행 결과:**

```
MyComponent의 작업 시작...
컴포넌트가 파괴됩니다. 모든 작업을 취소합니다.
```

`destroy()` 메서드가 `scope.cancel()`을 호출하자마자, 스코프 내에서 실행 중이던 코루틴이 `delay` 지점에서 취소 신호를 감지하고 즉시 종료되었습니다. 덕분에 "작업 완료\!" 메시지는 출력되지 않았고, 불필요한 리소스 낭비를 막을 수 있었습니다.

이처럼 **구조화된 동시성**은 코루틴의 생명주기를 특정 `CoroutineScope`에 바인딩하고, 스코프가 끝날 때 모든 작업을 함께 정리하는 명확하고 안전한 동시성 코드 작성의 핵심 원칙입니다.