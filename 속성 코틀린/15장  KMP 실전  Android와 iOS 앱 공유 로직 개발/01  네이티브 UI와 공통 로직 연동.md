### 네이티브 UI와 공통 로직 연동

우리는 `commonMain`에 앱의 핵심 두뇌(데이터 모델, 네트워크, 비즈니스 로직)를 모두 구축했습니다. 이 공유 모듈은 그 자체로 완성된 '엔진'입니다. 이제 남은 작업은 이 엔진을 실제 자동차 차체, 즉 Android 네이티브 UI와 iOS 네이티브 UI에 장착하는 것입니다.

두 플랫폼은 이 공유 모듈을 소비하는 방식이 근본적으로 다릅니다.

-----

#### Android: 익숙한 Gradle 의존성처럼 연결하기

Android 앱에게 `shared` 모듈은 그저 또 하나의 \*\*Gradle 모듈(라이브러리)\*\*일 뿐입니다. 안드로이드 앱 모듈(`:androidApp`)의 `build.gradle.kts` 파일에는 이미 `shared` 모듈에 대한 의존성이 설정되어 있습니다.

```kotlin
// In androidApp/build.gradle.kts
dependencies {
    implementation(project(":shared")) // 'shared' 모듈을 일반 라이브러리처럼 사용
    // ...
}
```

따라서 안드로이드의 `ViewModel`에서는 `shared` 모듈에 정의한 `UserRepository`를 마치 같은 프로젝트에 있는 클래스처럼 **직접 가져와서(import) 사용**할 수 있습니다. 코루틴 역시 안드로이드 생태계의 표준이므로, `viewModelScope`를 사용해 공유 모듈의 `suspend` 함수를 아무런 변환 없이 네이티브하게 호출할 수 있습니다.

```kotlin
// In androidApp/src/main/java/.../MainViewModel.kt

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.shared.repository.UserRepository // 'shared' 모듈의 클래스를 직접 임포트
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.launch

class MainViewModel : ViewModel() {

    // 1. 공통 저장소(UserRepository) 인스턴스 생성
    private val repository = UserRepository()

    // 2. UI가 관찰할 상태(StateFlow) 정의
    private val _userName = MutableStateFlow("로딩 중...")
    val userName: StateFlow<String> = _userName

    init {
        loadUser()
    }

    private fun loadUser() {
        // 3. viewModelScope를 사용해 공유 모듈의 suspend 함수를 직접 호출
        viewModelScope.launch {
            _userName.value = repository.getFormattedUserName()
        }
    }
}
```

안드로이드 개발자에게 이 과정은 너무나 익숙하며, KMP를 사용한다고 해서 새로운 것을 배울 필요가 거의 없습니다. 이것이 KMP가 안드로이드 개발자에게 매력적인 이유입니다.

-----

#### iOS: 브리지를 건너 Swift와 연동하기

iOS와의 연동은 조금 더 마법 같은 과정을 거칩니다. iOS는 코틀린 코드를 직접 실행할 수 없기 때문입니다.

1.  **컴파일:** Gradle은 `shared` 모듈의 `commonMain`과 `iosMain` 코드를 Kotlin/Native 컴파일러로 처리하여, Xcode가 이해할 수 있는 \*\*네이티브 프레임워크(`.framework`)\*\*로 빌드합니다.
2.  **헤더 생성:** 이 프레임워크 안에는 코틀린 코드와 상호작용할 수 있는 **Swift / Objective-C 호환 헤더 파일**이 자동으로 생성됩니다.

iOS 개발자는 Xcode 프로젝트에 이 `shared.framework`를 임포트하기만 하면, 헤더 파일을 통해 `shared` 모듈의 모든 공통 클래스와 함수를 Swift 코드에서 **마치 네이티브 Swift 코드인 것처럼** 사용할 수 있습니다.

**핵심 과제: Swift는 `suspend`를 모른다**

가장 큰 차이점은 Swift가 코틀린의 `suspend` 키워드를 이해하지 못한다는 것입니다. KMP는 이 문제를 **Completion Handler(콜백)** 패턴으로 자동 변환하여 해결합니다.

즉, 코틀린의 `suspend fun getFormattedUserName(): String` 함수는 Swift에서 다음과 같은 형태의 함수로 보이게 됩니다.

```swift
// Swift가 인식하는 변환된 함수 시그니처 (개념)
func getFormattedUserName(completionHandler: @escaping (String?, Error?) -> Void)
```

iOS의 `ViewModel`(보통 `ObservableObject`)에서는 이 콜백 기반 함수를 호출하여 UI를 업데이트합니다.

```swift
// In iosApp/iosApp/ContentView.swift (SwiftUI View)

import SwiftUI
import shared // KMP가 생성한 프레임워크를 임포트

// iOS의 ViewModel 역할
class ContentViewModel: ObservableObject {
    
    // UI가 관찰할 프로퍼티
    @Published var userName: String = "로딩 중..."
    
    // 1. 공통 저장소(UserRepository) 인스턴스 생성
    private let repository = UserRepository()

    func loadUser() {
        // 2. 콜백(Completion Handler) 방식으로 변환된 함수를 호출
        repository.getFormattedUserName { formattedName, error in
            
            // 콜백은 백그라운드 스레드에서 실행될 수 있으므로,
            // UI 업데이트는 반드시 메인 스레드에서 수행해야 함
            DispatchQueue.main.async {
                if let name = formattedName {
                    self.userName = name
                } else if let error = error {
                    self.userName = "에러: \(error.localizedDescription)"
                }
            }
        }
    }
}
```

이처럼 KMP는 `suspend` 함수를 플랫폼 표준 방식(안드로이드는 코루틴, iOS는 콜백)으로 자동 변환하여, 각 네이티브 플랫폼이 이질감 없이 공통 로직의 강력한 기능을 활용할 수 있도록 정교한 다리를 놓아줍니다.