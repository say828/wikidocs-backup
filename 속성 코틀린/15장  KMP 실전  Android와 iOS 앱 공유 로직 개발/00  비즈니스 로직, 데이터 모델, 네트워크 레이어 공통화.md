### 비즈니스 로직, 데이터 모델, 네트워크 레이어 공통화

모든 KMP 프로젝트의 핵심 작업은 `shared/src/commonMain` 디렉터리 안에서 이루어집니다. 이곳에 작성하는 코드는 Android와 iOS 양쪽에서 모두 실행될 우리 앱의 공통 심장부입니다. 우리는 앱을 '안에서 밖으로(inside-out)' 만든다는 느낌으로, 데이터의 흐름에 따라 모델, 네트워크, 비즈니스 로직 순서로 공통화 작업을 진행합니다.

#### 1\. 데이터 모델 공통화 (`Data Class`)

가장 쉽고 확실한 첫 단계는 두 플랫폼이 함께 사용할 데이터의 형태를 정의하는 것입니다. API로부터 받아올 사용자 정보(`User`)를 코틀린의 `data class`로 `commonMain`에 정의합니다.

네트워크를 통해 이 데이터를 주고받으려면 JSON 직렬화/역직렬화가 필요하며, KMP에서는 **`kotlinx.serialization`** 라이브러리를 표준으로 사용합니다.

```kotlin
// In shared/src/commonMain/kotlin/com/example/shared/model/User.kt

import kotlinx.serialization.Serializable

// @Serializable 어노테이션을 붙이면 kotlinx.serialization이 이 클래스를
// JSON으로 변환하거나 JSON에서 객체로 변환할 수 있게 해줍니다.
@Serializable
data class User(
    val id: String,
    val firstName: String,
    val lastName: String,
    val email: String
)
```

이 `User` 데이터 클래스 하나를 정의함으로써, Android와 iOS 앱이 서로 다른 데이터 모델을 사용하여 발생하는 불일치 버그를 원천적으로 차단할 수 있습니다.

#### 2\. 네트워크 레이어 공통화 (`Ktor`)

다음으로, 이 데이터를 가져올 네트워크 통신 코드를 작성합니다. Android에서는 Retrofit을, iOS에서는 Alamofire를 따로 작성하는 대신, JetBrains가 공식 지원하는 멀티플랫폼 네트워킹 라이브러리인 **Ktor**를 사용합니다.

Ktor는 내부적으로 `expect`/`actual` 패턴을 사용하여, 안드로이드에서는 OkHttp 엔진을, iOS에서는 네이티브 `NSURLSession` 엔진을 자동으로 사용합니다. 우리는 `commonMain`에서 Ktor의 공통 API만 호출하면 됩니다.

```kotlin
// In shared/src/commonMain/kotlin/com/example/shared/network/ApiClient.kt

import io.ktor.client.*
import io.ktor.client.call.*
import io.ktor.client.request.*
// (ktor-client-content-negotiation 및 kotlinx-serialization-json 플러그인 설정 필요)

class ApiClient {
    // HttpClient()를 생성하면 KMP가 알아서 플랫폼에 맞는 엔진을 주입합니다.
    private val client = HttpClient {
        // json() 플러그인을 설치하면 Ktor가 자동으로 kotlinx.serialization을 사용해
        // JSON을 데이터 클래스로 변환해 줍니다.
        install(ContentNegotiation) {
            json(Json { ignoreUnknownKeys = true })
        }
    }
    
    private val baseUrl = "https://api.randomuser.me/"

    // 이 함수는 100% 공통 코드로, Android와 iOS 모두에서 동일하게 동작합니다.
    suspend fun getRandomUser(): UserResponse { // UserResponse는 API 응답 전체를 감싸는 data class
        return client.get(baseUrl) {
             parameter("results", 1)
        }.body()
    }
}
```

#### 3\. 비즈니스 로직 / 저장소 공통화 (Repository Pattern)

이제 데이터 모델과 네트워크 계층이 준비되었습니다. 마지막으로, 이들을 조합하여 실제 앱에서 사용할 데이터를 가공하는 **비즈니스 로직**을 만듭니다. 이때 \*\*저장소 패턴(Repository Pattern)\*\*을 사용하여 관심사를 분리하는 것이 일반적입니다.

`UserRepository`는 `ApiClient`로부터 데이터를 가져와, UI가 필요로 하는 최종적인 형태로 가공하여 제공하는 역할을 `commonMain`에서 수행합니다.

```kotlin
// In shared/src/commonMain/kotlin/com/example/shared/repository/UserRepository.kt

class UserRepository {
    private val apiClient = ApiClient()

    // 이 함수가 바로 Android/iOS UI에서 직접 호출할 핵심 비즈니스 로직입니다.
    suspend fun getFormattedUserName(): String {
        return try {
            val response = apiClient.getRandomUser()
            val user = response.results.first() // API 응답 구조에 따라 첫 번째 유저 추출
            
            // 데이터를 UI 친화적인 형태로 가공 (비즈니스 로직)
            "${user.firstName} ${user.lastName.uppercase()}"
        } catch (e: Exception) {
            println("Error fetching user: ${e.message}")
            "Error: 사용자 로드 실패"
        }
    }
}
```

-----

이것으로 모든 준비가 끝났습니다. 우리는 `commonMain`에 데이터 모델(`User`), 네트워크 통신(`ApiClient`), 그리고 UI에 표시할 데이터를 가공하는 비즈니스 로직(`UserRepository`)까지 앱의 핵심 두뇌를 모두 구현했습니다.

이제 Android 앱과 iOS 앱은 이 공유 모듈의 `UserRepository`가 제공하는 `getFormattedUserName()` 함수 하나만 호출하면 됩니다. 복잡한 로직은 모두 공통 모듈에 캡슐화되어 있으며, 각 네이티브 플랫폼은 오직 이 결과 문자열을 화면에 보여주는 역할(UI)에만 집중하면 됩니다. 다음 섹션에서는 이 공유 모듈을 각 네이티브 UI에 연결하는 방법을 살펴보겠습니다.