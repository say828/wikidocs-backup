### 타입 추론: 컴파일러는 어떻게 타입을 아는가?

앞선 예제들에서 우리는 변수를 선언할 때 `val name: String = "Kotlin"`처럼 항상 자료형을 명시적으로 적어주었습니다. 하지만 코틀린 코드를 접하다 보면 아래와 같이 타입을 생략하는 경우를 훨씬 더 자주 보게 될 것입니다.

```kotlin
val name = "Kotlin"
val year = 2011
```

타입을 적어주지 않았음에도 불구하고, 이 코드는 아무런 문제 없이 완벽하게 동작합니다. 어떻게 이런 일이 가능할까요? 바로 코틀린 컴파일러가 가진 똑똑한 **타입 추론(Type Inference)** 기능 덕분입니다.

#### 타입 추론이란?

타입 추론은 개발자가 변수의 타입을 코드에 직접 명시하지 않아도, **컴파일러가 변수에 대입되는 초기값을 보고 타입을 스스로 유추하여 결정하는 기능**입니다.

마치 명탐정이 단서를 보고 범인을 추리하는 것과 같습니다. 🕵️‍♂️

  * 컴파일러는 `"Kotlin"`이라는 값을 봅니다. 이 값은 큰따옴표로 감싸여 있으므로, '아하\! 이건 `String`이 틀림없군.'이라고 추론합니다.
  * 컴파일러는 `2011`이라는 값을 봅니다. 이 값은 소수점이 없는 정수이므로, '흠, 이건 `Int`가 확실해.'라고 결론 내립니다.

이러한 추론 과정은 코드가 컴파일되는 시점에 일어나며, 한번 타입이 결정되면 그 이후에는 절대 다른 타입으로 변경될 수 없습니다.

```kotlin
val name = "Kotlin"       // 컴파일러는 name을 String 타입으로 추론합니다.
val year = 2011          // 컴파일러는 year를 Int 타입으로 추론합니다.
val pi = 3.14            // 컴파일러는 pi를 Double 타입으로 추론합니다.
val isAwesome = true     // 컴파일러는 isAwesome을 Boolean 타입으로 추론합니다.
```

타입 추론 덕분에 우리는 불필요한 상용구 코드를 대폭 줄일 수 있습니다. 코드는 훨씬 간결해지고, 핵심 로직에 더 집중할 수 있게 됩니다.

-----

#### 타입을 직접 명시해야 할 때

그렇다면 타입 선언은 이제 전혀 필요 없는 것일까요? 아닙니다. 타입 추론은 매우 편리하지만, 타입을 직접 명시해야 하거나 명시하는 것이 더 좋은 경우가 있습니다.

1.  **초기값으로 타입을 알 수 없을 때**
    변수를 선언만 하고 값을 나중에 할당하는 경우, 컴파일러는 어떤 타입인지 추론할 단서가 전혀 없습니다. 이럴 때는 반드시 타입을 명시해주어야 합니다.

    ```kotlin
    // var message // 컴파일 오류! 초기값이 없어 타입을 추론할 수 없습니다.
    var message: String // OK. String 타입임을 명시했습니다.
    message = "Hello"
    ```

2.  **숫자 타입을 명확히 하고 싶을 때**
    `10`이라는 값은 기본적으로 `Int`로 추론됩니다. 만약 이 값을 `Byte`나 `Long` 같은 다른 숫자 타입으로 다루고 싶다면, 타입을 명시적으로 선언해야 합니다. (물론 `10L`처럼 리터럴 접미사를 붙이는 방법도 있습니다.)

    ```kotlin
    val number = 10          // Int로 추론됨
    val smallNumber: Byte = 10 // Byte 타입으로 명시적 지정
    ```

3.  **코드의 가독성을 위해 (의도를 명확히 할 때)**
    함수의 반환 값이나 복잡한 표현식의 결과는 타입이 즉시 눈에 들어오지 않을 수 있습니다. 이런 경우, 비록 컴파일러가 타입을 추론할 수 있더라도 다른 개발자나 미래의 나를 위해 타입을 명시적으로 적어주는 것이 코드의 의도를 파악하는 데 도움이 될 수 있습니다.

#### 정적 타입 언어의 본질

한 가지 중요한 사실을 기억해야 합니다. 타입 추론은 코틀린이 **정적 타입(Statically-typed)** 언어라는 본질을 바꾸지 않습니다. 타입이 코드에 보이지 않을 뿐, 모든 변수의 타입은 컴파일 시점에 단 하나로 명확하게 결정됩니다. 한번 `String`으로 추론된 변수에 숫자를 할당하려고 하면 어김없이 컴파일 오류가 발생합니다.

이는 코드 실행 중에 타입 오류가 발생할 수 있는 동적 타입(Dynamically-typed) 언어(예: Python, JavaScript)와의 근본적인 차이점이며, 코틀린이 가진 **안정성**의 핵심입니다. 타입 추론은 정적 타입 언어의 안정성은 그대로 유지하면서, 동적 타입 언어의 간결함이라는 장점만을 취한 코틀린의 실용주의 철학을 보여주는 대표적인 기능입니다.