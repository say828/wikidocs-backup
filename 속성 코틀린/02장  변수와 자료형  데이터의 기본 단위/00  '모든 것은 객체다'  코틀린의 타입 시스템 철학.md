### '모든 것은 객체다': 코틀린의 타입 시스템 철학

코틀린의 세계를 이해하기 위해 가장 먼저 받아들여야 할 위대한 원칙이 하나 있습니다. 바로 **"코틀린에서는 모든 것이 객체(Object)다"** 라는 철학입니다.

자바와 같은 일부 언어에서는 데이터를 두 종류로 구분합니다. 숫자(`int`, `double` 등)처럼 순수한 값 자체를 의미하는 \*\*원시 타입(Primitive Type)\*\*과, 문자열(`String`)이나 개발자가 만든 클래스처럼 복잡한 데이터와 기능을 함께 가지는 \*\*참조 타입(Reference Type)\*\*으로 나뉩니다. 이 둘은 메모리에서 다뤄지는 방식도, 사용할 수 있는 기능도 다릅니다.

하지만 코틀린은 이러한 구분을 과감히 없앴습니다. 숫자 `10`, 진리값 `true`, 문자 `'A'`, 심지어 함수까지, 코틀린 세상에 존재하는 모든 것은 자신만의 속성(Properties)과 기능(Methods)을 가질 수 있는 객체입니다.

이것이 실질적으로 무엇을 의미할까요? 예를 들어, 숫자 `10`이 있다고 상상해 봅시다.

```kotlin
// 정수 10을 변수에 담는다.
val number: Int = 10

// 정수 10을 문자열 "10"으로 변환한다.
val text: String = number.toString() 
```

`number.toString()` 이라는 코드에 주목하세요. 우리는 숫자 `10`을 담고 있는 `number`라는 변수에게 `toString()` 이라는 '행동' 또는 '기능'을 직접 호출하고 있습니다. 이는 숫자 `10`이 단순한 값이 아니라, `toString()`이라는 기능을 내장한 하나의 온전한 객체이기 때문에 가능한 일입니다. 자바의 원시 타입 `int`였다면 상상할 수 없는 일이죠.

#### 성능 저하? 걱정하지 마세요.

경험 많은 개발자라면 "모든 것을 객체로 다루면 성능이 저하되지 않을까?"라는 의문을 가질 수 있습니다. 당연한 걱정입니다. 객체는 단순한 값보다 더 많은 메모리와 처리 비용을 요구하기 때문입니다.

하지만 이것이 바로 코틀린의 영리한 지점입니다. '모든 것은 객체'라는 것은 개발자가 코드를 작성하고 생각하는 관점에서의 이야기입니다. 코틀린 컴파일러는 우리가 작성한 코드를 JVM이 이해하는 바이트코드로 번역할 때, 극적인 최적화를 수행합니다. 불필요한 객체 포장(Wrapping) 없이, 숫자 `Int`는 가능한 모든 곳에서 자바의 원시 타입 `int`처럼 효율적으로 처리됩니다.

결과적으로 개발자는 **개념적 일관성**('모든 것은 객체'라는 단순하고 강력한 모델)과 **실행 성능**이라는 두 마리 토끼를 모두 잡게 됩니다. 이것이 바로 코틀린이 추구하는 실용주의 철학의 단면입니다. 이 위대한 원칙을 기억하며, 코틀린의 변수와 자료형을 본격적으로 탐험해 봅시다.