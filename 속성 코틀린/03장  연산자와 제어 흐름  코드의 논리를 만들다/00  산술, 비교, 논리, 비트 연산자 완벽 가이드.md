### 산술, 비교, 논리, 비트 연산자 완벽 가이드

연산자는 특정 연산을 수행하기 위해 약속된 기호입니다. 코틀린은 다른 여러 언어와 마찬가지로 직관적이고 익숙한 연산자들을 제공하여 데이터를 손쉽게 다룰 수 있도록 돕습니다.

---

#### 산술 연산자 (Arithmetic Operators)

가장 기본이 되는, 수학적 계산을 위한 연산자입니다.

| 연산자 | 의미 | 예시 (`val a = 10`, `val b = 3`) | 결과 |
| :--- | :--- | :--- | :---: |
| `+` | 덧셈 | `a + b` | `13` |
| `-` | 뺄셈 | `a - b` | `7` |
| `*` | 곱셈 | `a * b` | `30` |
| `/` | 나눗셈 | `a / b` | `3` |
| `%` | 나머지 | `a % b` | `1` |

**주의:** 정수와 정수의 나눗셈 결과는 소수점 이하를 버린 정수가 됩니다. `10 / 3`의 결과가 `3.333...`이 아닌 `3`이 되는 이유입니다. 정확한 소수점 결과를 원한다면 피연산자 중 하나 이상이 `Double`이나 `Float` 같은 실수 타입이어야 합니다. (`10.0 / 3`의 결과는 `3.333...` 입니다.)

코틀린에서는 이 연산자들이 사실 내부적으로는 `a.plus(b)` 와 같은 함수 호출로 동작합니다. 이는 '모든 것은 객체다'라는 코틀린의 철학을 보여주는 좋은 예시입니다.

##### 복합 대입 연산자와 증감 연산자

코드를 더 간결하게 만들어주는 연산자들도 있습니다.

* **복합 대입 연산자:** `a = a + b`를 `a += b` 와 같이 줄여 쓸 수 있습니다. (`-=`, `*=`, `/=`, `%=` 모두 사용 가능)
* **증감 연산자:** 변수의 값을 1만큼 증가(`++`)시키거나 감소(`--`)시킵니다. `i++`는 `i = i + 1`과 같습니다.

---

#### 비교 연산자 (Comparison Operators)

두 개의 값을 비교하여 그 결과를 `true` 또는 `false`의 `Boolean` 타입으로 반환합니다.

| 연산자 | 의미 | 예시 (`val a = 5`, `val b = 5`) | 결과 |
| :--- | :--- | :--- | :---: |
| `==` | 값이 같음 | `a == b` | `true` |
| `!=` | 값이 다름 | `a != b` | `false` |
| `>` | 왼쪽이 큼 | `a > 4` | `true` |
| `<` | 왼쪽이 작음 | `a < 4` | `false` |
| `>=` | 왼쪽이 크거나 같음 | `a >= 5` | `true` |
| `<=` | 왼쪽이 작거나 같음 | `a <= 5` | `true` |

**매우 중요한 차이점:** 자바와 달리, 코틀린의 `==` 연산자는 **구조적 동등성(Structural Equality)**을 비교합니다. 즉, 두 객체의 내용물이 같은지를 `equals()` 메서드를 통해 비교합니다. 두 변수가 메모리의 동일한 객체를 가리키는지(참조 동등성)를 확인하려면 `===` 연산자를 사용합니다. 하지만 대부분의 경우 내용물을 비교하는 `==`를 사용하게 될 것입니다.

---

#### 논리 연산자 (Logical Operators)

여러 개의 `Boolean` 표현식을 조합하여 더 복잡한 논리를 만들 때 사용합니다.

| 연산자 | 이름 | 의미 | 예시 |
| :--- | :--- | :--- | :--- |
| `&&` | AND | 두 조건이 **모두** `true`일 때만 `true` | `(a > 0) && (b < 10)` |
| `||` | OR | 두 조건 중 **하나라도** `true`이면 `true` | `(a < 0) || (b > 0)` |
| `!` | NOT | `Boolean` 값을 반대로 뒤집음 | `!isReady` (`false` -> `true`) |

---

#### 비트 연산자 (Bitwise Operators)

데이터를 비트(bit) 수준에서 직접 조작해야 하는 저수준(low-level) 프로그래밍에 사용되는 연산자입니다. 코틀린은 `&`, `|` 와 같은 기호 대신, **명시적인 이름의 함수**를 사용하여 논리 연산자와의 혼동을 막고 코드의 가독성을 높였습니다.

| 함수 (Infix) | 의미 | 예시 (10진수) | 예시 (2진수) |
| :--- | :--- | :--- | :--- |
| `shl` | 부호 있는 왼쪽 시프트 | `8 shl 1` (결과: 16) | `1000 shl 1` (결과: `10000`) |
| `shr` | 부호 있는 오른쪽 시프트 | `8 shr 1` (결과: 4) | `1000 shr 1` (결과: `100`) |
| `ushr` | 부호 없는 오른쪽 시프트 | | (부호 비트까지 이동) |
| `and` | 비트 AND | `9 and 10` (결과: 8) | `1001 and 1010` (결과: `1000`) |
| `or` | 비트 OR | `9 or 10` (결과: 11) | `1001 or 1010` (결과: `1011`) |
| `xor` | 비트 XOR | `9 xor 10` (결과: 3) | `1001 xor 1010` (결과: `0011`) |
| `inv()` | 비트 NOT (반전) | `9.inv()` | `...00001001` -> `...11110110`|

이러한 연산자들은 앞으로 배울 조건문과 반복문의 핵심적인 재료가 됩니다. 이제 이 도구들을 가지고 프로그램의 흐름을 제어하는 방법을 배워봅시다.