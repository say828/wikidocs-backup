### Nullable 타입과 Non-Null 타입의 명확한 구분

코틀린의 널 안정성은 복잡한 기능이 아닌, 단 하나의 단순하고 명확한 규칙에서 시작됩니다. 바로 **타입 시스템이 널(null)의 가능성을 명시적으로 구분하고 강제한다**는 것입니다.

-----

#### Non-Null 타입: '절대 null이 아님'이라는 약속

코틀린의 모든 타입은 기본적으로 **Non-Null**, 즉 `null` 값을 가질 수 없습니다. `String`, `Int`, `Person` 처럼 `?`가 붙지 않은 모든 타입이 여기에 해당합니다.

`val name: String = "Kotlin"`

이렇게 변수를 Non-Null 타입으로 선언하는 것은 컴파일러와의 **약속**입니다. 개발자는 컴파일러에게 "이 `name` 변수는 프로그램이 실행되는 동안 절대 `null`이 되지 않을 것이니 안심하라"고 보증하는 것과 같습니다.

컴파일러는 이 약속을 신뢰하기 때문에, 우리가 해당 변수의 프로퍼티나 메서드에 접근할 때 아무런 추가 검사도 요구하지 않습니다.

```kotlin
fun getLength(text: String): Int {
    // text 파라미터는 Non-Null 타입으로 선언되었으므로,
    // NPE 걱정 없이 안전하게 .length를 호출할 수 있습니다.
    return text.length
}
```

-----

#### Nullable 타입: 'null일 수 있음'이라는 가능성의 인정

만약 변수가 `null` 값을 가질 가능성이 있다면, 우리는 타입 뒤에 물음표(`?`)를 붙여 이 사실을 컴파일러에게 명시적으로 알려야 합니다. 이것이 **Nullable** 타입입니다.

`val name: String? = null`

`String?` 타입 선언은 "이 `name` 변수는 `String` 값을 가질 수도 있지만, 특정 시점에는 값이 없는 `null` 상태일 수도 있다"라고 가능성을 인정하는 것입니다.

이 순간부터 컴파일러는 더 이상 우리를 신뢰하지 않고, 엄격한 안전요원으로 돌변합니다. 컴파일러는 Nullable 타입의 변수를 사용할 때마다, 우리가 `null`일 경우를 제대로 처리하는지 감시하고 강제합니다.

```kotlin
fun getLength(text: String?): Int? {
    // return text.length // 컴파일 오류!
    // 컴파일러가 "text가 null이면 어떡할 건데?"라며 이 코드를 막아섭니다.
    // NPE가 발생할 수 있는 위험한 코드입니다.
}
```

#### 타입 시스템과의 대화

이러한 구분은 개발자와 컴파일러 간의 명확한 의사소통 체계를 만듭니다.

  * `String`:
      * **개발자**: "이 변수는 절대 `null` 아니야. 내가 보증할게."
      * **컴파일러**: "알았어. 믿고 마음껏 쓰게 해줄게."
  * `String?`:
      * **개발자**: "조심해. 이 변수는 `null`일 수도 있어."
      * **컴파일러**: "알았어. 그렇다면 네가 이 변수를 사용하기 전에 `null`이 아니라는 걸 증명해. 그렇지 않으면 컴파일시켜주지 않을 거야."

이처럼 `null`이 될 수 있는 가능성을 타입 시스템 안으로 끌어들여 컴파일 시점에 모든 위험을 차단하는 것, 이것이 코틀린 널 안정성의 근간입니다. 이제부터 우리는 `null`이 아니라는 것을 컴파일러에게 '증명'하는 다양한 방법들을 배우게 될 것입니다.