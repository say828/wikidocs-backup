# 07장: GitOps: 지속 가능한 플랫폼 운영의 새로운 패러다임

우리는 지금까지 쿠버네티스라는 강력한 기계를 다루는 다양한 기술을 연마했다. 상태가 없는 워크로드부터 까다로운 상태 저장 워크로드까지, 그리고 이들을 안전하게 배포하고 구성하는 정교한 패턴들을 익혔다. 당신의 손에는 이제 `kubectl`, `helm`, `kustomize`와 같은 강력한 도구들이 들려있다. 하지만 바로 그 강력함 속에, 우리도 모르는 사이 스며드는 가장 위험한 적, **'엔트로피(Entropy)'**가 숨어있다.

당신이 급한 운영 이슈를 해결하기 위해 `kubectl scale deployment ... --replicas=5` 명령을 터미널에 입력하는 순간, 당신의 클러스터는 '기록되지 않은 역사'를 갖게 된다. Git에 선언된 YAML 파일의 `replicas`는 여전히 3인데, 실제 운영 환경의 상태는 5가 되어버린다. 이 작은 불일치, 즉 **'드리프트(Drift)'**는 시작에 불과하다. 수많은 개발자와 운영자가 각자의 터미널에서 명령을 내리기 시작하면, 클러스터의 실제 상태는 그 누구도 정확히 알 수 없는 미지의 영역이 되어버린다. 이것이 바로 명령형 관리의 함정이다.

이 장에서는 바로 이 혼돈에 질서를 부여하고, 우리 플랫폼의 모든 상태를 단 하나의 진실 공급원에서 투명하게 관리하는 현대적인 운영 패러다임, **GitOps**의 세계로 들어간다. 우리는 `kubectl apply`를 왜 경계해야 하는지부터 시작하여, GitOps를 지탱하는 네 가지 핵심 원칙을 배울 것이다. 그리고 이 철학을 현실로 만들어주는 가장 강력한 도구인 **Argo CD**를 활용하여, 실제로 Git 저장소와 클러스터를 동기화하는 파이프라인을 구축해볼 것이다. 마지막으로, 수십, 수백 개의 애플리케이션을 단 하나의 저장소에서 우아하게 관리하는 **'App of Apps' 패턴**을 통해 당신의 플랫폼 운영을 지속 가능하고 확장 가능한 경지로 끌어올릴 것이다.

---

## 00. kubectl apply를 버려야 하는 이유: 명령형 관리의 함정

`kubectl apply -f my-app.yaml`. 이 명령어는 아마도 당신이 쿠버네티스를 배우며 가장 처음 실행해본, 그리고 가장 익숙한 명령어일 것이다. 이 명령어는 우리가 YAML 파일에 선언한 '이상적인 상태'를 클러스터에 적용해주는, 선언적 관리의 기본 도구처럼 보인다. 하지만 이 행위의 주체가 **'당신'**이라는 사실에 바로 함정이 있다.

당신의 로컬 머신, 당신의 터미널에서 실행되는 `kubectl`은 다음과 같은 근본적인 문제들을 잉태한다.

1.  **누가, 언제, 왜 변경했는가? (Audit & Accountability의 부재):** 당신의 동료가 "어젯밤부터 갑자기 파드 개수가 절반으로 줄었어요!"라고 외칠 때, 당신은 어떻게 그 원인을 추적할 것인가? `kubectl` 명령어는 중앙에 기록되지 않는다. 누가 어떤 이유로 `replicas`를 변경했는지에 대한 감사 추적(Audit Trail)이 전혀 남지 않는다. 이것은 장애 대응과 보안 감사의 악몽이다.

2.  **당신의 로컬 머신은 진실의 원천이 아니다 (Source of Truth의 부재):** 당신이 `kubectl apply`를 실행하는 그 YAML 파일은 정말 최신 버전인가? 혹시 Git 저장소에는 다른 변경 사항이 있는데 `git pull` 하는 것을 잊지는 않았는가? 당신의 동료가 방금 다른 변경 사항을 적용했다면? 클러스터의 상태는 여러 사람의 로컬 환경이라는, 파편화되고 동기화되지 않은 '진실'들의 충돌 지점이 되어버린다.

3.  **권한 관리의 복잡성:** 모든 개발자와 운영자에게 프로덕션 클러스터에 직접 `apply`할 수 있는 `kubeconfig` 파일을 나눠주는 것은 엄청난 보안 위험을 초래한다. 각 개인의 권한을 RBAC으로 세밀하게 관리하는 것은 복잡하며, 누군가의 노트북이 탈취당했을 때의 위험은 상상하기조차 싫다.

4.  **자동화의 부재:** 시스템의 상태를 변경하는 유일한 방법이 인간의 수동 개입이라면, 우리는 결코 진정한 자동화를 이룰 수 없다. `kubectl apply`는 CI/CD 파이프라인의 마지막 단계를 자동화할 수는 있지만, 배포 이후에 발생하는 '상태 드리프트'를 감지하고 자동으로 바로잡아주지는 못한다.



**명령형(Imperative) 관리**의 본질은 "시스템아, 지금 당장 이렇게 행동해!"라고 명령하는 것이다. `kubectl apply`는 비록 선언적인 파일을 입력으로 받지만, 그 실행 주체가 인간의 손끝에 달려있다는 점에서 여전히 명령형 관리의 그림자에서 벗어나지 못한다.

진정한 **선언적(Declarative) 관리**란, "시스템아, 이것이 우리가 원하는 이상적인 모습이야. 이제부터 너는 무슨 일이 있어도 이 모습을 스스로 유지해야 해"라고 최종 목표를 선언하고, 그 목표를 달성하고 유지하는 모든 책임을 시스템 자체에 위임하는 것이다.

이를 실현하기 위한 패러다임이 바로 GitOps다. GitOps는 인간의 직접적인 클러스터 접근을 원천적으로 차단한다. 클러스터를 변경하는 유일한 방법은 진실의 원천인 **Git 저장소**에 우리의 '의도'를 코드로 제출하고, 클러스터 안에 있는 자동화된 에이전트가 그 변경 사항을 감지하여 스스로를 업데이트하도록 하는 것이다. 이제, 이 혁신적인 패러다임의 구체적인 원칙들을 살펴보자.