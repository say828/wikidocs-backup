# 01장: 쿠버네티스의 심장: 선언적 API와 제어 루프

만약 누군가 나에게 쿠버네티스의 성공 비결을 단 하나만 꼽으라고 한다면, 나는 주저 없이 **선언적 API(Declarative API)**와 그 뒤에서 묵묵히 모든 것을 현실로 만드는 **제어 루프(Control Loop)** 메커니즘이라고 답할 것이다. 수많은 기능과 화려한 CNCF 생태계 프로젝트들은 모두 이 단단한 철학적 기반 위에 세워진 건축물에 불과하다.

대부분의 입문자들은 파드(Pod)를 생성하고 디플로이먼트(Deployment)를 통해 애플리케이션을 배포하는 방법부터 배운다. 하지만 이는 마치 자동차의 엔진 구조는 모른 채 운전 방법만 배우는 것과 같다. 당장은 도로를 달릴 수 있겠지만, 차가 고장 났을 때 보닛 한번 열어보지 못하고, 극한의 상황에서 최적의 성능을 끌어내는 튜닝은 꿈도 꾸지 못한다.

이 장에서는 쿠버네티스라는 자동차의 엔진룸을 열어 그 심장을 직접 들여다볼 것이다. 우리는 쿠버네티스의 정신적 모태가 된 구글의 내부 시스템으로부터 어떤 교훈을 얻었는지 살펴보고, 왜 '상태를 선언한다'는 행위가 분산 시스템을 다루는 가장 우아한 방법인지를 이해하게 될 것이다. 이 장을 끝낼 때쯤, 당신은 더 이상 YAML 파일을 귀찮은 설정 파일 뭉치로 보지 않게 될 것이다. 그것은 당신의 '의도'를 담아 거대한 클러스터를 움직이는 강력한 마법 주문처럼 느껴지게 될 것이다.

## 00. 쿠버네티스의 설계 철학: 구글 Borg와 Omega로부터의 교훈

쿠버네티스는 하늘에서 뚝 떨어진 기술이 아니다. 그것은 10년이 넘는 시간 동안 구글이라는 행성 규모의 인프라 위에서 수십억 개의 컨테이너를 운영하며 얻은 피와 땀, 그리고 통찰의 결정체다. 쿠버네티스의 DNA를 이해하려면, 우리는 그 정신적 조상이라 할 수 있는 **보그(Borg)**와 **오메가(Omega)** 시스템의 역사부터 거슬러 올라가야만 한다.

내가 구글에 몸담고 있던 시절, 우리는 이미 전 세계 수만 대의 머신을 하나의 거대한 컴퓨터처럼 사용하는 도전에 직면해 있었다. 이 도전에 대한 첫 번째 해답이 바로 보그였다. 보그는 클러스터 관리의 개념을 정립한 선구자였다. 수많은 머신을 '셀(Cell)'이라는 단위로 묶고, 사용자가 '잡(Job)'을 제출하면 보그는 셀 안의 비어있는 머신을 찾아 잡에 속한 '태스크(Task)'들을 스케줄링했다. 검색, 지메일, 맵스 등 구글의 거의 모든 서비스가 보그 위에서 동작했다.

보그는 놀랍도록 성공적이었지만, 그 구조에는 근본적인 한계가 있었다. 모든 스케줄링 결정이 **중앙 집중화된 마스터(Borgmaster)**에 의해 이루어졌다는 점이다. 클러스터의 규모가 커지고 잡의 종류가 다양해지면서, 이 중앙 마스터는 점점 거대한 병목 지점이 되어갔다. 또한, 모든 스케줄링 로직이 마스터 내부에 단일체(monolithic) 형태로 구현되어 있어 새로운 기능을 추가하거나 변경하는 것이 지극히 어려웠다.

이러한 보그의 한계를 극복하기 위한 차세대 프로젝트가 바로 오메가였다. 오메가의 핵심적인 발상은 **상태 저장소(State Store)를 중심으로 아키텍처를 완전히 분리**한 것이었다. 오메가는 클러스터의 모든 상태(머신의 자원 현황, 실행 중인 태스크 등)를 공유된 저장소(오늘날의 etcd와 유사한)에 기록했다. 그리고 스케줄링 로직을 마스터에서 분리하여, 여러 개의 특화된 스케줄러들이 이 공유 저장소를 함께 바라보며 병렬적으로 동작하도록 만들었다. 예를 들어, 짧은 배치 잡을 위한 스케줄러와 오랜 시간 실행되는 서비스형 잡을 위한 스케줄러가 독립적으로, 하지만 공유된 상태를 기반으로 협력하며 동작하는 것이 가능해졌다.

[그림: 중앙 집중형 보그 아키텍처와 공유 상태 기반의 오메가 아키텍처 비교]

이 보그와 오메가의 경험으로부터 쿠버네티스는 다음과 같은 핵심적인 설계 철학을 물려받았다.

1.  **모든 것은 API 객체다:** 보그의 잡, 태스크와 같은 개념은 쿠버네티스에서 Pod, Deployment, Service와 같은 잘 정의된 **API 객체(Object)**로 진화했다. 시스템을 조작하는 유일한 방법은 이 객체들의 상태를 생성하고, 조회하고, 수정하고, 삭제하는 것뿐이다. 이는 시스템의 모든 상태가 일관된 방식으로 표현되고 관리될 수 있는 기반이 되었다.
2.  **중앙 상태 저장소의 중요성:** 오메가의 공유 저장소 철학은 쿠버네티스의 **etcd**로 계승되었다. 클러스터의 모든 desired state(사용자가 원하는 상태)와 current state(실제 상태)는 오직 etcd에만 저장된다. 나머지 모든 컴포넌트(스케줄러, 컨트롤러 매니저 등)는 상태를 가지지 않으며(stateless), 오직 etcd의 상태를 감시하고 그에 따라 행동할 뿐이다. 이는 시스템의 특정 컴포넌트에 장애가 발생해도 상태 정보가 유실되지 않으며, 시스템 전체의 회복탄력성을 극적으로 높여주었다.
3.  **분산된 컨트롤러들의 협력:** 오메가의 병렬 스케줄러처럼, 쿠버네티스는 특정 역할을 수행하는 수많은 작은 **컨트롤러(Controller)**들의 집합으로 구성된다. 디플로이먼트 컨트롤러는 디플로이먼트 객체의 상태를 감시하고, 노드 컨트롤러는 노드의 상태를 감시한다. 이들은 서로 직접 통신하지 않는다. 오직 etcd에 저장된 API 객체의 상태를 매개로 느슨하게 결합되어(loosely coupled) 협력할 뿐이다. 이 구조야말로 쿠버네티스를 무한히 확장 가능하게 만드는 핵심 비결이다.

결국 쿠버네티스는 '어떻게 컨테이너를 실행시킬 것인가'에 대한 명령의 집합이 아니다. 그것은 '클러스터가 어떤 모습이어야 하는가'를 기술하는 **공유된 진실의 원천(Shared Source of Truth)**을 중심으로, 그 상태를 현실로 만들기 위해 끊임없이 노력하는 분산된 자동화 에이전트들의 생태계다. 이 핵심 철학을 이해했다면, 이제 우리는 이 모든 것을 가능하게 만드는 심장 박동, 즉 제어 루프의 세계로 들어갈 준비가 된 것이다.