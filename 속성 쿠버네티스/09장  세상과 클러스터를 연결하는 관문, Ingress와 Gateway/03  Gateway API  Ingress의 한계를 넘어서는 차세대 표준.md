## 03. Gateway API: Ingress의 한계를 넘어서는 차세대 표준

Ingress는 쿠버네티스에 L7 라우팅의 문을 열어주었지만, 그 문은 너무 좁고 낡았다. 플랫폼이 성숙하고 멀티테넌시와 같은 복잡한 요구사항이 대두되면서, Ingress API의 근본적인 한계들이 명확해지기 시작했다. 거대한 Ingress 리소스 하나를 플랫폼 관리자와 수많은 애플리케이션 개발자가 함께 수정하는 것은 혼돈 그 자체였고, 모든 고급 기능이 비표준 어노테이션에 의존하는 현실은 이식성을 앗아갔다.

이러한 혼돈 속에서 질서를 되찾고, 쿠버네티스 네트워킹을 다음 시대로 이끌기 위해 SIG-NETWORK 커뮤니티가 내놓은 해답이 바로 **Gateway API**다. Gateway API는 Ingress를 단순히 개선한 것이 아니다. 그것은 트래픽 관리를 바라보는 관점 자체를 완전히 재구성한, **역할 중심적(Role-Oriented)**이고, **표현력(Expressive)**이 풍부하며, **확장 가능(Extensible)**한 차세대 표준이다. 👑

---

### 역할의 분리: 누가 무엇을 책임지는가?

Gateway API의 가장 혁신적인 아이디어는, 거대하고 단일한 Ingress 리소스를 여러 개의 역할 중심적인 리소스로 분리한 것이다. 이는 플랫폼 인프라를 관리하는 사람과 그 위에서 애플리케이션을 운영하는 사람의 관심사를 명확하게 분리한다.

* **플랫폼 관리자 (Infrastructure Provider / Cluster Operator):** 이들의 역할은 클러스터의 '공동 현관'을 만들고 관리하는 것이다. 어떤 종류의 로드밸런서를 사용할지, 어떤 포트를 열고 어떤 TLS 인증서를 기본으로 사용할지 등, 클러스터 전체에 영향을 미치는 인프라적인 결정을 내린다.
* **애플리케이션 개발자 (Application Developer):** 이들의 역할은 자신의 애플리케이션으로 들어오는 트래픽의 라우팅 규칙을 정의하는 것이다. `/users` 경로는 `user-service`로, `/orders` 경로는 `order-service`로 보내는 것과 같이, 애플리케이션의 내부 로직에만 집중한다. 그 트래픽이 어떤 로드밸런서를 통해 들어오는지 알 필요가 없다.

이러한 역할 분리는 세 가지 핵심적인 CRD를 통해 구현된다.

1.  **`GatewayClass` (플랫폼 관리자):** 어떤 종류의 Ingress Controller(예: NGINX, Contour, Istio)를 사용할지를 정의하는 템플릿이다. "우리 회사에서는 'nginx-premium'과 'envoy-fast' 두 종류의 게이트웨이를 제공합니다"라고 선언하는 것과 같다.
2.  **`Gateway` (플랫폼 관리자):** `GatewayClass`를 실제로 구현한 인스턴스다. "인터넷과 통하는 `external-https` 게이트웨이를 443 포트로 열고, `*.example.com` 도메인을 위한 와일드카드 TLS 인증서를 사용하겠습니다"라고 선언한다. 이것이 바로 실제 로드밸런서와 리스너를 생성하는 지점이다.
3.  **`HTTPRoute` (애플리케이션 개발자):** 특정 `Gateway`에 자신의 라우팅 규칙을 **'붙이는(attach)'** 리소스다. "저는 `external-https` 게이트웨이를 통해 들어오는 트래픽 중 `myapp.example.com`으로 오는 요청을 제 `my-app-service`로 보내고 싶습니다"라고 선언한다.



이 모델 덕분에, 개발자는 더 이상 플랫폼 관리자의 거대한 Ingress 설정을 건드릴 위험 없이, 자신의 네임스페이스 안에서 `HTTPRoute` 리소스만을 안전하게 관리할 수 있게 된다. 이는 멀티테넌시 환경의 보안과 안정성을 극적으로 향상시킨다.

---

### 표현력과 확장성: Ingress가 할 수 없었던 것들

Gateway API는 Ingress가 어노테이션에 의존했던 수많은 고급 기능들을 API 명세의 **일급 시민(first-class citizen)**으로 끌어올렸다.

* **가중치 기반 트래픽 분할:** `HTTPRoute` 리소스 안에서 표준화된 필드를 통해 "90%의 트래픽은 v1 서비스로, 10%는 v2 서비스(카나리)로 보내라"와 같은 규칙을 명시적으로 선언할 수 있다.
* **헤더 기반 라우팅:** "HTTP 헤더에 `X-Canary: true`가 있는 요청만 v2 서비스로 보내라"와 같은 정교한 라우팅이 가능하다.
* **요청 미러링:** 프로덕션 트래픽의 복사본을 테스트 환경으로 보내 실제 부하를 시험해볼 수 있다.
* **프로토콜 확장성:** `HTTPRoute`뿐만 아니라, `TCPRoute`, `UDPRoute`, `TLSRoute` 등을 통해 L4 트래픽과 non-HTTP L7 트래픽까지 표준화된 방식으로 다룰 수 있다.

이처럼 풍부하고 표현력 있는 API는 더 이상 특정 구현체에 종속되지 않는, 진정으로 이식 가능한 라우팅 구성을 가능하게 한다.

### 미래는 이미 여기에

Gateway API는 더 이상 먼 미래의 이야기가 아니다. 이미 수많은 Ingress Controller와 서비스 메시 프로젝트(Contour, Istio, NGINX, Traefik 등)가 Gateway API 구현을 지원하고 있으며, 빠르게 사실상의 표준으로 자리 잡고 있다.

Ingress가 쿠버네티스 네트워킹의 1막을 열었다면, Gateway API는 그 2막을 여는 주인공이다. 그것은 단순한 기술적 개선을 넘어, 복잡한 플랫폼 환경에서 여러 팀이 안전하고 효율적으로 협업할 수 있도록 돕는 조직적인 해결책을 제시한다.

이제 우리는 클러스터의 내부와 외부를 잇는 가장 현대적이고 견고한 관문을 손에 넣었다. 하지만 우리의 여정은 아직 끝나지 않았다. 애플리케이션의 보안은 단순히 네트워크를 격리하고 암호화하는 것만으로 완성되지 않는다. 다음 장에서는 애플리케이션의 '신원'과 '권한'을 다루는, 쿠버네티스 보안의 가장 깊은 심장부, **DevSecOps**의 세계로 들어갈 것이다.