## 02. API를 중심으로 모든 것이 움직인다: The Kubernetes Way

우리는 제어 루프가 '이상적인 상태'와 '현재 상태'를 일치시키는 과정이라는 것을 확인했다. 그렇다면 이 수많은 분산된 컨트롤러들과 사용자는 어떻게 상태에 대한 정보를 주고받고, 어떻게 서로의 작업을 조율하는가? 만약 각 컴포넌트가 개별적으로 통신하기 시작한다면, 시스템은 순식간에 거미줄처럼 얽힌 통신 지옥으로 변해버릴 것이다.

쿠버네티스는 이 문제에 대해 지극히 명쾌하고 우아한 해답을 제시한다. 바로 **모든 것을 API 서버(`kube-apiserver`)라는 단일한 관문으로 집중시키는 것**이다. 쿠버네티스의 세계에서 API 서버는 클러스터의 유일한 정문이자 중앙 신경 시스템이다. 클러스터의 그 어떤 컴포넌트도 다른 컴포넌트와 직접 대화하지 않는다. 스케줄러가 컨트롤러 매니저에게 말을 걸지 않고, 노드 위에서 동작하는 Kubelet이 스케줄러에게 직접 연락하는 일도 없다. 그들은 모두 오직 API 서버하고만 대화한다.

당신이 터미널에 입력하는 `kubectl` 명령어부터 살펴보자. `kubectl`은 마법적인 도구가 아니다. 그 본질은 쿠버네티스 API 서버와 통신하는 매우 잘 만들어진 **REST API 클라이언트**일 뿐이다. 당신이 `kubectl apply -f deployment.yaml` 명령을 실행할 때, `kubectl`은 YAML 파일을 파싱하여 JSON 형식의 API 요청으로 변환하고, 이를 API 서버의 적절한 엔드포인트(예: `/apis/apps/v1/namespaces/default/deployments`)로 전송한다.

이 API 중심 아키텍처의 진정한 힘은, 인간 사용자뿐만 아니라 **클러스터를 구성하는 모든 내부 컴포넌트 역시 똑같은 API의 클라이언트**라는 점에서 드러난다.

* **컨트롤러 매니저(Controller Manager):** 디플로이먼트 컨트롤러, 레플리카셋 컨트롤러 등 수많은 제어 루프를 실행하는 이 컴포넌트는, API 서버를 통해 특정 리소스(Deployment, ReplicaSet 등)의 변경 사항을 구독(watch)한다. 그리고 자신의 임무를 수행하기 위해 파드를 생성하거나 ReplicaSet의 상태를 업데이트하는 등의 작업을 다시 API를 통해 요청한다.
* **스케줄러(Scheduler):** 스케줄러는 `spec.nodeName` 필드가 비어있는 새로운 파드가 API 서버에 등록되기를 끊임없이 감시한다. 적절한 파드를 발견하면, 클러스터의 모든 노드 상태 정보를 API를 통해 조회하여 가장 적합한 노드를 선택한 후, 그 결과를 다시 파드 객체의 `spec.nodeName`에 기록하는 API 요청을 보낸다.
* **Kubelet:** 각 노드에서 실행되는 에이전트인 Kubelet은 자기 자신(노드)에게 할당된 파드 목록을 얻기 위해 API 서버를 주기적으로 확인한다. 그리고 해당 파드 명세에 맞게 컨테이너를 실행하거나 중지시킨 후, 그 결과를 파드의 `status` 필드에 기록하여 API 서버로 다시 보고한다.

[그림: 쿠버네티스 API를 중심으로 한 허브-앤-스포크(Hub-and-Spoke) 아키텍처]
*(중앙에 API 서버가 위치하고, kubectl, 컨트롤러 매니저, 스케줄러, Kubelet, 그리고 외부 시스템들이 모두 API 서버를 통해서만 상호작용하는 모습을 보여주는 다이어그램)*

이러한 **API 중심(API-centric)** 설계는 쿠버네티스에 경이로운 수준의 **느슨한 결합(Loose Coupling)**과 **확장성(Extensibility)**을 부여한다.

새로운 종류의 컨트롤러를 추가하고 싶다면? 그저 API 서버와 대화할 줄 아는 프로그램을 하나 만들어 실행시키기만 하면 된다. 기존의 어떤 컴포넌트도 수정할 필요가 없다. CI/CD 파이프라인, 모니터링 시스템, 정책 엔진 등 외부의 어떤 도구라도 API를 통해 클러스터와 상호작용하며 생태계의 일부가 될 수 있다.

이것이 바로 "The Kubernetes Way"다. 모든 것을 표준화된 API 리소스로 모델링하고, 모든 상호작용을 중앙 API 서버를 통해 이루어지게 하며, 각자의 역할을 수행하는 독립적인 컨트롤러들이 이 API를 중심으로 협력하게 만드는 것. 이 철학 덕분에 쿠버네티스는 단순한 컨테이너 오케스트레이터를 넘어, **분산 시스템을 구축하기 위한 궁극의 플랫폼, 즉 '클라우드 네이티브 시대의 커널(Kernel)'**이 될 수 있었던 것이다.

자, 이제 우리는 이 위대한 시스템의 소통 방식과 동작 원리를 이해했다. 그렇다면 우리는 이 API를 통해 우리의 '의도'를 어떻게 표현해야 하는가? 왜 하필 우리는 수많은 설정 파일 형식 중에 YAML을 통해 그 '상태'를 선언해야만 하는 것일까? 다음 절에서 이 질문에 대한 답을 찾아보자.