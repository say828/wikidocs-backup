## 03. 왜 우리는 YAML을 통해 '상태'를 선언해야만 하는가

수많은 개발자들이 쿠버네티스를 처음 접하며 부딪히는 장벽이자, 오랫동안 사용해온 이들조차 종종 불평하는 대상이 바로 **YAML**이다. 길고 장황하며, 들여쓰기 하나에 모든 것이 망가지는 이 형식에 대해 "왜 하필 YAML인가?"라는 질문을 던지는 것은 당연하다. JSON이 더 엄격하고, TOML이 더 간결하며, 심지어는 Python이나 Go와 같은 프로그래밍 언어로 상태를 정의하는 것이 더 강력하지 않았을까?

이 질문에 대한 답을 찾는 과정은, 쿠버네티스가 왜 그토록 강력한지를 다시 한번 깨닫게 되는 여정이 될 것이다. YAML의 선택은 단순한 파일 형식의 문제가 아니라, 쿠버네티스의 선언적 철학을 완성하는 마지막 핵심 조각이기 때문이다.

가장 본질적인 이유는 이것이다: **YAML은 로직(Logic)이 아닌 순수한 데이터(Data)다.**

당신이 YAML 파일을 작성하는 행위는 '파드를 생성하는 5단계 절차를 코딩'하는 것이 아니다. 당신은 그저 '파드라는 이름의 데이터 객체가 최종적으로 가져야 할 속성들의 집합'을 기술하고 있을 뿐이다. 여기에는 조건문도, 반복문도, 예외 처리도 없다. 오직 '상태'에 대한 명세만이 존재한다.

이것이 왜 그토록 중요한가? 바로 **관심사의 분리(Separation of Concerns)**를 극단적으로 강제하기 때문이다.

* **'무엇(What)'은 당신(사용자)의 몫이다:** 당신은 YAML을 통해 "NGINX 컨테이너를 가진 파드 3개가 필요하다"라는 최종 목표, 즉 **'무엇'**을 정의한다.
* **'어떻게(How)'는 쿠버네티스(컨트롤러)의 몫이다:** 이 목표를 달성하기 위해 어떤 노드에 파드를 스케줄링하고, 컨테이너 런타임을 어떻게 호출하며, 만약 실패하면 어떤 재시도 로직을 탈 것인지와 같은 복잡한 실행 절차, 즉 **'어떻게'**는 전적으로 쿠버네티스 컨트롤러들의 책임이다.

만약 우리가 Python 스크립트로 상태를 정의한다고 상상해보자. 머지않아 누군가는 그 스크립트 안에 `if`문을 넣어 특정 조건에 따라 파드의 수를 바꾸려 할 것이고, `for`문을 돌려 파드에 동적인 이름을 붙이려 할 것이다. 이는 순식간에 '상태 선언'을 '절차적 스크립팅'으로 변질시키고, 시스템의 상태를 예측하고 검증하는 것을 극도로 어렵게 만든다. YAML은 그 구조 자체로 이러한 유혹을 원천적으로 차단한다.

더 나아가, YAML과 같은 데이터 직렬화 형식은 **인간과 기계 모두를 위한 언어**라는 이중적인 장점을 가진다.

* **인간을 위해:** YAML은 (들여쓰기에 대한 원성에도 불구하고) JSON에 비해 주석을 추가할 수 있고 구조를 한눈에 파악하기 용이하여 사람이 읽고 검토하기에 적합하다. 이는 곧 우리가 선언한 '이상적인 상태'가 코드 리뷰의 대상이 될 수 있음을 의미한다. 시스템의 변경 사항이 동료의 검토를 거쳐 Git에 기록되고 추적된다. 이것이 바로 7장에서 자세히 다룰 **GitOps** 패러다임의 문을 여는 열쇠다.
* **기계를 위해:** YAML은 동시에 매우 엄격한 구조를 가진 기계 친화적인 데이터 형식이다. 이는 쿠버네티스 API 서버가 이 데이터를 안정적으로 파싱하고 유효성을 검증할 수 있게 한다. 또한 `kubectl`, 렌즈(Lens)와 같은 클라이언트 도구부터 키베르노(Kyverno), OPA와 같은 정책 엔진에 이르기까지, 수많은 생태계 도구들이 이 표준화된 데이터 구조를 이해하고, 분석하고, 조작하고, 강화하는 것을 가능하게 한다.

물론, 애플리케이션이 복잡해지면서 수백, 수천 줄의 YAML을 수동으로 관리하는 것이 고통스럽다는 사실을 부정할 수는 없다. 이른바 **'YAML 지옥(YAML Hell)'**이라 불리는 이 현실적인 문제는 우리에게 새로운 도전 과제를 안겨주었다. 하지만 중요한 것은, 바로 이 고통이 YAML을 버리는 방향이 아니라, YAML이라는 '데이터'를 더 지능적으로 생성하고 관리하기 위한 더 높은 수준의 추상화 도구, 즉 **헬름(Helm)**과 **커스터마이즈(Kustomize)**를 탄생시키는 원동력이 되었다는 점이다. 이에 대해서는 4장에서 깊이 있게 다룰 것이다.

결론적으로, YAML은 쿠버네티스 세계관에서 단순한 설정 파일이 아니다. 그것은 우리의 의도를 분산 시스템이라는 거대한 기계가 이해할 수 있는 언어로 번역한 **설계도**이며, 선언적 패러다임을 지탱하는 **주춧돌**이다.

이제 우리는 쿠버네티스의 심장이 어떻게 뛰고(제어 루프), 무엇을 통해 소통하며(API), 어떤 언어로 말하는지(YAML) 모두 이해했다. 이 강력한 도구들을 손에 쥐었으니, 이제 클러스터 안에 실질적인 첫 번째 건축물을 올릴 시간이다. 다음 장에서는 모든 워크로드의 가장 근본적인 건축 자재, 바로 컨테이너를 품은 원자 단위인 **파드(Pod)**의 세계로 들어가 본다.