# 06장: 상태를 기억하는 애플리케이션 아키텍처

우리는 지금까지 '상태가 없는(stateless)' 애플리케이션을 중심으로, 어떻게 하면 이들을 우아하고 견고하게 운영할 수 있는지에 대한 여정을 걸어왔다. 디플로이먼트가 관리하는 파드들은 이름도, 순서도 없는 동일한 복제품들이다. 그들은 언제든지 사라졌다가 다른 모습으로 태어날 수 있으며, 우리는 그들의 죽음을 슬퍼할 필요가 없다. 왜냐하면 그들의 모든 '기억'은 클러스터 외부의 데이터베이스나 캐시와 같은 전문화된 시스템에 저장되어 있기 때문이다.

하지만 세상의 모든 애플리케이션이 이렇게 말끔하게 상태를 외부화할 수 있는 것은 아니다. 데이터베이스, 메시지 큐, 분산 파일 시스템과 같이 **데이터 그 자체를 책임지는 시스템들**은 어떠한가? 이 **'상태 저장(stateful)'** 애플리케이션들은 stateless 애플리케이션과는 전혀 다른, 훨씬 더 까다로운 규칙을 따른다. 각 멤버는 고유한 신원(identity)을 가져야 하고, 자신이 사용하던 데이터를 잃어버리지 않아야 하며, 때로는 시작하고 종료하는 순서까지도 엄격하게 지켜야 한다.

오랫동안 쿠버네티스 커뮤니티에서는 "데이터베이스를 쿠버네티스 위에서 운영해야 하는가?"라는 격렬한 논쟁이 있었다. 초기에는 '절대 안 된다'는 의견이 지배적이었다. 예측 불가능한 파드의 생명주기와 복잡한 스토리지 관리는 상태 저장 애플리케이션에게는 악몽과도 같았기 때문이다.

하지만 시대는 변했다. 이 장에서는 쿠버네티스가 이 어려운 도전을 어떻게 정복해나가고 있는지를 깊이 있게 탐구할 것이다. 우리는 디플로이먼트의 한계를 명확히 인지하고, 상태 저장 워크로드를 위해 특별히 설계된 컨트롤러인 **스테이트풀셋(StatefulSet)**의 고유한 특징을 파헤칠 것이다. 그리고 쿠버네티스가 물리적 스토리지를 어떻게 추상화하여 파드에게 안정적으로 제공하는지, PV, PVC, StorageClass의 관계를 명확히 이해하게 될 것이다. 마지막으로, 데이터베이스를 쿠버네티스에서 운영한다는 것의 현실적인 의미와 트레이드오프를 냉철하게 분석하고, **Velero**를 활용한 실전 재해 복구 아키텍처를 통해 당신의 소중한 데이터를 지키는 최후의 보루를 세울 것이다.

---

## 00. 스테이트풀셋(StatefulSet): 왜 디플로이먼트와 다르게 동작하는가

상태 저장 애플리케이션, 예를 들어 3개의 노드로 구성된 데이터베이스 클러스터를 디플로이먼트로 배포했다고 상상해보자. 어떤 재앙이 펼쳐질까?

* **불안정한 네트워크 신원:** 디플로이먼트는 파드에게 `my-db-<random-hash>` 와 같은 무작위 이름을 부여한다. 파드가 재시작되면 완전히 새로운 이름과 새로운 IP 주소를 받는다. 데이터베이스 클러스터의 멤버들은 서로를 고정된 이름으로 찾아야 하는데, 이처럼 신원이 계속 바뀌는 환경에서는 클러스터링 구성 자체가 불가능하다.
* **불안정한 스토리지:** 디플로이먼트의 모든 파드는 잠재적으로 동일한 스토리지 볼륨을 공유하도록 설정될 수 있지만, 이는 여러 프로세스가 하나의 파일에 동시에 쓰려는 경쟁 상태(race condition)를 유발할 뿐이다. 각 파드는 자신만의 고유한 데이터 저장소가 필요하며, 파드가 재시작되더라도 이전에 사용하던 바로 그 저장소에 다시 연결되어야 한다. 디플로이먼트는 이러한 보장을 제공하지 않는다.
* **무질서한 스케일링:** 디플로이먼트로 `replicas`를 3에서 5로 늘리면, 두 개의 새로운 파드가 동시에, 무작위 순서로 생성된다. 데이터베이스 클러스터에 새로운 멤버를 추가할 때는 종종 기존 멤버로부터 데이터를 동기화하는 절차가 필요한데, 이처럼 무질서한 확장은 클러스터의 상태를 깨뜨릴 수 있다.

이 모든 문제를 해결하기 위해 탄생한 것이 바로 **스테이트풀셋(StatefulSet)** 컨트롤러다. 스테이트풀셋은 디플로이먼트와는 근본적으로 다른, 상태 저장 시스템을 위한 세 가지 핵심적인 약속을 제공한다.

1.  **안정적이고 고유한 네트워크 신원 (Stable, Unique Network Identity):** 스테이트풀셋이 관리하는 파드는 예측 가능한 고유한 이름을 순서대로 부여받는다. 스테이트풀셋의 이름이 `db`이고 `replicas`가 3이라면, 파드들은 `db-0`, `db-1`, `db-2`라는 고정된 이름을 갖는다. 이 이름은 파드가 재시작되어도 절대 변하지 않는다. 또한, 각 파드는 `<pod-name>.<service-name>` 형태의 안정적인 DNS 이름을 가지므로, 서로를 항상 동일한 주소로 찾을 수 있다.
2.  **안정적이고 영속적인 스토리지 (Stable, Persistent Storage):** 스테이트풀셋의 각 파드는 자신만의 고유한 **영속 볼륨 클레임(PersistentVolumeClaim, PVC)**에 연결된다. `db-0`은 `data-db-0`이라는 PVC를, `db-1`은 `data-db-1`이라는 PVC를 사용하는 식이다. 만약 `db-1` 파드가 실행되던 노드가 다운되어 다른 노드에서 재시작되더라도, 스테이트풀셋은 이 파드가 이전에 사용하던 바로 그 `data-db-1` PVC에 다시 연결되는 것을 보장한다. 데이터는 파드의 생명주기를 초월하여 보존된다.
3.  **정돈되고 우아한 배포 및 스케일링 (Ordered, Graceful Deployment and Scaling):** 스테이트풀셋은 모든 작업을 정해진 순서대로, 한 번에 하나씩 수행한다.
    * **배포:** `replicas: 3`으로 생성하면, `db-0`이 생성되어 완전히 준비(Ready) 상태가 된 것을 확인한 후에야 비로소 `db-1`을 생성한다. `db-1`이 준비되면 그제야 `db-2`를 만든다.
    * **스케일 다운:** `replicas`를 3에서 1로 줄이면, 가장 높은 순번인 `db-2`를 먼저 종료시키고, 작업이 완료되면 `db-1`을 종료시킨다. 이는 데이터 손실 없이 클러스터 멤버를 안전하게 축소할 수 있게 해준다.
    * **업데이트:** 롤링 업데이트 시에도 역순(`db-2`부터)으로 하나씩, 이전 파드가 완전히 종료되고 새 파드가 준비된 것을 확인하며 순차적으로 진행한다.

[그림: StatefulSet이 Pod, PVC, 네트워크 ID를 안정적으로 매핑하는 구조]

이러한 엄격한 보장 덕분에, 스테이트풀셋은 ZooKeeper, etcd, Kafka, Cassandra와 같이 멤버 간의 관계와 순서, 데이터의 영속성이 지극히 중요한 분산 시스템을 쿠버네티스 위에서 안정적으로 운영할 수 있는 기반을 제공한다.

하지만 스테이트풀셋이 마법처럼 스토리지를 만들어내는 것은 아니다. 이 '안정적인 스토리지'라는 약속의 이면에는 쿠버네티스의 정교한 스토리지 추상화 계층이 존재한다. 다음 절에서는 이 계층을 구성하는 PV, PVC, 그리고 StorageClass의 관계를 파헤쳐 볼 것이다.