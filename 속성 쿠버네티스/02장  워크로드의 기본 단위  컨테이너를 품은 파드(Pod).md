# 02장: 워크로드의 기본 단위: 컨테이너를 품은 파드(Pod)

우리는 1장에서 쿠버네티스의 심장부, 즉 선언적 API와 제어 루프라는 거대한 엔진이 어떻게 작동하는지 깊이 있게 탐험했다. 이제 우리는 그 엔진 위에 올릴 첫 번째이자 가장 중요한 승객, 바로 우리의 애플리케이션을 실어 나를 **워크로드(Workload)**에 대해 이야기할 시간이다.

쿠버네티스 세계에서 모든 애플리케이션은 **파드(Pod)**라는 기본 단위 안에 담겨 배포되고 관리된다. 당신이 앞으로 다루게 될 디플로이먼트, 스테이트풀셋, 데몬셋 등 모든 상위 레벨의 워크로드 컨트롤러들은 결국 이 파드를 어떻게, 몇 개나, 어떤 방식으로 운영할 것인가를 정의하는 정교한 규칙의 집합에 지나지 않는다.

따라서 파드를 제대로 이해하지 못하면 쿠버네_티스 위에 견고한 아키텍처를 세울 수 없다. 이 장에서는 왜 쿠버네티스가 컨테이너를 직접 다루지 않고 파드라는 한 단계 추상화된 개념을 도입했는지 그 설계 사상을 파헤칠 것이다. 그리고 이 파드라는 원자 단위를 다루는 보이지 않는 손, 즉 컨트롤러의 역할과 애플리케이션의 생명주기를 관리하는 핵심 오브젝트인 디플로이먼트와 서비스를 차례로 분석하며 클라우드 네이티브 워크로드를 향한 첫걸음을 내디딜 것이다.

## 00. 파드: 컨테이너를 넘어 쿠버네티스의 원자 단위가 된 이유

쿠버네티스를 처음 접하는 이들이 가장 먼저 품는 의문은 이것이다. "어차피 컨테이너를 실행하는 시스템인데, 왜 굳이 '파드'라는 복잡한 개념을 하나 더 만들었을까? 그냥 도커 컨테이너를 직접 실행하면 안 되는가?" 이 질문에 대한 답을 찾는 것이야말로 쿠버네티스 아키텍처의 탁월함을 이해하는 첫 관문이다.

결론부터 말하자면, 파드는 단순히 컨테이너를 감싸는 껍데기가 아니다. 파드는 쿠버네티스에서 **배포, 스케줄링, 그리고 자원 할당의 최소 단위, 즉 원자 단위(atomic unit)**다. 컨테이너가 단일 '프로세스'의 격리에 가깝다면, 파드는 밀접하게 결합된 프로세스들의 집합을 담는 하나의 **'논리적인 머신(Logical Host)'**에 해당한다.

하나의 파드 안에 포함된 컨테이너들은 몇 가지 매우 중요한 자원을 **공유**한다.

* **네트워크:** 파드 안의 모든 컨테이너는 동일한 네트워크 네임스페이스를 공유한다. 이는 곧 모든 컨테이너가 동일한 IP 주소와 포트 공간을 가진다는 의미다. 컨테이너 A는 `localhost`를 통해 컨테이너 B의 포트로 직접 통신할 수 있다. 마치 하나의 가상 머신 안에서 여러 프로세스가 `localhost`로 통신하는 것과 완벽하게 동일하다.
* **스토리지:** 파드 안의 컨테이너들은 **볼륨(Volume)**이라고 하는 스토리지 공간을 공유하도록 설정할 수 있다. 컨테이너 A가 볼륨에 파일을 쓰면, 컨테이너 B가 즉시 그 파일을 읽을 수 있다.

바로 이 '공유'의 개념이 파드의 존재 이유다. 이 공유 모델을 통해 우리는 매우 강력하고도 일반적인 패턴인 **사이드카 패턴(Sidecar Pattern)**을 구현할 수 있다. 사이드카 패턴이란, 핵심적인 비즈니스 로직을 담은 주 애플리케이션 컨테이너의 기능을, 그 옆에 붙어 보조적인 역할을 수행하는 별도의 컨테이너를 통해 확장하고 강화하는 설계 방식이다.

몇 가지 실질적인 예를 들어보자.

* **로깅 에이전트:** 당신의 애플리케이션 컨테이너는 오직 표준 출력(stdout)이나 특정 파일(`app.log`)에 로그를 남기는 책임만 진다. 그러면 같은 파드 안에 있는 '사이드카' 로깅 에이전트 컨테이너(Fluentd, Vector 등)가 공유된 볼륨의 로그 파일을 읽거나 로그 스트림을 받아, 중앙 로깅 시스템(Elasticsearch, Loki)으로 전송하는 복잡한 역할을 대신 처리한다. 주 애플리케이션은 로깅 시스템의 존재 자체를 알 필요가 없다.
* **서비스 메시 프록시:** 주 애플리케이션 컨테이너는 `http://order-service/` 와 같이 평범하게 다른 서비스와 통신한다. 그러면 같은 파드 안에 있는 '사이드카' 프록시 컨테이너(Envoy, Linkerd-proxy 등)가 공유된 네트워크를 통해 모든 들어오고 나가는 트래픽을 가로챈다. 그리고 서비스 디스커버리, mTLS를 통한 상호 암호화, 재시도(retry), 서킷 브레이킹과 같은 모든 복잡한 네트워크 제어를 투명하게 처리해준다.
* **인증 프록시:** 레거시 애플리케이션이 OIDC나 OAuth 2.0 같은 현대적인 인증 방식을 지원하지 않는다고 가정해보자. 우리는 애플리케이션 코드 수정 없이, 파드 앞에 인증을 처리하는 '사이드카' 프록시를 두어 모든 요청을 먼저 검증하고, 검증된 요청만을 `localhost`를 통해 주 애플리케이션으로 전달하게 할 수 있다.

[그림: 애플리케이션 컨테이너와 사이드카 컨테이너(로깅 에이전트, 서비스 메시 프록시)가 하나의 파드 안에서 네트워크와 스토리지를 공유하는 모습]

이 모든 예시에서 핵심은 **관심사의 분리**다. 주 애플리케이션은 자신의 핵심 비즈니스 로직에만 집중할 수 있게 되고, 횡단 관심사(cross-cutting concerns)에 해당하는 부가적인 기능들은 재사용 가능한 표준화된 사이드카 컨테이너로 분리되어 독립적으로 개발되고 관리된다.

이것이 쿠버네티스가 컨테이너가 아닌 파드를 원자 단위로 삼은 이유다. 파드는 하나의 컨테이너만 담을 수도 있지만, 본질적으로는 **함께 생성되고, 함께 스케줄링되며, 함께 생명주기를 공유해야 하는** 강하게 결합된 컨테이너들의 묶음을 표현하기 위해 설계된 것이다. 파드 내의 컨테이너들은 하나의 단위로 취급되어 항상 같은 노드 위에서 실행되는 것이 보장된다.

파드는 불필요한 추상화가 아니다. 그것은 복잡한 마이크로서비스 아키텍처를 더 단순하고, 재사용 가능하며, 확장 가능한 컴포넌트들로 구성할 수 있게 해주는 지극히 의도된 설계 결정이다. 이제 이 원자 단위가 어떻게 보이지 않는 손에 의해 관리되는지, 컨트롤러의 세계로 들어가 보자.