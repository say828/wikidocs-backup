## 01. Cluster API를 활용한 쿠버네티스 클러스터 프로비저닝 자동화

멀티 클러스터라는 새로운 대륙으로의 이주를 결심한 순간, 우리는 첫 번째 거대한 장벽과 마주한다. "이 수많은 클러스터를 어떻게 일관되고, 반복 가능하며, 자동화된 방식으로 건설할 것인가?" 과거의 방식—`kops`, `kubeadm` 스크립트, 혹은 클라우드 제공업체의 웹 콘솔을 수없이 클릭하는 것—은 우리가 지금까지 쌓아 올린 선언적 GitOps 제국의 철학과 정면으로 위배된다. 그것은 여전히 인간의 손에 의존하는, 오류가 발생하기 쉬운 명령형의 세계에 속해있다.

우리는 근본적인 질문을 던져야 한다. "만약 `Deployment`가 `Pod`의 생명주기를 관리하듯, 클러스터의 생명주기를 관리하는 쿠버네티스 리소스가 있다면 어떨까?" 즉, **파드를 찍어내듯 클러스터를 찍어낼 수는 없을까?**

이 대담한 질문에 대한 해답이 바로 **Cluster API (CAPI)**다. Cluster API는 쿠버네티스 커뮤니티(SIG Cluster Lifecycle)가 주도하는 프로젝트로, 클러스터의 프로비저닝, 업그레이드, 그리고 운영을 자동화하기 위한 선언적인 API와 컨트롤러의 집합이다. CAPI의 핵심 철학은 **쿠버네티스를 사용하여 쿠버네티스를 관리하는 것(managing Kubernetes with Kubernetes)**이다.

이것은 다음과 같은 두 가지 핵심 개념을 통해 작동한다.

1.  **관리 클러스터 (Management Cluster):** 클러스터를 건설하는 '공장'이다. 이 클러스터에는 Cluster API 컨트롤러들이 설치되어 있다. 우리는 이 관리 클러스터의 API 서버에 우리가 만들고 싶은 새로운 클러스터의 '설계도'를 제출한다.

2.  **워크로드 클러스터 (Workload Cluster):** 관리 클러스터에 의해 생성되고 관리되는, 실제 애플리케이션이 배포될 '제품' 클러스터다.

이 공장이 제품을 만들기 위해 사용하는 설계도는 바로 Cluster API가 제공하는 새로운 CRD들이다.

* **`Cluster`:** 만들려는 클러스터의 네트워크 설정(Pod CIDR, Service CIDR)과 같은 클러스터 전역의 설정을 정의한다.
* **`Machine`:** 워크로드 클러스터의 단일 노드(VM)를 나타낸다.
* **`MachineDeployment` / `MachineSet`:** `Deployment`가 `Pod`를 관리하듯, `MachineDeployment`는 워크로드 클러스터의 노드 그룹(`Machine`의 집합)을 관리한다. 이를 통해 노드의 롤링 업데이트와 같은 정교한 작업이 가능해진다.

하지만 이 설계도들은 AWS EC2나 GCP GCE와 같은 실제 인프라를 어떻게 만들어내는지에 대한 구체적인 내용은 담고 있지 않다. 바로 이 지점에서 CAPI의 아키텍처적 우아함이 드러난다. CAPI는 **인프라 프로바이더(Infrastructure Provider)**라는 플러그인 모델을 통해, 클러스터의 논리적 정의와 물리적 구현을 완벽하게 분리한다. `cluster-api-provider-aws` (CAPA)는 `AWSMachine`이라는 CRD를 `EC2 Instance`로 번역하는 방법을 알고 있고, `cluster-api-provider-gcp` (CAPG)는 `GCPMachine`을 `GCE VM`으로 번역하는 방법을 알고 있다.

플랫폼 팀의 작업 흐름은 이제 다음과 같이 변한다.
1.  관리 클러스터에 접속한다.
2.  워크로드 클러스터의 전체 명세를 담은 단 하나의 YAML 파일을 작성한다. 이 파일 안에는 `Cluster`, `AWSCluster`, `MachineDeployment`, `AWSMachineTemplate` 등의 리소스가 모두 선언되어 있다.
3.  `kubectl apply -f my-cluster.yaml` 명령을 관리 클러스터에 실행한다.

이 순간, 관리 클러스터의 CAPI 컨트롤러들이 깨어나, 마치 오퍼레이터처럼 이 '의도'를 현실로 만들기 시작한다. AWS 프로바이더는 VPC를 만들고, 서브넷을 설정하며, EC2 인스턴스들을 띄우고, 그 위에 쿠버네티스를 설치하여 완벽하게 작동하는 새로운 워크로드 클러스터를 조립해낸다.

[그림: 관리 클러스터가 Cluster API를 통해 워크로드 클러스터를 생성하는 아키텍처]

Cluster API는 클러스터 생성을 더 이상 며칠이 걸리는 수작업이 아닌, GitOps 파이프라인에 통합할 수 있는 예측 가능하고 자동화된 프로세스로 바꾸어 놓는다. 우리는 이제 애플리케이션뿐만 아니라, 그 애플리케이션이 살아갈 집(클러스터) 자체마저도 코드로 관리할 수 있게 된 것이다.

이제 우리는 원하는 만큼의 클러스터를 전 세계 어디에든 찍어낼 수 있는 강력한 '클러스터 공장'을 손에 넣었다. 다음으로는 이 흩어진 공화국들 위에 어떻게 애플리케이션을 일관되게 배포하고, 이들 사이의 네트워크를 어떻게 연결할 것인지에 대한 멀티 클러스터 시대의 새로운 도전 과제들을 탐구해 볼 것이다.