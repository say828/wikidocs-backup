# 08장: 쿠버네티스 네트워킹 아키텍처 심층 분석

우리는 GitOps를 통해 플랫폼 전체를 선언적으로 관리하는 자동화된 제국을 건설했다. 하지만 이 제국 안의 도시 국가들, 즉 우리의 마이크로서비스들은 아직 서로 어떻게 대화하고 외부 세계와 어떻게 교역하는지에 대한 근본적인 법칙을 배우지 못했다. 애플리케이션이 파드라는 고립된 성 안에 갇혀있다면 아무런 가치를 창출할 수 없다. 결국 모든 가치는 '연결'을 통해 만들어진다.

쿠버네티스 네트워킹은 종종 입문자들이 가장 마지막에 마주하는, 그리고 가장 깊은 심연처럼 느끼는 영역이다. 파드는 어떻게 IP 주소를 가지게 되는가? 서비스는 어떻게 로드 밸런싱을 수행하는가? 클러스터 외부의 트래픽은 어떤 경로를 거쳐 우리의 파드에 도달하는가? 이 질문들에 대한 답은 표면 아래에 숨겨진 복잡한 계층과 수많은 선택지로 가득하다.

이 장에서는 바로 이 어둡고 깊은 바닷속으로 잠수하여, 쿠버네티스 네트워킹의 모든 비밀을 해부할 것이다. 우리는 파드에 IP 주소를 부여하는 첫 번째 관문인 **CNI(Container Network Interface)**의 역할과 원리부터 시작하여, 오늘날 가장 치열한 기술 전쟁터인 **Calico, Cilium, Flannel**의 장단점을 명확히 비교 분석하여 당신의 플랫폼에 맞는 최적의 CNI를 선택할 수 있는 통찰력을 제공할 것이다. 그리고 서비스 디스커버리의 마법을 가능하게 하는 쿠버네티스 DNS의 동작 원리를 파헤치고, 마지막으로 '기본적으로 아무도 믿지 않는다'는 **제로 트러스트(Zero Trust)** 철학을 향한 첫걸음인 **네트워크 정책(Network Policy)**을 통해 우리 제국의 국경을 굳건히 세울 것이다.

---

## 00. 파드는 어떻게 IP 주소를 갖게 되는가: CNI의 역할과 원리

당신이 `kubectl run` 명령으로 파드를 생성하면, 몇 초 안에 그 파드는 `10.244.0.5`와 같은 고유한 IP 주소를 부여받고 클러스터 내의 다른 파드와 통신을 시작한다. 이 과정은 너무나 당연하게 일어나기에, 우리는 이것이 어떻게 가능한지에 대해 깊이 생각하지 않는다. 하지만 이 IP 주소는 쿠버네티스 스케줄러나 API 서버가 부여하는 것이 아니다. 이 마법의 배후에는 바로 **CNI(Container Network Interface)**라는 이름의 조용한 실무자가 있다.

CNI는 쿠버네티스가 네트워킹이라는 극도로 복잡하고 다변적인 영역에 대해 직접적인 책임을 지는 대신, 그 책임을 외부의 전문화된 **플러그인(Plugin)**에게 위임하기 위해 만들어진 **표준 명세(Specification)**다. 쿠버네티스의 핵심 철학인 '플러그인 아키텍처'가 가장 빛을 발하는 부분이 바로 여기다. 쿠버네티스는 "나는 네트워킹에 대해 아는 바가 없다. 다만, 파드가 생성되고 삭제될 때마다 내가 이 표준화된 방식으로 너희 플러그인을 호출해줄 테니, IP 주소를 할당하고 네트워크 인터페이스를 설정하는 모든 실제 작업은 너희가 알아서 처리하라"고 말한다.

이 위임 과정은 각 노드에서 실행되는 Kubelet을 통해 이루어진다.

1.  **파드 스케줄링:** 사용자가 파드를 생성하면, 스케줄러는 해당 파드를 특정 노드(예: `node-1`)에 할당한다.
2.  **Kubelet의 인지:** `node-1`의 Kubelet은 자신에게 새로운 파드가 할당된 것을 API 서버를 통해 인지한다.
3.  **컨테이너 런타임 호출:** Kubelet은 컨테이너 런타임(예: containerd)에게 컨테이너를 생성하고, 가장 먼저 격리된 네트워크 네임스페이스(network namespace)를 만들도록 지시한다. 이 순간, 파드는 아직 IP가 없는 자신만의 고립된 네트워크 공간을 갖게 된다.
4.  **CNI 플러그인 호출:** 이제 가장 중요한 단계다. Kubelet은 설정된 CNI 플러그인(예: `/opt/cni/bin/calico`)을 호출한다. 이때 컨테이너의 네트워크 네임스페이스 경로, 컨테이너 ID와 같은 정보를 인자로 전달한다.
5.  **플러그인의 마법:** CNI 플러그인은 Kubelet으로부터 받은 정보를 바탕으로 실제 네트워킹 작업을 수행한다.
    * IP 주소 관리(IPAM) 플러그인을 호출하여 파드에 할당할 IP 주소를 받아온다.
    * 가상 이더넷(veth) 페어를 생성하여 한쪽 끝은 호스트(노드)의 루트 네트워크 네임스페이스에, 다른 한쪽 끝은 컨테이너의 네트워크 네임스페이스 안에 위치시킨다.
    * 컨테이너의 네트워크 네임스페이스 안쪽 인터페이스에 할당받은 IP 주소와 기본 게이트웨이를 설정한다.
    * 호스트의 라우팅 테이블을 업데이트하여, 이 새로운 파드로 향하는 트래픽이 올바르게 전달되도록 설정한다.

[그림: Kubelet이 CNI 플러그인을 호출하여 파드의 네트워크를 설정하는 과정]

Kubelet은 이 과정의 복잡한 세부사항에 대해 전혀 알지 못한다. 그저 CNI 명세에 따라 플러그인을 호출하고, 성공/실패 결과만을 돌려받을 뿐이다.

이 CNI라는 표준화된 인터페이스 덕분에, 우리는 AWS의 네이티브 네트워킹을 사용하는 `aws-vpc-cni`부터, BGP를 이용해 라우팅하는 Calico, 그리고 eBPF라는 커널의 마법을 사용하는 Cilium에 이르기까지, 각기 다른 철학과 기술을 가진 수많은 CNI 구현체 중에서 우리의 요구사항에 가장 적합한 것을 자유롭게 선택하여 클러스터에 설치할 수 있게 된다.

이제, 오늘날 가장 뜨거운 논쟁의 중심에 있는 대표적인 CNI 플러그인들을 비교 분석하며, 우리 플랫폼의 혈관을 책임질 기술을 선택하는 여정을 떠나보자.