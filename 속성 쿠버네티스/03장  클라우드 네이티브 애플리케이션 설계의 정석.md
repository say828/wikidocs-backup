# 03장: 클라우드 네이티브 애플리케이션 설계의 정석

지금까지 우리는 쿠버네티스라는 강력한 오케스트레이션 플랫폼이 제공하는 도구들, 즉 파드, 디플로이먼트, 서비스를 이용해 애플리케이션을 안정적으로 배포하고 외부 세계와 연결하는 방법을 익혔다. 마치 튼튼한 집을 짓기 위한 최상급의 공구와 설계도를 손에 넣은 것과 같다. 하지만 아무리 훌륭한 공구가 있어도, 집 안에 들어갈 가구나 전자제품이 엉망이라면 그 집은 결코 안락한 공간이 될 수 없다.

마찬가지로, 쿠버네티스라는 견고한 플랫폼 위에 제대로 설계되지 않은 애플리케이션을 올리는 것은 값비싼 스포츠카에 저품질 연료를 넣는 것과 같다. 제 성능을 내기는커녕, 오히려 플랫폼 전체의 안정성을 해치는 애물단지로 전락할 수 있다. 쿠버네티스는 죽은 컨테이너를 다시 살려줄 수는 있지만, 애초에 계속 죽도록 만들어진 애플리케이션을 근본적으로 치유해줄 수는 없다.

이 장에서는 우리의 시선을 플랫폼에서 그 안에 담길 **애플리케이션 그 자체**로 옮긴다. 우리는 클라우드 네이티브 철학의 고전이라 할 수 있는 **12-Factor App(12요소 앱)** 원칙이 쿠버네티스라는 새로운 환경 속에서 어떻게 재해석되고 진화하는지를 살펴볼 것이다. 그리고 작고 안전하며 효율적인 컨테이너 이미지를 만드는 기술, 쿠버네티스가 애플리케이션의 건강 상태를 정확히 진단하게 만드는 프로브(Probe) 설계법, 마지막으로 클러스터라는 한정된 자원을 현명하게 나눠 쓰기 위한 약속인 자원 요청(Requests)과 제한(Limits)에 이르기까지, 당신의 애플리케이션을 진정한 '클라우드 네이티브 시민'으로 거듭나게 할 핵심적인 설계 원칙들을 깊이 있게 탐구할 것이다.

---

## 00. 12-Factor App 원칙은 쿠버네티스에서 어떻게 진화하는가

'12-Factor App'은 클라우드 환경의 등장 초기에 Heroku의 엔지니어들이 제시한, 서비스형 소프트웨어(SaaS)를 만들기 위한 12가지 방법론의 집합이다. 이것은 특정 언어나 기술에 종속되지 않는, 시대를 초월하는 원칙에 가깝다. 쿠버네티스는 이 12가지 원칙을 강제하지는 않지만, 이 원칙을 따르는 애플리케이션을 운영할 때 그 진정한 힘을 120% 발휘하도록 설계되었다. 오히려 쿠버네티스는 몇몇 원칙들을 너무나 당연하게 만들어 버렸고, 몇몇은 한 단계 더 높은 수준으로 발전시켰다.

과거의 이정표가 오늘날의 우리에게 어떤 의미를 갖는지, 핵심적인 몇 가지를 중심으로 되짚어보자.

**I. 코드베이스 (Codebase): 버전 관리되는 하나의 코드베이스와 다양한 배포**
이 원칙은 너무나 당연하게 들리지만, Git으로 대표되는 버전 관리 시스템에 모든 코드를 두고, 동일한 코드베이스에서 개발, 스테이징, 프로덕션 등 다양한 환경으로 배포해야 함을 의미한다. 쿠버네티스는 여기서 한 걸음 더 나아간다. 이제 우리는 애플리케이션 코드뿐만 아니라, 그 애플리케이션을 둘러싼 모든 인프라 구성(디플로이먼트 YAML, 서비스 명세 등)까지도 Git에서 관리하는 **IaC(Infrastructure as Code)**, 그리고 **GitOps**의 시대를 열었다.

**III. 설정 (Config): 환경(environment)에 저장되는 설정**
12-Factor는 소스 코드와 설정을 엄격하게 분리하고, 환경 변수를 통해 설정을 주입하라고 말한다. 쿠버네티스는 이 원칙을 **ConfigMap**과 **Secret**이라는 일급 시민(first-class citizen) 오브젝트로 완벽하게 구현했다. 우리는 더 이상 서버에 직접 접속해 환경 변수 파일을 수정할 필요가 없다. 그저 ConfigMap을 변경하고 디플로이먼트를 재시작하면, 쿠버네티스가 알아서 새로운 설정을 컨테이너의 환경 변수나 볼륨 파일로 주입해준다.

**V. 빌드, 릴리즈, 실행 (Build, release, run): 엄격하게 분리된 세 단계**
이 원칙은 소스 코드 저장소에서 실제 프로덕션 프로세스가 실행되기까지의 과정을 명확히 구분하라고 요구한다.
* **빌드 단계:** 소스 코드를 가져와 실행 가능한 아티팩트(artifact)로 변환한다. (쿠버네티스 세계에서는 **컨테이너 이미지**를 빌드하는 과정이다.)
* **릴리즈 단계:** 빌드된 아티팩트에 특정 환경의 설정을 결합한다. (컨테이너 이미지에 ConfigMap/Secret을 결합하여 배포 가능한 버전, 즉 **Helm 차트**나 **Kustomize 오버레이**를 만드는 것에 해당한다.)
* **실행 단계:** 릴리즈를 실제 실행 환경에서 구동시킨다. (클러스터에 디플로이먼트를 적용하여 **파드**를 실행하는 단계다.)

쿠버네티스는 이 분리 원칙을 CI/CD 파이프라인과 결합하여 완벽하게 자동화할 수 있는 이상적인 환경을 제공한다.

**VI. 프로세스 (Processes): 애플리케이션을 하나 이상의 무상태(stateless) 프로세스로 실행**
이것이 바로 쿠버네티스가 가장 사랑하는 애플리케이션의 형태다. 12-Factor는 프로세스가 어떤 상태도 내부에 저장하지 말고, 필요한 모든 상태는 데이터베이스나 캐시와 같은 외부의 **상태 저장 백엔드 서비스(stateful backing service)**에 위임하라고 강조한다. 이렇게 설계된 애플리케이션은 언제든지 죽여도 문제가 없으며, 수평적으로 무한히 확장(scale-out)할 수 있다. 이는 디플로이먼트 컨트롤러가 파드를 자유롭게 복제하고, 노드 장애 시 다른 곳에서 되살릴 수 있는 능력의 근간이 된다.

**IX. 폐기 가능성 (Disposability): 빠른 시작과 그레이스풀 셧다운(graceful shutdown)으로 견고성 극대화**
프로세스는 언제든지 즉시 시작하거나 중지될 수 있어야 한다. 이는 파드가 일회용품이라는 쿠버네티스의 철학과 정확히 일치한다. 애플리케이션은 시작 시간을 최소화하여 스케일 아웃에 빠르게 반응해야 하며, 종료 신호(SIGTERM)를 받았을 때는 진행 중이던 작업을 안전하게 마무리하고 연결을 끊는 **그레이스풀 셧다운** 로직을 반드시 구현해야 한다. 이것이 구현되지 않은 애플리케이션은 롤링 업데이트 시 데이터 유실이나 요청 실패를 유발하는 주범이 된다.

[도표: 12-Factor 원칙과 쿠버네티스 구현 방식의 매핑]
| 12-Factor 원칙 | 쿠버네티스에서의 구현 |
| :--- | :--- |
| III. 설정 (Config) | ConfigMap, Secret |
| VI. 프로세스 (Processes) | Stateless 파드, Deployment |
| VII. 포트 바인딩 | Service 오브젝트 |
| VIII. 동시성 (Concurrency)| `replicas`를 통한 수평 확장 (HPA) |
| IX. 폐기 가능성 | 빠른 컨테이너 시작, Graceful Shutdown, Liveness Probe |

이처럼 12-Factor App 원칙은 쿠버네티스 시대를 위한 예언서와도 같았다. 이 원칙들을 충실히 따르는 것만으로도, 당신의 애플리케이션은 쿠버네티스라는 오케스트라와 아름답게 협연할 준비를 마치게 된다. 이제 이 원칙을 바탕으로, 애플리케이션의 첫 번째 아티팩트인 컨테이너 이미지를 어떻게 명품으로 만들어낼 것인지 살펴보자.