## 03. 분산 추적(Distributed Tracing)으로 마이크로서비스 병목점 찾기 (Jaeger/OpenTelemetry)

메트릭이 우리에게 '무엇'이 잘못되었는지 알려주고, 로그가 '왜' 잘못되었는지에 대한 단서를 준다면, **분산 추적(Distributed Tracing)**은 그 문제가 '어디에서' 발생하고 있는지를 정확히 짚어주는 내비게이션이자 MRI 영상이다. 모놀리식 아키텍처에서는 하나의 요청이 단일 프로세스 안에서 순차적으로 처리되므로, 프로파일링 도구를 사용하면 어떤 함수가 시간을 많이 소요하는지 쉽게 찾아낼 수 있었다. 하지만 마이크로서비스의 세계에서는, 사용자의 단 한 번의 클릭이 클러스터 내부에 보이지 않는 연쇄 반응을 일으킨다. `frontend` 서비스는 `auth-service`를 호출하여 사용자를 인증하고, `product-service`에서 상품 정보를 가져오며, `recommendation-service`로부터 추천 상품 목록을 받아온다. 이 중 단 하나라도 느려지면, 전체 사용자 경험은 급격히 저하된다.

이 복잡하게 얽힌 서비스들의 호출 사슬 속에서, "주문 완료 페이지가 왜 3초나 걸리는가?"라는 질문에 답하기란 불가능에 가깝다. 이것이 바로 분산 추적이 해결하고자 하는 문제다. 분산 추적은 단일 요청의 전체 생명주기를, 그것이 시스템의 경계를 넘나드는 모든 과정을 추적하고 시각화하는 기술이다.

### Trace와 Span: 요청의 여정을 기록하는 방법

분산 추적의 세계는 두 가지 핵심적인 개념으로 이루어져 있다.

* **트레이스 (Trace):** 사용자의 요청이 시작되어 끝날 때까지의 전체 여정. 이것은 고유한 `Trace ID`를 가진다.
* **스팬 (Span):** 그 여정 속에서 이루어지는 각각의 논리적인 작업 단위. `frontend`가 HTTP 요청을 보내는 것, `product-service`가 데이터베이스 쿼리를 날리는 것 등이 모두 하나의 스팬이 된다. 각 스팬은 고유한 `Span ID`와 함께, 자신이 속한 전체 여정을 나타내는 `Trace ID`를 공유한다. 스팬들은 부모-자식 관계를 통해 트리 구조를 형성한다.

이것이 가능하려면, 서비스들은 요청을 주고받을 때마다 이 **'추적 컨텍스트(Trace Context)'**(`Trace ID`, `Parent Span ID` 등)를 함께 전달해야 한다. 가장 일반적인 방법은 `traceparent`와 같은 표준화된 HTTP 헤더를 통해 이 정보를 전파하는 것이다.

1.  사용자의 첫 요청이 Ingress Controller에 도달하면, 새로운 `Trace ID`가 생성된다.
2.  Ingress Controller가 `frontend` 서비스를 호출할 때, 이 `Trace ID`를 HTTP 헤더에 담아 보낸다.
3.  `frontend`는 이 헤더를 읽고, 자신이 처리하는 작업에 대한 스팬을 생성한 뒤, `product-service`를 호출할 때 다시 이 `Trace ID`와 자신의 `Span ID`(부모로서)를 헤더에 담아 전송한다.
4.  이 과정이 요청의 전체 여정이 끝날 때까지 반복된다.

### OpenTelemetry와 Jaeger: 계측과 시각화의 표준

이 모든 추적 컨텍스트를 수동으로 코드에 심는 것은 끔찍한 일이다. 이 **계측(Instrumentation)** 과정을 표준화하고 자동화하기 위해 탄생한 CNCF의 거대 프로젝트가 바로 **OpenTelemetry (OTel)**다. OpenTelemetry는 각 프로그래밍 언어별로 라이브러리(SDK)와 자동 계측 에이전트를 제공하여, 개발자가 최소한의 코드 변경만으로 (혹은 전혀 없이) 자신의 애플리케이션이 자동으로 스팬을 생성하고 전파하도록 만들 수 있게 해준다.

이렇게 생성된 스팬 데이터는 **OTel Collector**라는 중앙 수집기를 통해 수집, 처리된 후, 최종적으로 **분산 추적 백엔드**로 전송된다. 이 백엔드는 스팬들을 수집하여 `Trace ID`를 기준으로 재조립하고, 저장하며, 시각화하는 역할을 담당한다. 이 영역의 가장 대표적인 오픈소스 강자가 바로 **Jaeger**와 **Zipkin**이다.



Jaeger의 UI에서 우리는 다음과 같은 놀라운 통찰을 얻을 수 있다.
* 하나의 요청이 어떤 서비스들을, 어떤 순서로 거쳐갔는지에 대한 전체 그림 (Service Map).
* 각 스팬이 얼마나 많은 시간을 소요했는지를 보여주는 타임라인 그래프 (Gantt Chart). 이를 통해 전체 요청 시간 중 90%가 `database-query` 스팬에서 소요되었음을 즉시 발견할 수 있다.
* 각 스팬에 첨부된 상세한 메타데이터(태그)와 로그. (예: 어떤 SQL 쿼리가 실행되었는가?)

이로써 우리는 마이크로서비스의 보이지 않는 내부 동작을 손에 잡힐 듯 들여다볼 수 있는 궁극의 현미경을 손에 넣었다.

---

메트릭, 로그, 그리고 트레이스. 옵저버빌리티의 이 세 기둥은 이제 우리 플랫폼의 모든 것을 보고, 듣고, 추적할 수 있는 강력한 감각 기관이 되었다. 우리는 더 이상 시스템의 어둠 속에서 추측과 감에 의존하여 헤맬 필요가 없다. 데이터가 우리를 진실로 인도할 것이다.

하지만 우리의 플랫폼이 아무리 완벽하게 관측 가능하고 안정적이라 하더라도, 플랫폼 그 자체를 확장해야 하는 순간은 반드시 찾아온다. 만약 우리가 직접 쿠버네티스 API를 확장하여, 우리 회사만의 `Database`나 `MLPipeline`과 같은 새로운 리소스를 만들어 관리하고 싶다면 어떻게 해야 할까? 다음 장에서는 쿠버네티스 확장의 정수이자, 플랫폼 엔지니어의 진정한 힘을 보여주는 **오퍼레이터 패턴**의 세계로 떠나볼 것이다.