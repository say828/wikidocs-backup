## 01\. 블루/그린 배포 아키텍처: 가장 안전하게 신버전을 배포하는 방법

롤링 업데이트의 불확실성에 대한 가장 확실한 해답은 바로 **블루/그린 배포(Blue/Green Deployment)** 전략이다. 이 전략의 핵심 철학은 지극히 단순하고 명확하다. **"절대로 날고 있는 비행기의 엔진을 교체하지 마라. 대신, 완벽하게 준비된 새 비행기로 승객을 옮겨 태워라."**

블루/그린 배포는 이름 그대로, 현재 운영 환경인 \*\*블루(Blue)\*\*와 완벽하게 동일하지만 아직 외부 트래픽을 받지 않는 대기 환경인 **그린(Green)**, 이렇게 두 개의 독립적인 프로덕션 환경을 동시에 유지하는 방식이다.

배포 과정은 다음과 같이 명확한 단계를 거친다.

1.  **그린 환경에 신버전 배포:** 현재 모든 실시간 트래픽은 블루 환경으로 향하고 있다. 우리는 이와는 완전히 격리된 그린 환경에 새로운 버전의 애플리케이션을 배포한다.
2.  **그린 환경 검증:** 그린 환경은 아직 외부에 노출되지 않았으므로, 우리는 이곳에서 어떠한 위험 부담도 없이 완벽한 테스트를 수행할 수 있다. 내부망을 통해 API를 호출해보고, 자동화된 E2E(End-to-End) 테스트를 실행하며 신버전이 정말로 준비되었는지 확신을 얻는다.
3.  **트래픽 전환 (The Switch):** 모든 검증이 끝나면, 가장 극적인 순간이 온다. 우리는 로드 밸런서 혹은 라우터의 설정을 단 한 번 변경하여, 이전까지 블루 환경으로 향하던 모든 트래픽을 **일제히, 그리고 즉시** 그린 환경으로 전환시킨다. 마치 철로의 선로 변환기를 돌리는 것과 같다.
4.  **블루 환경 대기 및 폐기:** 트래픽 전환 후, 기존의 블루 환경은 이제 대기 상태가 된다. 만약 그린 환경에서 예기치 못한 문제가 발생하면, 우리는 즉시 선로 변환기를 다시 돌려 트래픽을 안정적인 블루 환경으로 되돌릴 수 있다. 이것이 바로 **즉각적인 롤백**이다. 일정 시간 동안 그린 환경이 안정적으로 동작하는 것이 확인되면, 블루 환경은 다음 배포를 위해 대기하거나 자원 절약을 위해 폐기될 수 있다.

이것을 쿠버네티스 세계에서는 어떻게 구현할까? 핵심은 \*\*서비스(Service)의 셀렉터(Selector)\*\*를 교묘하게 조작하는 것이다. 서비스는 파드들의 집합으로 향하는 안정적인 출입구, 즉 '선로 변환기'의 역할을 완벽하게 수행할 수 있다.

  * **1단계: 초기 상태**
    `my-app-svc`라는 서비스가 `version: blue` 레이블을 가진 파드들을 가리키고 있다. 모든 사용자는 이 서비스를 통해 블루 디플로이먼트에 접근한다.

    ```yaml
    # my-app-svc
    apiVersion: v1
    kind: Service
    metadata:
      name: my-app-svc
    spec:
      selector:
        app: my-app
        version: blue # <-- 현재 Blue를 가리킴
      ports:
      - port: 80
        targetPort: 8080
    ```

    이때 우리는 `version: green` 레이블을 가진, 새로운 버전의 그린 디플로이먼트를 클러스터에 배포해둔다. 하지만 아직 서비스가 이 파드들을 가리키지 않으므로, 아무런 트래픽도 받지 않는다.

  * **2단계: 트래픽 전환**
    이제, 우리는 서비스의 YAML 파일에서 단 한 줄, `selector`의 `version` 값을 `green`으로 변경하여 `kubectl apply`를 실행한다.

    ```yaml
    # my-app-svc (updated)
    apiVersion: v1
    kind: Service
    metadata:
      name: my-app-svc
    spec:
      selector:
        app: my-app
        version: green # <-- 이제 Green을 가리킴!
    ...
    ```

    쿠버네티스의 제어 플레인은 이 변경을 감지하고, 서비스가 가리키는 엔드포인트 목록을 블루 파드의 IP들에서 그린 파드의 IP들로 **원자적(atomic)으로** 교체한다. 이 순간, 100%의 트래픽이 중단 없이 새로운 버전으로 흐르기 시작한다. 롤링 업데이트처럼 구버전과 신버전이 뒤섞이는 혼란스러운 과도기 상태는 존재하지 않는다.

[그림: 블루/그린 배포에서 서비스 셀렉터가 트래픽을 전환하는 아키텍처]

블루/그린 배포는 롤링 업데이트의 거의 모든 단점을 해결한다.

  * **버전 충돌 원천 봉쇄:** 구버전과 신버전이 동시에 트래픽을 처리하는 시간이 없으므로 API나 스키마 변경 문제에서 자유롭다.
  * **즉각적이고 무손실 롤백:** 문제가 생기면 그저 서비스의 셀렉터를 다시 `blue`로 되돌리기만 하면 된다. 사용자 입장에서는 아무 일도 없었던 것처럼 이전 버전으로 돌아간다.

하지만 이 완벽해 보이는 안전함에도 비용은 따른다. 가장 큰 단점은 **자원 비용**이다. 배포가 진행되는 동안 우리는 두 벌의 프로덕션 환경을 유지해야 하므로, 거의 두 배에 달하는 컴퓨팅 자원이 필요하다. 이는 비용에 민감한 환경에서는 상당한 부담이 될 수 있다.

블루/그린 배포가 'All or Nothing', 즉 100%의 트래픽을 한 번에 전환하는 대담한 전략이라면, 이와는 반대로 지극히 조심스럽고 점진적으로 위험을 관리하는 또 다른 철학이 있다. 바로 일부 사용자에게만 먼저 신버전을 공개하여 그 반응을 살피는 카나리 배포 전략이다. 다음 절에서는 이 현명한 광부의 새에 대해 알아볼 것이다.