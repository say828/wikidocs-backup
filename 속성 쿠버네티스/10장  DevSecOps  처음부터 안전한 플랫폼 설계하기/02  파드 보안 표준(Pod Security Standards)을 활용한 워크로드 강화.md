## 02\. 파드 보안 표준(Pod Security Standards)을 활용한 워크로드 강화

우리는 RBAC를 통해 '누가(who)' '무엇을(what)' 할 수 있는지를 완벽하게 통제했다. 하지만 여기에는 교묘한 맹점이 존재한다. RBAC는 요청자가 '디플로이먼트를 생성할 권한'이 있는지는 검사하지만, 그 디플로이먼트가 담고 있는 **파드의 '내용'이 얼마나 위험한지는 검사하지 않는다.** 권한을 가진 개발자가 실수로, 혹은 악의적으로 다음과 같은 '괴물' 파드를 클러스터에 배포하려 한다면 어떻게 될까?

  * `hostPath`를 사용하여 노드의 루트 파일 시스템(`/`)을 마운트하는 파드.
  * `privileged: true` 플래그를 달고 컨테이너의 모든 격리를 해제하는 파드.
  * `hostNetwork: true`로 노드의 네트워크 스택을 그대로 사용하는 파드.

이러한 파드 하나가 클러스터에 배포되는 순간, 당신이 공들여 쌓아 올린 모든 RBAC 방어벽은 무용지물이 된다. 공격자는 이 파드를 발판 삼아 손쉽게 컨테이너를 탈출(Container Escape)하고, 노드 전체의 루트 권한을 장악하며, 클러스터 전체를 파괴할 수 있는 발판을 마련하게 된다.

이처럼 위험한 워크로드가 애초에 클러스터에 발을 들이지 못하도록 막는, 어드미션 컨트롤 단계에서 작동하는 강력한 내장 방어 체계가 바로 \*\*파드 보안 표준(Pod Security Standards, PSS)\*\*이다. 과거의 복잡했던 PodSecurityPolicy(PSP)를 대체하여 훨씬 더 직관적이고 표준화된 방식으로 도입된 PSS는, 파드가 준수해야 할 보안 수준을 세 가지 프로파일로 정의한다.

1.  **`privileged` (특권):** 사실상 아무런 제한이 없는, 가장 느슨한 정책이다. 이름 그대로, 노드의 자원을 마음껏 사용하는 특권 컨테이너를 실행해야 하는 극히 예외적인 시스템 레벨의 워크로드(예: 일부 CNI 플러그인)를 위해 존재한다. **일반 애플리케이션에 이 정책을 적용하는 것은 보안을 포기하겠다는 선언과 같다.**

2.  **`baseline` (기준):** 알려진 권한 상승(privilege escalation) 공격 벡터들을 차단하는, 합리적이고 기본적인 보안 수준을 제공한다. `privileged` 컨테이너, `hostPath` 볼륨, `hostNetwork` 등 명백히 위험한 설정들을 금지한다. 대부분의 일반적인 애플리케이션이 최소한으로 만족해야 할 **상식적인 기준선**이다.

3.  **`restricted` (제한):** 현재 커뮤니티에서 권장하는 가장 강력한 파드 강화(hardening) 모범 사례를 따르는, 가장 안전한 정책이다. `baseline`의 모든 제한을 포함하며, 추가적으로 다음과 같은 엄격한 규칙을 강제한다.

      * 컨테이너는 반드시 non-root 유저로 실행되어야 한다 (`runAsNonRoot: true`).
      * `allowPrivilegeEscalation: false`를 설정하여 자식 프로세스가 더 높은 권한을 획득하는 것을 금지해야 한다.
      * `seccompProfile`을 설정하여 커널에 대한 시스템 콜(syscall)을 제한해야 한다.
      * `capabilities`에서 `ALL`을 `drop`하고, 꼭 필요한 최소한의 능력만 허용해야 한다.

-----

### 네임스페이스 레이블을 통한 정책 강제

PSS의 가장 아름다운 점은 그 적용 방식이 놀랍도록 간단하고 쿠버네티스답다는 것이다. 이 모든 정책은 **네임스페이스(Namespace)에 특정 레이블(Label)을 붙이는 것**만으로 활성화된다. 플랫폼 관리자는 네임스페이스를 생성할 때, 그 공간의 '보안 법률'을 레이블로 선포하는 것이다.

```yaml
apiVersion: v1
kind: Namespace
metadata:
  name: critical-app-ns
  labels:
    # --- PSS Magic Starts Here ---
    # 1. ENFORCE: 이 네임스페이스에는 'restricted' 정책을 강제한다.
    #    위반하는 파드는 생성 자체가 거부된다.
    pod-security.kubernetes.io/enforce: restricted
    pod-security.kubernetes.io/enforce-version: latest

    # 2. AUDIT: 만약 'baseline' 정책이라도 위반하면, 허용은 하되
    #    그 사실을 감사 로그(audit log)에 기록한다.
    pod-security.kubernetes.io/audit: baseline

    # 3. WARN: 만약 'privileged' 정책을 위반하는 (아주 위험한) 파드를
    #    생성하려고 하면, 생성은 허용하되 사용자에게 즉시 경고(warning)를 보여준다.
    pod-security.kubernetes.io/warn: privileged
```

이 레이블들이 붙은 `critical-app-ns` 네임스페이스에서, 이제 개발자는 `restricted` 정책을 만족하는 안전한 파드만을 배포할 수 있다. 만약 `runAsUser: 0` (root)을 포함한 파드를 배포하려고 시도하면, 쿠버네티스의 내장 Pod Security 어드미션 컨트롤러가 이를 즉시 감지하고 API 요청 자체를 거부해버린다.

이것이 바로 진정한 **'Shift Left' 보안**이다. 보안은 더 이상 배포가 끝난 후에 스캔을 돌리는 사후 작업이 아니다. 개발자가 `kubectl apply`를 누르는 바로 그 순간, 플랫폼이 스스로의 법률에 따라 안전하지 않은 코드는 애초에 영토 안에 들어오는 것조차 막아버리는, 능동적이고 예방적인 방어 체계가 완성된 것이다.

이제 우리는 사용자의 권한(RBAC)과 워크로드의 내용(PSS)을 모두 통제할 수 있게 되었다. 하지만 아직 하나의 거대한 미지의 영역이 남아있다. 우리가 실행하려는 그 **컨테이너 이미지** 자체는 과연 안전한가? 그 안에는 알려진 보안 취약점을 가진 오래된 라이브러리가 숨어있지는 않을까? 다음 절에서는 이 소프트웨어 공급망의 심장부를 겨누는 위협에 맞서기 위한 이미지 스캐닝과 정책 엔진의 세계로 나아간다.