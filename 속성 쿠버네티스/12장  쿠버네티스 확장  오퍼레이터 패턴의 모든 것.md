# 12장: 쿠버네티스 확장: 오퍼레이터 패턴의 모든 것

우리는 이제 쿠버네티스라는 강력한 운영체제 위에서 애플리케이션을 배포하고, 관리하며, 관찰하는 거의 모든 기술을 마스터했다. GitOps를 통해 플랫폼 전체를 선언적으로 관리하고, 옵저버빌리티 스택을 통해 그 내부를 손금 보듯 들여다볼 수 있게 되었다. 하지만 지금까지 우리가 다룬 모든 것은, 쿠버네티스가 **이미 알고 있는** 리소스들—`Deployment`, `StatefulSet`, `Service`—을 다루는 방법이었다. 우리는 쿠버네티스가 제공하는 기존의 API라는 문법 안에서만 이야기해왔다.

하지만 만약 우리가 이 문법 자체를 확장할 수 있다면 어떨까? 만약 쿠버네티스가 `PostgreSQLDatabase`나 `RedisCacheCluster`, 심지어는 `MachineLearningPipeline`과 같은, 우리 회사만의 고유한 개념을 이해하고, 그것의 생명주기를 스스로 관리하게 만들 수 있다면? 이것은 단순히 플랫폼을 사용하는 것을 넘어, **플랫폼 자체를 창조**하는 영역으로 들어서는 것을 의미한다. 🤖

이 장에서는 쿠버네티스의 진정한 힘이자, 플랫폼 엔지니어링의 정점에 있는 \*\*확장성(Extensibility)\*\*의 세계로 들어간다. 우리는 왜 쿠버네티스 API를 확장해야만 하는지에 대한 근본적인 이유부터 시작하여, 이 확장의 핵심 도구인 \*\*CRD(Custom Resource Definition)\*\*와 \*\*커스텀 컨트롤러(Custom Controller)\*\*의 관계를 파헤칠 것이다. 그리고 이 둘을 결합하여 인간 운영자의 지식을 코드로 캡슐화한 자동화의 정수, \*\*오퍼레이터 패턴(Operator Pattern)\*\*을 깊이 있게 이해하게 될 것이다. 나아가, **Kubebuilder**를 이용해 우리만의 오퍼레이터를 개발하는 과정을 살펴보고, 마지막으로 이 패턴의 궁극적인 활용 사례인 **Crossplane**을 통해 AWS RDS나 GCP Cloud SQL과 같은 외부 클라우드 리소스마저 쿠버네티스 API의 일부로 만들어버리는, 플랫폼 엔지니어의 최종 병기를 손에 넣게 될 것이다.

-----

## 00\. 왜 우리는 쿠버네티스 API를 확장해야 하는가: CRD와 컨트롤러

6장에서 우리는 스테이트풀셋을 이용해 데이터베이스를 운영하는 것의 어려움, 특히 백업, 복구, 업그레이드와 같은 복잡한 'Day-2 운영'에 대해 이야기했다. `StatefulSet`은 우리에게 안정적인 신원과 스토리지를 제공해주지만, `PostgreSQL`의 Primary 노드가 다운되었을 때 Standby 노드로 Failover를 수행하는 방법을 알지는 못한다. 그 지식은 PostgreSQL을 운영해 본 인간 전문가의 머릿속에만 존재한다.

우리가 원하는 것은 이 전문가의 지식을 자동화하는 것이다. 우리는 "PostgreSQL 클러스터의 복제본은 3개여야 하고, 버전은 15.3이며, 백업은 매일 새벽 2시에 S3 버킷으로 수행되어야 한다"와 같은, \*\*애플리케이션에 특화된 고수준의 '의도'\*\*를 선언하고 싶다. 그리고 쿠버네티스가 이 의도를 현실로 만들고 유지하기 위해 필요한 모든 저수준 작업(StatefulSet 생성, ConfigMap 설정, 백업 CronJob 실행 등)을 스스로 처리해주기를 바란다.

하지만 쿠버네티스는 `PostgreSQLDatabase`라는 단어를 모른다. 이 단어를 가르쳐주는 행위가 바로 \*\*CRD(Custom Resource Definition)\*\*를 만드는 것이다. CRD는 우리가 쿠버네티스 API에 새로운 종류의 오브젝트, 즉 우리만의 API를 등록할 수 있게 해주는 강력한 메커니즘이다.

```yaml
apiVersion: apiextensions.k8s.io/v1
kind: CustomResourceDefinition
metadata:
  name: postgresqldatabases.my-company.com # 새로운 리소스의 이름
spec:
  group: my-company.com # API 그룹
  versions:
    - name: v1alpha1
      served: true
      storage: true
      schema: # 이 리소스가 가질 수 있는 필드(spec)의 구조 정의
        openAPIV3Schema:
          type: object
          properties:
            spec:
              type: object
              properties:
                version:
                  type: string
                replicas:
                  type: integer
                backupSchedule:
                  type: string
  scope: Namespaced # 네임스페이스에 속하는 리소스
  names:
    plural: postgresqldatabases
    singular: postgresqldatabase
    kind: PostgreSQLDatabase
    shortNames:
    - pgdb
```

이 CRD를 클러스터에 적용하는 순간, 쿠버네티스 API 서버는 이제 `PostgreSQLDatabase`라는 새로운 종류의 리소스를 이해하고, 저장하며, 클라이언트에게 제공할 준비를 마친다. 이제 우리는 다음과 같은 YAML을 클러스터에 자신 있게 제출할 수 있다.

```yaml
apiVersion: my-company.com/v1alpha1
kind: PostgreSQLDatabase
metadata:
  name: my-production-db
spec:
  version: "15.3"
  replicas: 3
  backupSchedule: "0 2 * * *"
```

하지만 이것만으로는 아무 일도 일어나지 않는다. 우리는 API 서버에게 새로운 '명사'(`PostgreSQLDatabase`)를 가르쳤지만, 그 명사가 무슨 '의미'를 가지며 어떤 '동사'로 처리되어야 하는지는 아직 가르치지 않았다. API 서버는 그저 이 YAML을 etcd에 저장해둘 뿐이다.

이 새로운 리소스에 생명을 불어넣는 것이 바로 \*\*커스텀 컨트롤러(Custom Controller)\*\*다. 커스텀 컨트롤러는 우리가 직접 작성하여 클러스터에 배포하는, 특정 CRD를 위해 일하는 전문화된 제어 루프다. 이 컨트롤러의 임무는 지극히 명확하다.

1.  쿠버네티스 API 서버를 감시하며 `PostgreSQLDatabase` 리소스의 생성/수정/삭제 이벤트를 지켜본다.
2.  `my-production-db`라는 새로운 리소스가 생성된 것을 발견하면, 그 `spec`을 읽는다.
3.  `spec`에 선언된 '이상적인 상태'(`replicas: 3`, `version: "15.3"`)와 '현재 상태'(아무것도 없음)의 차이를 인지한다.
4.  이 차이를 메우기 위해, 쿠버네티스의 기본 리소스들—`StatefulSet`, `Service`, `Secret`, `CronJob` 등—을 적절하게 조합하여 생성하고 관리하는 일련의 로직을 실행한다.

CRD가 우리만의 '선언서'라면, 커스텀 컨트롤러는 그 선언서의 내용을 현실로 만드는 '엔진'이다. 이 둘의 강력한 조합, 이것이 바로 자동화의 다음 시대를 여는 오퍼레이터 패턴의 본질이다.