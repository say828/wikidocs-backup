## 03\. 네트워크 정책(Network Policy): 제로 트러스트를 향한 첫걸음

우리는 이제 모든 파드가 서로를 이름만으로 찾아 대화할 수 있는, 매우 효율적이고 유연한 통신망을 구축했다. 하지만 이 통신망은 현재 '완전한 신뢰'라는, 너무나 순진하고 위험한 가정 위에 서 있다. 쿠버네티스의 기본 네트워킹 모델은 \*\*'기본적으로 허용(Default Allow)'\*\*이다. 아무런 규칙도 설정하지 않으면, `default` 네임스페이스의 파드는 `kube-system` 네임스페이스의 파드와 통신할 수 있고, 프론트엔드 파드는 백엔드를 거치지 않고 데이터베이스 파드에 직접 접속을 시도할 수도 있다.

이것은 마치 성벽 없는 도시와 같다. 모든 시민이 자유롭게 돌아다닐 수 있지만, 그 자유는 동시에 모든 적에게도 열려있는 문이 된다. 만약 프론트엔드 파드가 공격자에게 침해당한다면, 공격자는 그 파드를 교두보 삼아 클러스터 내부의 다른 모든 서비스로 자유롭게 측면 이동(Lateral Movement)을 시도하며 피해를 확산시킬 것이다.

\*\*제로 트러스트(Zero Trust)\*\*라는 현대 보안의 핵심 원칙은 이 순진한 가정을 정면으로 부정한다. "내부 네트워크는 안전하다"는 낡은 믿음을 버리고, \*\*"기본적으로 아무도, 아무것도 믿지 마라(Never Trust, Always Verify)"\*\*고 선언한다. 모든 통신은 그것이 명시적으로 허가되지 않는 한, 원천적으로 차단되어야 한다. 이것이 바로 \*\*'최소 권한의 원칙(Principle of Least Privilege)'\*\*이다.

쿠버네티스에서 이 제로 트러스트 철학을 구현하는 첫 번째 방화벽이 바로 **네트워크 정책(Network Policy)** 리소스다. 네트워크 정책은 L3/L4 수준에서 파드 간의 트래픽 흐름을 통제하는 규칙의 집합이다. 마치 클라우드의 보안 그룹(Security Group)이나 방화벽 규칙처럼, 어떤 파드가 어떤 다른 파드와 어떤 포트를 통해 통신할 수 있는지를 선언적으로 정의할 수 있다.

네트워크 정책의 마법 역시 \*\*레이블(Label)\*\*과 \*\*셀렉터(Selector)\*\*를 통해 이루어진다.

1.  **정책의 대상 선택 (`podSelector`):** 먼저, 이 정책을 어떤 파드들에게 적용할 것인지를 `podSelector`를 통해 선택한다. 예를 들어, `role: database` 레이블을 가진 모든 파드를 이 정책의 적용 대상으로 삼을 수 있다.
2.  **규칙 정의 (`ingress`, `egress`):** 그 다음, 이 파드들에게 허용할 트래픽 규칙을 정의한다.
      * **`ingress` (인바운드):** 어떤 종류의 트래픽이 이 파드들'에게' 들어오는 것을 허용할 것인가?
      * **`egress` (아웃바운드):** 이 파드들이 어떤 목적지'로' 트래픽을 보내는 것을 허용할 것인가?
3.  **트래픽 소스/목적지 선택 (`from`, `to`):** 허용할 트래픽의 출발지(`from`)나 목적지(`to`) 역시 파드의 레이블(`podSelector`), 네임스페이스(`namespaceSelector`), 혹은 특정 IP 대역(`ipBlock`)으로 명시할 수 있다.

이것이 어떻게 동작하는지, 아주 흔한 시나리오를 통해 살펴보자. `role: database` 파드는 오직 `app: backend` 레이블을 가진 파드로부터의 `TCP 6379` 포트 트래픽만을 허용해야 한다.

```yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: db-allow-backend
  namespace: production
spec:
  podSelector: # 1. 이 정책은 'role: database' 파드에 적용된다.
    matchLabels:
      role: database
  policyTypes:
  - Ingress # 인바운드 트래픽에 대한 규칙이다.
  ingress:
  - from: # 2. 출발지(from)가...
    - podSelector:
        matchLabels:
          app: backend # ...'app: backend' 레이블을 가진 파드이면서,
    ports: # 3. 목적지 포트가...
    - protocol: TCP
      port: 6379 # ...TCP 6379인 트래픽만 허용한다.
```

이 정책이 `production` 네임스페이스에 적용되는 순간, 마법 같은 일이 벌어진다.

  * `app: backend` 파드가 `role: database` 파드의 6379 포트로 보내는 트래픽은 **허용**된다.
  * `app: frontend` 파드가 `role: database` 파드에 접속하려는 모든 시도는 **차단**된다.
  * 심지어 `app: backend` 파드라 할지라도 6379가 아닌 다른 포트로 접속하려는 시도는 **차단**된다.

**중요한 점:** 특정 파드에 네트워크 정책이 하나라도 적용되는 순간, 그 파드는 '기본적으로 허용' 모드에서 **'기본적으로 거부(Default Deny)'** 모드로 전환된다. 즉, 명시적으로 허용된 트래픽을 제외한 모든 인바운드(ingress) 및 아웃바운드(egress) 트래픽이 차단된다. 이것이 바로 우리가 원했던 제로 트러스트의 시작이다.

네트워크 정책은 CNI 플러그인에 의해 실제 방화벽 규칙(iptables, eBPF 등)으로 변환되어 커널 수준에서 강제된다. (주의: Flannel과 같은 일부 단순한 CNI는 네트워크 정책을 지원하지 않는다\!)

이제 우리의 도시에는 성벽이 세워졌고, 우리는 허가된 시민만이 정해진 문을 통해 드나들 수 있도록 통제할 수 있게 되었다. 이로써 우리는 클러스터 내부의 보안을 한 차원 높은 수준으로 끌어올렸다.

지금까지 우리는 클러스터 '내부'의 통신 법칙을 모두 정립했다. 하지만 우리의 애플리케이션은 결국 외부 세계의 사용자들과 만나야만 그 가치가 있다. 다음 장에서는 이 클러스터라는 제국과 외부 세계를 연결하는 거대한 관문, Ingress와 Gateway API의 세계로 여정을 떠날 것이다.