## 02. 쿠버네티스 DNS의 동작 원리와 서비스 디스커버리

우리는 CNI를 통해 클러스터의 모든 파드가 고유한 IP 주소를 갖는다는 사실을 확인했다. 그리고 2장에서 배운 서비스(Service)는 이 유령처럼 변하는 파드 IP들의 집합 앞에, `10.96.0.10`과 같은 안정적인 가상 IP(ClusterIP)를 제공해준다. 그렇다면 이제 `order-service`가 `user-service`와 통신하고 싶을 때, `user-service`의 ClusterIP를 어딘가에 설정 파일로 저장해두고 사용하면 되는 것일까?

물론 기술적으로는 가능하다. 하지만 그것은 여전히 반쪽짜리 해결책이다. 만약 `user-service`를 삭제했다가 다른 설정으로 다시 만들어야 한다면? ClusterIP는 바뀔 수 있다. 더 중요한 것은, IP 주소는 기계가 기억하기 위한 숫자일 뿐, 인간이 그 의미를 직관적으로 이해하고 관리하기 위한 이름이 아니다. 우리는 `10.101.35.112`가 아니라 `user-service`라는 이름으로 대화하고 싶다.

이것이 바로 **서비스 디스커버리(Service Discovery)**, 즉 "광활한 클러스터 네트워크 안에서 내가 원하는 서비스를 이름만으로 어떻게 찾아갈 수 있는가?"라는 근본적인 질문이다. 쿠버네티스는 이 질문에 대해 지난 수십 년간 인터넷을 지탱해 온 가장 확실하고 검증된 방식으로 답한다. 바로 **DNS(Domain Name System)**다.

쿠버네티스 클러스터는 그 자체로 하나의 작은 인터넷과 같다. 그리고 이 내부 인터넷을 위한 자체적인 DNS 서버를 가지고 있다. 오늘날 거의 모든 쿠버네티스 클러스터에서 이 역할을 수행하는 것이 바로 **CoreDNS**다. CoreDNS는 클러스터의 애드온(add-on)으로 배포되는 평범한 디플로이먼트일 뿐이지만, 그 역할은 막중하다.

CoreDNS의 작동 원리는 다음과 같다.

1.  **자동 등록:** 당신이 `user-service`라는 이름의 서비스를 `production` 네임스페이스에 생성하는 순간, 쿠버네티스 API 서버는 이 이벤트를 감지한다. CoreDNS 컨트롤러는 API 서버를 지속적으로 감시(watch)하다가, 새로운 서비스가 생성된 것을 보고 즉시 그에 맞는 DNS 레코드를 자신의 내부에 자동으로 생성한다.
2.  **체계적인 이름:** 이 DNS 레코드는 무작위로 만들어지지 않는다. 다음과 같은 매우 예측 가능하고 체계적인 규칙에 따라 생성된다.
    * **`user-service.production`**: 같은 네임스페이스(`production`) 내의 다른 파드는 이 짧은 이름만으로 `user-service`를 찾을 수 있다.
    * **`user-service.production.svc.cluster.local`**: 이것이 바로 서비스의 전체 주소(Fully Qualified Domain Name, FQDN)다. `.svc`는 이것이 서비스 리소스임을, `.cluster.local`은 이 클러스터 내부에서만 유효한 도메인임을 나타낸다. 다른 네임스페이스의 파드라도 이 전체 주소를 사용하면 언제든지 `user-service`를 찾을 수 있다.
3.  **자동 설정:** 그렇다면 파드는 어떻게 이 내부 DNS 서버(CoreDNS)를 사용해야 하는지 알 수 있을까? 파드가 생성될 때, Kubelet은 해당 파드의 `/etc/resolv.conf` 파일에 CoreDNS 서비스의 ClusterIP를 네임서버(nameserver)로 자동으로 주입한다. 또한, 검색 경로(search path)에 `production.svc.cluster.local`, `svc.cluster.local`, `cluster.local`과 같은 접미사를 추가해준다. 이 덕분에 당신이 코드에서 `http://user-service/`라고만 호출해도, 리눅스 시스템은 자동으로 검색 경로를 조합하여 최종적으로 `user-service.production.svc.cluster.local`이라는 전체 주소를 찾아내 질의할 수 있는 것이다.

[그림: 파드가 CoreDNS를 통해 다른 서비스의 IP를 찾는 과정]

결과적으로, 개발자는 더 이상 다른 서비스의 IP 주소를 전혀 신경 쓸 필요가 없어진다. 그저 코드에서는 설정 파일에 `USER_SERVICE_HOST=user-service`라고 정의해두고, `http://{USER_SERVICE_HOST}/`를 호출하기만 하면 된다. 서비스의 ClusterIP가 바뀌든, 그 서비스가 가리키는 파드들의 IP가 수십 번 바뀌든, 이 모든 복잡성은 DNS와 서비스라는 두 개의 강력한 추상화 계층 아래에 완벽하게 숨겨진다.

이것이 바로 쿠버네티스가 제공하는 위치 투명성(Location Transparency)의 본질이다. 마이크로서비스들은 그저 서로의 논리적인 이름만으로 대화할 뿐, 상대방이 클러스터의 어느 노드 위에 떠 있는지에 대해서는 전혀 알 필요도, 알 수도 없다.

이제 우리는 파드들이 서로를 이름만으로 자유롭게 찾아가 대화할 수 있는 완벽한 통신망을 구축했다. 하지만 이 자유에는 대가가 따른다. 지금 우리의 클러스터는 기본적으로 모든 파드가 다른 모든 파드와 자유롭게 통신할 수 있는, 완전히 개방된 평원과도 같다. `frontend` 파드가 `database` 파드에 직접 접속할 수도 있고, `logging` 파드가 `payment` 파드의 민감한 API를 호출할 수도 있다.

이러한 무질서한 자유는 보안의 악몽이다. 우리는 이제 이 평원 위에 국경과 방화벽을 세워, 오직 허가된 통신만이 오고 갈 수 있도록 통제해야 한다. 다음 절에서는 제로 트러스트를 향한 첫걸음, 네트워크 정책에 대해 알아볼 것이다.