# 04장: 'YAML 지옥' 탈출기: 선언적 구성 관리 마스터

우리는 지금까지 클라우드 네이티브 애플리케이션을 어떻게 설계하고, 컨테이너에 담아, 쿠버네티스의 기본 워크로드 오브젝트를 통해 안정적으로 실행하는지에 대한 견고한 기초를 다졌다. 당신은 이제 단일 애플리케이션을 배포하고 운영하는 데 필요한 거의 모든 지식을 갖추었다. 하지만 현실 세계의 플랫폼은 그렇게 단순하지 않다.

하나의 마이크로서비스는 곧 수십 개로 늘어날 것이고, 우리는 이 서비스들을 개발(development), 스테이징(staging), 그리고 프로덕션(production)이라는 여러 환경에 걸쳐 배포하고 관리해야 한다. 이때, 당신은 곧 끔찍한 현실과 마주하게 된다. 바로 \*\*'YAML 지옥(YAML Hell)'\*\*이다.

각 환경마다 미묘하게 다른 복제본 수, CPU/메모리 자원 설정, 도메인 이름, 데이터베이스 접속 정보 등을 관리하기 위해, 당신은 수많은 YAML 파일들을 복사하고 붙여넣기 시작할 것이다. 이 파일들은 시간이 지남에 따라 걷잡을 수 없이 늘어나고, 서로의 차이점을 추적하는 것은 불가능에 가까워진다. 프로덕션에 적용되어야 할 중요한 보안 설정이 개발 환경 YAML에는 누락되고, 스테이징에서만 사용해야 할 설정이 프로덕션으로 흘러 들어가는 끔찍한 실수가 발생하기 시작한다.

이 장에서는 바로 이 YAML 지옥에서 당신을 구원할 두 가지 핵심 무기, \*\*커스터마이즈(Kustomize)\*\*와 \*\*헬름(Helm)\*\*을 깊이 있게 다룰 것이다. 우리는 단순한 설정 값 주입을 넘어, 왜 ConfigMap만으로는 이 문제를 근본적으로 해결할 수 없는지를 먼저 이해할 것이다. 그리고 템플릿 없이 YAML 자체를 데이터처럼 다루는 커스터마이즈의 철학과, 애플리케이션을 하나의 패키지로 묶어 재사용성을 극대화하는 헬름의 강력함을 비교하며 어떤 상황에 무엇을 선택해야 하는지에 대한 명확한 기준을 세울 것이다. 마지막으로, GitOps 시대의 가장 민감한 주제인 시크릿(Secret) 정보를 어떻게 안전하게 선언적으로 관리할 수 있는지에 대한 실전 아키텍처를 탐구하며 이 지옥에 마침표를 찍을 것이다.

-----

## 00\. 환경별 설정의 문제: 왜 ConfigMap만으로는 부족한가

12-Factor App 원칙에 따라 우리는 코드와 설정을 분리해야 함을 배웠고, 쿠버네티스는 이를 위해 **ConfigMap**과 **Secret**이라는 훌륭한 도구를 제공한다. 환경별로 다른 데이터베이스 URL이나 외부 API 키를 ConfigMap에 담아두고, 디플로이먼트에서는 이 ConfigMap을 참조하여 환경 변수로 주입하는 것은 매우 기본적인 패턴이다.

예를 들어, 개발 환경에서는 `db-url-dev` ConfigMap을, 프로덕션 환경에서는 `db-url-prod` ConfigMap을 사용하도록 디플리이먼트 YAML을 각각 만들 수 있다.

**`deployment-dev.yaml`**

```yaml
...
        env:
        - name: DATABASE_URL
          valueFrom:
            configMapKeyRef:
              name: db-url-dev # 개발용 ConfigMap
              key: url
...
```

**`deployment-prod.yaml`**

```yaml
...
        env:
        - name: DATABASE_URL
          valueFrom:
            configMapKeyRef:
              name: db-url-prod # 운영용 ConfigMap
              key: url
...
```

이 방식은 처음에는 잘 동작하는 것처럼 보인다. 하지만 여기서 진짜 문제는 `DATABASE_URL`이 아니다. 진짜 문제는 `deployment-dev.yaml`과 `deployment-prod.yaml` 파일의 **나머지 95% 내용이 거의 동일하다**는 점이다.

환경이 늘어나고 관리해야 할 마이크로서비스가 증가함에 따라, 이 방식의 근본적인 한계가 드러나기 시작한다.

  * **엄청난 중복:** 프로덕션 환경의 `replicas`를 3개로, `memory limits`를 4Gi로 설정하고 싶다고 가정해보자. 당신은 `deployment-prod.yaml` 파일을 직접 수정해야 한다. 만약 모든 환경에 공통적으로 적용해야 할 `livenessProbe` 설정을 변경해야 한다면? 당신은 `deployment-dev.yaml`, `deployment-staging.yaml`, `deployment-prod.yaml` 파일을 모두 찾아 일일이 수정해야 한다. 이는 실수를 유발하는 가장 확실한 방법이다.
  * **'차이'에 대한 관리 부재:** 두 환경의 설정 파일 사이에 정확히 어떤 차이가 있는지 한눈에 파악하기가 극도로 어렵다. "프로덕션에는 적용되었지만 스테이징에는 빠진 보안 관련 어노테이션이 있는가?" 와 같은 질문에 답하기 위해, 당신은 두 개의 거대한 YAML 파일을 나란히 띄워놓고 눈으로 비교하는 원시적인 방법을 사용해야 할 것이다.
  * **재사용 불가능:** 당신의 팀이 만든 멋진 모니터링 대시보드 설정이나 로깅 사이드카 구성을 다른 팀도 사용하고 싶다면 어떻게 해야 할까? 관련 YAML 파일들을 통째로 복사해서 전달해주는 수밖에 없다. 그리고 그 순간, 원본의 개선 사항은 더 이상 복사본에 반영되지 않는 '설정의 파편화'가 시작된다.

ConfigMap은 애플리케이션이 \*\*런타임에 읽어들일 '값(value)'\*\*을 외부화하는 데는 훌륭하지만, 애플리케이션의 \*\*배포 구조 자체(Deployment, Service 등)의 '차이'\*\*를 관리하는 데는 역부족이다. 우리가 정말로 필요한 것은, 여러 환경에 걸쳐 공통되는 부분은 한곳에서 관리하고(Don't Repeat Yourself, DRY), 각 환경의 고유한 차이점만을 '덧씌우는(overlay)' 방식의 정교한 구성 관리 도구다.

바로 이 문제를 해결하기 위해, 우리는 이제 YAML을 프로그래밍 방식으로 다루는 첫 번째 기술, 커스터마이즈를 만나볼 시간이다.