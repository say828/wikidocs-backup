## 01. 컨테이너를 넘어 오케스트레이션이 필요한 이유

마이크로서비스가 낳은 분산 시스템의 혼돈을 해결할 첫 번째 구원투수로 등장한 것이 바로 **컨테이너(Container)**, 특히 도커(Docker)였다. 컨테이너 기술은 혁명적이었다. "제 컴퓨터에서는 잘 되는데요?" 라는 오랜 변명을 역사의 뒤안길로 사라지게 만들었다. 애플리케이션과 그 실행에 필요한 모든 라이브러리, 바이너리, 설정 파일을 하나의 불변(immutable) 이미지로 묶어버림으로써, 개발 환경, 테스트 환경, 프로덕션 환경 어디에서든 동일한 방식으로 동작하는 것을 보장했다.

이는 마이크로서비스 배포의 가장 큰 골칫거리였던 '환경의 비일관성' 문제를 단번에 해결했다. 더 이상 특정 서버에 어떤 버전의 라이브러리가 설치되어 있는지 걱정할 필요가 없어졌다. 우리는 그저 컨테이너 이미지를 전달하고 실행하기만 하면 되었다. 또한, 가상 머신(VM)과 달리 컨테이너는 호스트 운영체제의 커널을 공유하여 훨씬 가볍고 빠르게 시작되었다. 이는 서버 자원의 밀도를 극적으로 높여 비용 효율성을 개선하는 부수적인 효과까지 가져왔다.

컨테이너는 마이크로서비스라는 작은 서비스들을 담기에 더할 나위 없이 완벽한 그릇이었다. 각 서비스는 격리된 자신만의 컨테이너 안에서 안정적으로 실행될 수 있었다. 이제 우리는 수십, 수백 개의 서비스들을 표준화된 컨테이너 이미지로 만들어낼 수 있게 되었다.

하지만 이것으로 모든 문제가 해결되었을까? 천만에. 우리는 곧 새로운 현실과 마주하게 되었다. 이제 우리의 데이터센터는 수십, 수백, 아니 수천 개의 컨테이너들로 가득 차게 된 것이다. 이 컨테이너 군단을 어떻게 관리할 것인가?

* **배포와 스케줄링:** 수십 개의 서버 중 어떤 서버에 새로운 컨테이너를 배치해야 하는가? 해당 서버에 충분한 CPU와 메모리가 남아있는지는 어떻게 아는가?
* **서비스 디스커버리:** A 서비스 컨테이너가 B 서비스 컨테이너와 통신하려면 B의 IP 주소를 알아야 한다. 컨테이너는 언제든지 죽고 다시 살아나며 IP가 바뀌는데, 이 변화무쌍한 IP 주소는 어떻게 관리할 것인가?
* **상태 모니터링과 자가 치유:** 특정 컨테이너나 서버가 다운되었을 때, 이를 어떻게 감지하고 자동으로 다른 서버에 컨테이너를 다시 띄울 것인가?
* **확장과 축소:** 트래픽이 몰릴 때 특정 서비스의 컨테이너 수를 10개로 늘리고, 트래픽이 줄어들면 다시 3개로 줄이는 작업을 어떻게 자동화할 것인가?
* **네트워킹과 스토리지:** 여러 서버에 흩어져 있는 컨테이너들이 어떻게 하나의 가상 네트워크 안에서 안전하게 통신하게 만들며, 컨테이너가 사라져도 데이터는 영속적으로 보존되게 할 것인가?

이 모든 질문들은 하나의 결론으로 귀결된다. 바로 **'컨테이너를 관리하는 컨테이너'**, 즉 이 컨테이너 군단을 지휘할 지능적인 지휘관이 필요하다는 것이다. 개별 병사(컨테이너)가 아무리 뛰어나다 한들, 이들을 지휘하여 거대한 전투를 승리로 이끌 오케스트라의 지휘자, 즉 **컨테이너 오케스트레이션(Container Orchestration)** 엔진 없이는 분산 시스템이라는 전쟁에서 승리할 수 없다.

[도표: 컨테이너와 오케스트레이션의 역할 분담]
| 기술 | 해결하는 문제 | 비유 |
| :--- | :--- | :--- |
| **컨테이너 (Docker)** | 애플리케이션 실행 환경의 표준화 및 격리 | 규격화된 화물 컨테이너 |
| **오케스트레이션 (Kubernetes)** | 컨테이너의 생명주기, 네트워킹, 스토리지, 확장성 관리 | 컨테이너선, 항만, 크레인을 총괄하는 자동화된 항만 관제 시스템 |

초기에는 Docker Swarm, Mesos와 같은 여러 경쟁자들이 이 지휘관의 자리를 놓고 다투었다. 하지만 결국 승자는 구글이 자신들의 내부 시스템인 Borg와 Omega의 경험을 바탕으로 세상에 공개한 프로젝트, 쿠버네티스였다. 쿠버네티스가 승리한 이유는 단순히 기능이 더 많아서가 아니었다. 그것은 분산 시스템을 어떻게 다루어야 하는지에 대한 압도적인 철학적 깊이와 확장 가능한 아키텍처를 제시했기 때문이다.

이제 우리는 자연스럽게 다음 질문으로 넘어가게 된다. 그렇다면 이 모든 복잡성을 관리하고 개발자에게는 더 나은 경험을 제공하려는 움직임, 즉 플랫폼 엔지니어링이란 정확히 무엇이며, 왜 그것이 오늘날 모든 기업의 핵심 과제가 되었는가?