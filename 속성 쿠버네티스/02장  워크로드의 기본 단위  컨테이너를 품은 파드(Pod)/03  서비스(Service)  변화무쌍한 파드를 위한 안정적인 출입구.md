## 03\. 서비스(Service): 변화무쌍한 파드를 위한 안정적인 출입구

이제 우리는 디플로이먼트를 통해 자가 치유되고, 확장 가능하며, 안전하게 업데이트될 수 있는 파드들의 집합을 손에 넣었다. 하지만 이 파드들은 여전히 심각한 문제를 안고 있다. 바로 **유령과 같은 존재**라는 점이다. 파드는 언제든지 죽고 다시 살아날 수 있으며, 그때마다 클러스터 내부에서만 유효한 새로운 IP 주소를 부여받는다. `nginx-deployment`가 관리하는 파드 A의 IP가 `10.244.1.10`이었다가, 노드 장애로 파드 A가 죽고 파드 B가 새로 태어나면 그 IP는 `10.244.2.25`로 바뀌어 버린다.

이런 상황에서 클라이언트나 다른 마이크로서비스가 어떻게 NGINX 애플리케이션을 안정적으로 찾아갈 수 있겠는가? 변화무쌍한 파드들의 개별 IP 주소를 일일이 추적하는 것은 불가능하며, 설령 가능하다 해도 그것은 끔찍한 안티패턴(Anti-pattern)이다. 우리는 이 파드들의 집합 앞에, 절대로 변하지 않는 \*\*단일 진입점(Single, stable entrypoint)\*\*을 세워야만 한다.

이 역할을 수행하는 것이 바로 쿠버네티스의 **서비스(Service)** 오브젝트다. 서비스는 논리적으로 동일한 역할을 수행하는 파드들의 집합을 대표하는, 하나의 고유하고 안정적인 **추상화 계층**이다. 서비스의 본질은 간단하다. "이 파드들은 자주 죽고 IP도 계속 바뀌지만, 내가 그들 모두를 대표하는 영원불변의 주소를 제공하겠다."

서비스가 이 마법을 부리는 핵심적인 원리는 바로 \*\*레이블(Label)\*\*과 **셀렉터(Selector)** 메커니즘이다.

1.  먼저, 우리는 디플로이먼트를 통해 생성되는 파드들에게 `app: nginx`와 같은 식별표, 즉 **레이블**을 붙여두었다. 이것은 이 파드들이 'NGINX 앱 그룹'에 속해있음을 나타내는 표식이다.
2.  그리고 우리는 다음과 같은 서비스 명세를 작성한다.

<!-- end list -->

```yaml
apiVersion: v1
kind: Service
metadata:
  name: nginx-service
spec:
  selector:
    app: nginx # <-- "나는 'app: nginx' 레이블을 가진 모든 파드를 찾아내겠다."
  ports:
    - protocol: TCP
      port: 80 # <-- 이 서비스가 외부(다른 파드)에 노출할 포트
      targetPort: 80 # <-- 서비스가 트래픽을 전달할 대상 파드의 컨테이너 포트
```

3.  이 YAML을 클러스터에 제출하면, 쿠버네티스는 `nginx-service`라는 이름의 서비스를 생성하고, 이 서비스에 \*\*절대 변하지 않는 가상의 IP 주소(ClusterIP)\*\*를 할당한다.
4.  이제 `nginx-service`는 자신의 \*\*셀렉터(`selector: app: nginx`)\*\*와 일치하는 레이블을 가진 파드가 클러스터에 나타나거나 사라지는 것을 끊임없이 감시한다. 현재 `app: nginx` 레이블을 가진 파드가 3개 있다면, 서비스는 이 3개의 실제 파드 IP 주소(`10.244.1.10`, `10.244.2.25`, ...)를 자신의 엔드포인트(Endpoint) 목록으로 유지한다.
5.  이제 클러스터 내의 다른 파드가 `nginx-service`의 안정적인 IP 주소(혹은 더 편리하게는 `nginx-service`라는 DNS 이름)와 `port: 80`으로 트래픽을 보내면, 서비스는 이 요청을 받아 자신이 알고 있는 3개의 실제 파드 중 하나에게 지능적으로 분배(load balancing)해준다.

[그림: 서비스가 셀렉터를 통해 여러 파드를 가리키고, 안정적인 ClusterIP로 트래픽을 받아 분배하는 아키텍처]

클라이언트는 더 이상 파드의 탄생과 죽음에 신경 쓸 필요가 없다. 그들의 유일한 관심사는 `nginx-service`라는 변치 않는 존재뿐이다. 파드의 개수가 3개에서 10개로 늘어나든, 롤링 업데이트로 모든 파드의 IP가 바뀌든, 서비스가 그 모든 변화를 흡수하는 완충재 역할을 해주기 때문이다.

이로써 우리는 비로소 마이크로서비스 아키텍처의 기본 구성 단위를 완성했다. **디플로이먼트**가 애플리케이션의 **생존과 확장**을 책임지고, **서비스**가 애플리케이션의 **발견과 접근**을 책임진다. 이 둘의 조합을 통해 우리는 변화무쌍한 클라우드 환경 위에서도 흔들리지 않는 견고한 애플리케이션의 토대를 마련한 것이다.

하지만 좋은 아키텍처는 단순히 오브젝트를 조합하는 것만으로 완성되지 않는다. 우리는 이 파드라는 작은 공간 안에 애플리케이션을 '어떻게' 담아야 하는지에 대한 더 깊은 고민을 시작해야 한다. 다음 장에서는 클라우드 네이티브 환경에 걸맞은 애플리케이션을 설계하는 정석, 즉 12-Factor App 원칙의 현대적 해석부터 올바른 헬스 체크와 자원 관리 전략까지, 플랫폼의 안정성을 좌우하는 핵심적인 설계 패턴들을 탐구해 볼 것이다.