## 01. 컨트롤러 깊이 보기: 파드를 관리하는 보이지 않는 손

우리는 파드라는 견고하고 유연한 건축 자재를 손에 넣었다. 그렇다면 이제 `kubectl run my-app --image=nginx` 와 같은 명령어로 파드를 직접 하나하나 클러스터에 올리면 되는 것일까? 만약 당신이 그렇게 생각했다면, 당신은 쿠버네티스의 가장 중요한 원칙 중 하나를 위배하는 것이다. **절대로, 날 것 그대로의 파드(Naked Pod)를 직접 생성하고 관리하지 마라.**

왜냐하면 파드는 본질적으로 **일회용품(disposable)**이며 **덧없는 존재(ephemeral)**이기 때문이다. 파드가 실행 중인 노드에 장애가 발생하면 파드는 그대로 사라진다. 파드 내부의 프로세스가 에러를 일으켜 종료되면 파드는 다시 살아나지 않는다. 우리는 이렇게 연약한 존재를 직접 관리하며 밤새 안녕한지 지켜볼 여유가 없다. 우리의 목표는 개별 파드의 생존이 아니라, '우리의 애플리케이션이 안정적으로 실행되고 있는 상태' 그 자체이기 때문이다.

바로 이 지점에서 우리는 1장에서 만났던 제어 루프, 즉 **컨트롤러(Controller)**를 다시 소환해야만 한다. 컨트롤러는 우리가 직접 파드를 돌보는 수고를 대신해주는, 클러스터의 보이지 않는 손이다.

컨트롤러의 임무는 지극히 명확하다.

1.  **자신이 책임져야 할 API 오브젝트를 감시한다.** (예: 디플로이먼트)
2.  **그 오브젝트에 선언된 '이상적인 상태'를 읽는다.** (예: "NGINX 파드 3개가 필요함")
3.  **클러스터의 '현재 상태'를 관찰한다.** (예: "현재 NGINX 파드는 2개만 존재함")
4.  **두 상태의 차이를 인지하고, 그 차이를 메우기 위해 행동한다.** (예: "부족한 파드 1개를 생성하라")

당신은 컨트롤러에게 파드를 직접 생성하라고 명령하지 않는다. 당신은 그저 "이러이러한 명세를 가진 파드가 몇 개 있었으면 좋겠다"는 상위 레벨의 '의도'를 담은 오브젝트(예: 디플로이먼트, 레플리카셋)를 API 서버에 제출할 뿐이다. 그러면 해당 컨트롤러가 그 의도를 현실로 만들고, 한번 만들어진 현실이 외부 요인(노드 장애, 파드 삭제 등)에 의해 틀어지지 않도록 끊임없이 감시하고 복원하는 모든 책임을 진다.

[도표: 파드와 컨트롤러의 책임 분리]
| 주체 | 책임 (Responsibility) | 관심사 (Concern) |
| :--- | :--- | :--- |
| **당신 (사용자)** | **'무엇(What)'**을 원하는지 선언한다. (애플리케이션의 최종 상태) | 비즈니스 로직, 배포 정책, 확장성 요구사항 |
| **컨트롤러** | **'어떻게(How)'** 그 상태를 달성하고 유지할지를 실행한다. (파드의 생명주기 관리) | 파드 생성/삭제, 스케줄링 요청, 상태 모니터링, 자가 치유 |
| **파드** | 실제 워크로드를 실행하는 최소 단위. | 컨테이너 실행, 자원 공유 |

이러한 컨트롤러 기반의 아키텍처는 우리에게 다음과 같은 핵심적인 이점을 제공한다.

* **자가 치유(Self-healing):** 노드 장애로 파드가 사라지면, 컨트롤러가 이를 감지하고 즉시 다른 노드에 대체 파드를 생성한다.
* **스케일링(Scaling):** `replicas` 수를 3에서 10으로 변경하면, 컨트롤러가 알아서 7개의 파드를 추가로 생성한다.
* **롤링 업데이트(Rolling Update):** 애플리케이션의 버전을 업데이트하면, 컨트롤러는 구버전 파드를 하나씩 점진적으로 신버전 파드로 교체하여 무중단 배포를 수행한다.

쿠버네티스는 다양한 종류의 워크로드를 처리하기 위해 각기 다른 전략을 가진 전문화된 컨트롤러들을 제공한다. 상태가 없는(stateless) 웹 애플리케이션을 위한 **디플로이먼트(Deployment)**, 고유한 네트워크 식별자와 안정적인 스토리지를 필요로 하는 데이터베이스와 같은 상태 저장(stateful) 애플리케이션을 위한 **스테이트풀셋(StatefulSet)**, 클러스터의 모든 (또는 특정) 노드에 파드를 하나씩 배포해야 하는 로깅 에이전트나 모니터링 에이전트를 위한 **데몬셋(DaemonSet)** 등이 바로 그들이다.

이제 우리는 이 컨트롤러들 중 가장 기본적이고 널리 사용되는 디플로이먼트를 통해, 어떻게 애플리케이션의 배포와 회복탄력성을 위한 첫걸음을 뗄 수 있는지 구체적으로 살펴볼 것이다.