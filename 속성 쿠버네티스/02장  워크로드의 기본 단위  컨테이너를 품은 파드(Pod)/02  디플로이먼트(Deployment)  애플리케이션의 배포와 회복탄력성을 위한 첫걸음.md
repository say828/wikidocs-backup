## 02\. 디플로이먼트(Deployment): 애플리케이션의 배포와 회복탄력성을 위한 첫걸음

수많은 컨트롤러 중에서도 당신이 가장 먼저, 그리고 가장 빈번하게 마주하게 될 존재가 바로 \*\*디플로이먼트(Deployment)\*\*다. 디플로이먼트는 상태가 없는(stateless) 애플리케이션을 배포하고 관리하는 가장 표준적인 방법이며, 사실상 쿠버네티스에서 '애플리케이션을 실행한다'는 말의 동의어처럼 사용된다. 웹 서버, API 게이트웨이, 캐싱 레이어 등 외부의 요청을 받아 처리하고 그 결과를 돌려줄 뿐, 스스로 영속적인 데이터를 저장하지 않는 대부분의 마이크로서비스가 바로 이 디플로이먼트의 완벽한 대상이다.

디플로이먼트의 핵심적인 역할은 \*\*파드의 개수를 보장(ensuring desired replica count)\*\*하고, 애플리케이션의 \*\*업데이트를 통제(controlling updates)\*\*하는 것이다. 하지만 디플로이먼트가 이 모든 일을 직접 처리하는 것은 아니다. 여기서 우리는 쿠버네티스의 우아한 책임 위임 구조를 다시 한번 엿볼 수 있다.

실제로 파드의 개수를 감시하고 유지하는 임무는 디플로이먼트의 충직한 부하 직원인 **레플리카셋(ReplicaSet)** 컨트롤러가 담당한다. 당신이 디플로이먼트를 생성하면, 디플로이먼트 컨트롤러는 그 명세를 바탕으로 정확히 동일한 파드 템플릿을 가진 레플리카셋을 생성한다. 그리고 이 레플리카셋이야말로 우리가 앞에서 보았던 제어 루프를 돌며 실제 파드의 수를 맞추는 실무자다.

그렇다면 디플로이먼트는 왜 굳이 레플리카셋이라는 중간 관리자를 두는 것일까? 바로 \*\*'변경 이력(Revision History)'\*\*을 관리하고 이를 통해 \*\*'안전한 업데이트'\*\*를 수행하기 위함이다.

당신이 처음 `nginx:1.24` 이미지를 사용하는 디플로이먼트를 배포했다고 생각해보자.

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deployment
spec:
  replicas: 3
  selector:
    matchLabels:
      app: nginx
  template: #<-- 파드의 설계도
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx:1.24 #<-- 현재 버전 v1
```

1.  디플로이먼트 컨트롤러는 이 명세를 바탕으로 `nginx-deployment-<hash1>` 이라는 이름의 레플리카셋을 생성한다. 이 레플리카셋은 `nginx:1.24` 이미지를 사용하는 파드 3개를 생성하고 유지하는 임무를 부여받는다.

이제 당신이 이미지 버전을 `nginx:1.25`로 변경하여 디플로이먼트를 업데이트(`kubectl apply ...`)했다고 가정해보자.

2.  디플로이먼트 컨트롤러는 파드 템플릿(`spec.template`)이 변경된 것을 감지한다.
3.  컨트롤러는 기존 레플리카셋(`...-<hash1>`)의 `replicas`를 점진적으로 줄이는 동시에, `nginx:1.25`라는 새로운 파드 템플릿을 가진 두 번째 레플리카셋(`nginx-deployment-<hash2>`)을 생성하고 그 `replicas`를 점진적으로 늘리기 시작한다.
4.  이 과정은 기본적으로 구버전 파드 하나를 죽이고, 신버전 파드 하나가 완전히 준비(Ready)된 것을 확인한 후에 다음 파드를 교체하는 **롤링 업데이트(Rolling Update)** 방식으로 진행된다. 이 덕분에 업데이트 과정 중에도 서비스는 중단되지 않는다.
5.  모든 파드가 성공적으로 `nginx:1.25`로 교체되면, 구버전 레플리카셋(`...-<hash1>`)은 `replicas: 0`인 상태로 보존된다.

[그림: 롤링 업데이트 과정에서 두 개의 레플리카셋이 파드를 교체하는 모습]

이것이 바로 디플로이먼트의 진가다. 만약 새로운 버전 `nginx:1.25`에 심각한 버그가 있어 롤백(rollback)해야 한다면 어떻게 할까? 당신은 그저 `kubectl rollout undo deployment/nginx-deployment`라는 간단한 명령을 내리면 된다. 그러면 디플로이먼트 컨트롤러는 새로운 레플리카셋(`...-<hash2>`)의 `replicas`를 0으로 만들고, 이전에 보존해두었던 구버전 레플리카셋(`...-<hash1>`)의 `replicas`를 다시 3으로 복원하여 순식간에 이전 상태로 되돌려준다.

이처럼 디플로이먼트는 레플리카셋이라는 메커니즘을 활용하여 단순히 파드의 개수를 유지하는 것을 넘어, 애플리케이션의 **선언적 업데이트**와 **변경 이력 관리**라는 한 차원 높은 수준의 추상화를 제공한다. 당신은 "A를 B로 바꿔라"는 절차를 명령하는 대신, 그저 "이제부터 애플리케이션의 이상적인 상태는 B다"라고 선언하기만 하면 된다. 그 상태로 가는 가장 안전하고 검증된 길을 찾아내는 것은 디플로이먼트 컨트롤러의 몫이다.

이제 우리는 안정적으로 실행되고 스스로 치유하며, 심지어는 안전하게 업데이트될 수 있는 애플리케이션의 묶음을 손에 넣었다. 하지만 이 파드들은 여전히 클러스터라는 고립된 섬 안에 갇혀 있다. 이 변화무쌍한 파드들을 외부 세계, 그리고 클러스터 내의 다른 서비스들과 어떻게 안정적으로 연결할 수 있을까? 다음 절에서는 이 문제를 해결하기 위한 열쇠, 바로 서비스(Service)에 대해 알아볼 것이다.