## 02\. Karpenter를 활용한 지능적인 노드 오토스케일링 아키텍처

우리는 이제 OpenCost와 같은 도구를 통해 비용의 안개를 걷어내고, 어떤 워크로드가 얼마의 비용을 발생시키는지 명확히 볼 수 있게 되었다. 하지만 가시성은 문제 해결의 시작일 뿐, 그 자체로 비용을 줄여주지는 않는다. 우리가 발견한 가장 큰 낭비는 아마도 이것일 것이다: 피크 타임의 부하를 감당하기 위해 항상 필요 이상으로 거대한 노드들을 띄워놓는 **과잉 프로비저닝(Over-provisioning)**.

이 문제를 해결하기 위해 쿠버네티스 생태계는 오랫동안 **Cluster Autoscaler**라는 도구를 사용해왔다. Cluster Autoscaler는 스케줄링 대기 중(`Pending`)인 파드가 있고, 클러스터에 더 이상 자원이 없을 때, 미리 정의된 **노드 그룹(Node Group)** 또는 \*\*오토 스케일링 그룹(Auto Scaling Group, ASG)\*\*의 노드 수를 늘려주는 역할을 한다.

하지만 이 전통적인 방식은 근본적인 한계를 가진다. Cluster Autoscaler는 마치 **정해진 노선만 다니는 버스 시스템**과 같다.

  * **경직성:** 우리는 미리 `m5.large` 인스턴스로 구성된 노드 그룹, `g4dn.xlarge` 인스턴스로 구성된 GPU 노드 그룹처럼, 몇 가지 정해진 '버스 노선'을 만들어 두어야 한다. Cluster Autoscaler는 오직 이 정해진 종류의 버스(노드)만을 부를 수 있다.
  * **비효율성:** 아주 작은 CPU를 필요로 하는 파드 하나 때문에, 거대한 `m5.large` 노드 전체가 새로 프로비저닝될 수 있다. 이는 엄청난 자원 낭비다.
  * **느린 속도:** ASG를 통해 노드가 추가되고 클러스터에 조인하기까지는 수 분이 소요될 수 있다. 이는 급격한 트래픽 증가에 민첩하게 대응하기 어렵게 만든다.

이 낡은 버스 시스템에 대한 AWS의 혁신적인 대답이 바로 **Karpenter**다. Karpenter는 Cluster Autoscaler를 대체하기 위해 만들어진, 완전히 새로운 패러다임의 오픈소스 오토스케일러다. Karpenter는 버스 시스템이 아니라, **승객에게 최적화된 온디맨드 택시 호출 시스템**과 같다. 🚕

Karpenter는 노드 그룹이나 ASG라는 개념 자체를 완전히 버린다. 대신, 다음과 같이 작동한다.

1.  Karpenter 컨트롤러는 스케줄링 대기 중인 파드를 직접 감시한다.
2.  `Pending` 상태의 파드를 발견하면, 그 파드가 요구하는 자원(`requests`), 노드 어피니티(affinity), 톨러레이션(toleration)과 같은 모든 제약 조건을 즉시 읽는다.
3.  이 제약 조건을 만족하는 **수백 가지 EC2 인스턴스 타입 중에서, 현재 시점에 가장 저렴하고 가장 적합한 인스턴스 타입을 실시간으로 계산**한다.
4.  그리고 ASG를 거치지 않고, EC2 Fleet API를 통해 해당 인스턴스를 **직접, 그리고 즉시** 프로비저닝하여 클러스터에 등록시킨다.

이 모든 지시는 \*\*`Provisioner`\*\*라는 이름의 CRD를 통해 선언적으로 이루어진다.

```yaml
apiVersion: karpenter.sh/v1alpha5
kind: Provisioner
metadata:
  name: default
spec:
  requirements: # 1. 이 프로비저너가 만들 수 있는 노드의 제약 조건
    - key: karpenter.sh/capacity-type
      operator: In
      values: ["spot", "on-demand"] # 스팟과 온디맨드 인스턴스를 모두 사용
    - key: "node.kubernetes.io/instance-type"
      operator: In
      values: ["m5.large", "m5.2xlarge", "c5.large", "r5.large"] # 허용된 타입 목록
  limits: # 2. 이 프로비저너가 관리하는 총 자원 상한선
    resources:
      cpu: "1000"
  providerRef: # 3. AWS 관련 설정 참조
    name: default
  ttlSecondsAfterEmpty: 30 # 4. 노드가 30초 동안 비어있으면 자동으로 제거
```

Karpenter는 단순히 노드를 추가하는 것에서 그치지 않는다. 주기적으로 클러스터 전체의 파드 배치를 검토하여, 여러 노드에 흩어져 있는 파드들을 더 적은 수의 큰 노드로 통합(consolidate)하고 빈 노드를 제거하는 **디프로비저닝(Deprovisioning)** 작업도 수행한다. 이는 시간이 지남에 따라 발생하는 자원 파편화를 해결하고 클러스터를 항상 최적의 상태로 유지하는 강력한 기능이다.

Karpenter를 도입함으로써, 우리는 더 이상 수십 개의 노드 그룹을 관리하는 복잡성에서 벗어날 수 있다. 플랫폼은 애플리케이션의 실제 요구사항에 맞춰, 마치 살아있는 생물처럼 스스로의 형태를 실시간으로 최적화하기 시작한다. 이는 비용을 절감하고, 스케일링 속도를 비약적으로 향상시키며, 플랫폼 팀의 운영 부담을 극적으로 줄여주는 진정한 게임 체인저다.

이제 우리는 비용을 보고, 지능적으로 제어할 수 있는 기술적 무기를 모두 갖추었다. 하지만 최고의 도구도 그것을 사용하는 문화가 뒷받침되지 않으면 무용지물이다. 다음 절에서는 이 모든 기술을 조직의 DNA에 심는 문화적 혁신, FinOps에 대해 알아볼 것이다.