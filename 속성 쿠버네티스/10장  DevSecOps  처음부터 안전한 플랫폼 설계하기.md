# 10장: DevSecOps: 처음부터 안전한 플랫폼 설계하기

우리는 지금까지 클러스터의 내부 교통망을 정비하고, 외부 세계와의 관문을 굳건히 세웠다. 네트워크 정책과 암호화된 통신은 우리 제국을 외부의 침략으로부터 보호하는 높은 성벽과도 같다. 하지만 역사상 가장 강력했던 요새들도 종종 내부의 배신자나 허가증을 위조한 암살자에 의해 무너졌다는 사실을 잊어서는 안 된다. 진정한 보안은 성벽을 높이 쌓는 것에서 끝나지 않는다. 그것은 성문 안으로 들어온 모든 이들의 **신원을 확인(Authentication)**하고, 그들이 **무엇을 할 수 있는지(Authorization)**를 통제하며, 그들의 행동이 성의 법률에 위배되지 않는지를 **검증(Admission Control)**하는, 훨씬 더 깊고 내밀한 통치 체계에서 완성된다. 🏛️

DevOps의 시대는 우리에게 속도를 선물했지만, 종종 보안은 그 속도의 희생양이 되었다. **DevSecOps**는 이러한 잘못된 관행에 대한 반성이자, 보안을 개발 파이프라인의 가장 마지막 단계에 덧붙이는 '사후약방문'이 아니라, 애플리케이션의 기획 단계부터 코드 한 줄을 작성하는 순간, 그리고 인프라를 구성하는 모든 과정에 내재화해야 한다는 근본적인 문화적 전환을 요구한다. 보안은 더 이상 보안팀만의 책임이 아니라, 플랫폼을 만드는 우리 모두의 책임이다.

이 장에서는 쿠버네티스라는 운영체제의 가장 깊은 곳, 즉 **API 서버**라는 중앙 권력 기관이 어떻게 보안을 강제하는지를 파헤칠 것이다. 우리는 쿠버네티스 보안의 세 기둥인 **인증, 인가, 그리고 어드미션 컨트롤**의 관계를 명확히 이해하고, 가장 골치 아픈 문제 중 하나인 **RBAC의 복잡성**을 길들이는 실전 설계 패턴을 익힐 것이다. 나아가, 파드 자체의 보안을 강화하는 **파드 보안 표준(Pod Security Standards)**을 적용하고, 마지막으로 **이미지 스캐닝**과 **정책 엔진(Kyverno/OPA)**을 통해 우리의 소프트웨어 공급망 전체를 악의적인 위협으로부터 보호하는 자동화된 방어선을 구축할 것이다.

---

## 00. 인증, 인가 그리고 어드미션 컨트롤: 쿠버네티스 보안의 세 기둥

9장에서 보았듯, 쿠버네티스의 모든 것은 API 서버를 통해 이루어진다. `kubectl`이든, Argo CD 컨트롤러든, Kubelet이든, 클러스터의 상태를 변경하려는 모든 행위는 결국 API 서버로 향하는 하나의 API 요청일 뿐이다. 따라서 API 서버는 우리 클러스터의 모든 것을 지키는 **궁극의 게이트키퍼(Gatekeeper)**다.

이 게이트키퍼는 모든 요청을 마주할 때마다, 다음과 같은 세 가지 질문을 순서대로, 그리고 아주 엄격하게 던진다. 이 세 단계를 통과하지 못하는 요청은 그 내용이 아무리 타당하더라도 가차 없이 거부된다.

1.  **인증 (Authentication): "당신은 누구인가?"**
    이것은 요청자의 신원을 확인하는 첫 번째 관문이다. API 서버는 요청을 보낸 주체가 정말로 자신이 주장하는 그 사람이 맞는지 증명할 것을 요구한다. 쿠버네티스는 다양한 인증 전략을 지원한다.
    * **사용자 계정 (Normal Users):** 클러스터 외부의 인간 사용자를 위한 계정이다. 이는 쿠버네티스가 직접 관리하지 않으며, 보통 X.509 클라이언트 인증서나 OIDC(OpenID Connect)와 같은 외부 ID 공급자와의 연동을 통해 관리된다.
    * **서비스 어카운트 (Service Accounts):** 클러스터 **내부의** 프로세스(파드)를 위한 계정이다. `kubectl create serviceaccount`를 통해 쿠버네티스 API가 직접 관리하며, 파드가 API 서버와 통신할 때 사용하는 JWT(JSON Web Token) 토큰을 제공한다. Argo CD 컨트롤러나 cert-manager가 API 서버와 통신하는 것이 바로 이 서비스 어카운트를 통해서다.

    인증 단계는 오직 "이 요청은 'alice'라는 사용자가 보낸 것이 맞다" 또는 "이 요청은 'prod' 네임스페이스의 'argocd-repo-server' 서비스 어카운트가 보낸 것이다"까지만 확인해줄 뿐, 그들이 무엇을 할 수 있는지는 전혀 신경 쓰지 않는다.

2.  **인가 (Authorization): "당신은 이 행동을 할 권한이 있는가?"**
    신원이 확인되면, 게이트키퍼는 두 번째 질문을 던진다. "'alice' 당신, `prod` 네임스페이스의 파드를 조회(get)할 권한이 있는가?" 이것이 바로 인가 단계다. 쿠버네티스는 다양한 인가 모듈을 지원하지만, 오늘날 사실상의 표준은 **RBAC(Role-Based Access Control)** 이다. RBAC는 '누가(Subject) 어떤 리소스(Resource)에 대해 어떤 행위(Verb)를 할 수 있는지'를 **Role**과 **RoleBinding**이라는 두 개의 오브젝트를 통해 선언적으로 정의한다. 이에 대해서는 다음 절에서 깊이 있게 다룰 것이다.
    
    만약 RBAC 규칙에 따라 해당 요청이 허가된다면, 요청은 다음 단계로 넘어갈 준비가 된 것이다.

3.  **어드미션 컨트롤 (Admission Control): "이 행동이 허가되었더라도, 정말로 실행해도 되는가?"**
    이것이 바로 최후의 방어선이자, 쿠버네티스 보안의 유연성을 극대화하는 비밀 병기다. 인증과 인가를 모두 통과한 요청이라 할지라도, 어드미션 컨트롤러는 그 요청의 **'내용'**을 검사하여 클러스터 전체의 정책이나 모범 사례에 부합하는지를 마지막으로 검증한다. 쿠버네티스는 수십 개의 내장 어드미션 컨트롤러를 가지고 있으며, 우리는 웹훅(Webhook)을 통해 우리만의 커스텀 정책을 추가할 수도 있다.
    * **`ValidatingAdmissionWebhook`:** 요청의 내용을 검증하여, 정책에 위배되면 요청 자체를 **거부(reject)**한다. 예를 들면, "모든 파드는 반드시 `owner` 레이블을 가져야 한다"거나, "`latest` 태그를 사용하는 이미지는 프로덕션 네임스페이스에 배포할 수 없다"와 같은 규칙을 강제할 수 있다.
    * **`MutatingAdmissionWebhook`:** 요청의 내용을 검증할 뿐만 아니라, 정책에 따라 그 내용을 **수정(mutate)**하여 API 서버로 전달한다. 예를 들어, 어떤 파드가 생성되든 상관없이 항상 특정 로깅 사이드카 컨테이너를 자동으로 주입하거나, 모든 파드에 특정 보안 관련 어노테이션을 강제로 추가하는 등의 마법을 부릴 수 있다.



이 세 기둥—인증, 인가, 어드미션 컨트롤—은 서로 긴밀하게 연동되어, 외부로부터의 위협과 내부의 실수를 모두 막아내는 다층 방어 체계를 구축한다.

이제 우리는 이 방어 체계의 가장 핵심적인 부분이자, 가장 관리하기 까다로운 영역인 RBAC의 복잡성을 길들이는 여정을 시작할 것이다.