## 01\. 잘 만든 컨테이너 이미지, 그 이상의 것: 멀티스테이지 빌드와 최적화

애플리케이션을 컨테이너에 담는다는 것은, 단순히 코드를 압축해서 파일 하나로 만드는 행위가 아니다. **컨테이너 이미지는 당신의 워크로드가 가진 유전자 정보다.** 이 이미지가 어떻게 만들어졌느냐에 따라 당신의 애플리케이션의 보안 수준, 배포 속도, 운영 비용, 그리고 안정성까지 모든 것이 결정된다. 부실하게 만들어진 이미지는 클러스터 전체를 병들게 하는 만병의 근원이 될 수 있다.

많은 초심자들이 저지르는 가장 흔한 실수는, 개발 환경의 편의성을 그대로 프로덕션 이미지에 옮겨오는 것이다. 예를 들어, `ubuntu:latest`와 같은 거대한 범용 운영체제 이미지를 기반으로 시작한다. 그 위에 `maven`이나 `npm`과 같은 빌드 도구를 설치하고, 소스 코드를 복사한 뒤, 이미지 안에서 애플리케이션을 빌드하고, 그 결과물을 그대로 담아 배포한다.

이것은 끔찍한 안티패턴이다. 왜냐하면 당신은 지금, 자동차를 배달하는데 그 자동차를 조립했던 거대한 공장 설비 전체를 함께 포장해서 보내는 것과 같은 짓을 하고 있기 때문이다.

  * **보안의 재앙:** 최종 실행 파일(.jar, Go 바이너리 등)을 실행하는 데 전혀 필요 없는 컴파일러(`gcc`), 빌드 도구(`maven`), 소스 코드, 심지어는 `curl`이나 `bash` 같은 셸 유틸리티까지 프로덕션 환경에 그대로 노출된다. 이 도구들 중 단 하나에서라도 보안 취약점이 발견되면, 당신의 프로덕션 컨테이너는 공격자에게 활짝 열린 대문이 된다.
  * **성능 저하와 비용 낭비:** 수백 MB, 심지어 GB에 달하는 거대한 이미지는 레지스트리에서 노드로 다운로드하는 데 오랜 시간이 걸린다. 이는 파드의 시작 시간을 지연시키고, 긴급한 트래픽 증가에 대응하기 위한 오토스케일링 속도를 저해한다. 또한, 불필요하게 비싼 레지스트리 저장 비용과 네트워크 대역폭 비용을 지불하게 만든다.

이 문제를 해결하는 가장 우아하고 표준적인 해법이 바로 \*\*멀티스테이지 빌드(Multi-stage builds)\*\*다. 이름 그대로, `Dockerfile` 안에서 빌드 과정을 여러 단계로 나누는 기술이다.

1.  **빌드 스테이지(Build Stage):** 첫 번째 단계에서는 `golang`이나 `maven`처럼 모든 SDK와 빌드 도구가 포함된 무거운 이미지를 사용한다. 여기서는 소스 코드를 컴파일하고, 의존성을 다운로드하며, 최종적으로 실행 가능한 단일 아티팩트를 만들어내는 데만 집중한다. 이곳이 바로 자동차를 조립하는 '공장'이다.
2.  **런타임 스테이지(Runtime Stage):** 두 번째 단계에서는 `alpine`이나 `distroless`처럼 극도로 가볍고 최소한의 구성 요소만 담긴 베이스 이미지에서 새로 시작한다. 그리고 **`COPY --from=builder`** 라는 마법과 같은 명령어를 사용해, 첫 번째 '공장' 스테이지에서 만들어진 **최종 결과물(자동차)만을** 가져온다.

Go 언어로 작성된 간단한 웹서버를 위한 `Dockerfile`을 통해 이 개념을 구체적으로 살펴보자.

```dockerfile
# ----- 스테이지 1: 빌드 환경 (The "Factory") -----
# Go SDK가 포함된 공식 이미지를 빌더로 지정
FROM golang:1.21-alpine AS builder

# 작업 디렉토리 설정
WORKDIR /app

# Go 모듈 의존성 캐싱을 위해 먼저 복사 및 다운로드
COPY go.mod ./
COPY go.sum ./
RUN go mod download

# 전체 소스 코드 복사
COPY . .

# 애플리케이션 빌드. CGO_ENABLED=0은 정적 바이너리를 만들기 위함.
RUN CGO_ENABLED=0 GOOS=linux go build -o /app/main .

# ----- 스테이지 2: 런타임 환경 (The "Car") -----
# 운영체제 라이브러리조차 거의 없는 극소의 'distroless' 이미지 사용
FROM gcr.io/distroless/static-debian11

# 빌더 스테이지에서 컴파일된 최종 실행 파일만 복사
COPY --from=builder /app/main /

# 컨테이너가 시작될 때 실행할 명령어
ENTRYPOINT ["/main"]
```

이 `Dockerfile`로 이미지를 빌드하면 최종 결과물에는 Go 컴파일러도, 소스 코드도, 심지어는 셸(`bash`)조차도 존재하지 않는다. 오직 실행에 필요한 최소한의 라이브러리와 당신이 만든 `main`이라는 바이너리 파일 단 하나만이 담겨있을 뿐이다. 이는 이미지 크기를 수십 배 줄여줄 뿐만 아니라, 공격자가 컨테이너 내부에 침투하더라도 사용할 수 있는 도구가 거의 없어 공격의 반경을 극적으로 제한하는 강력한 보안 장치가 된다.

잘 만든 컨테이너 이미지는 그 자체로 훌륭한 문서이자, 당신의 애플리케이션을 위한 가장 견고한 갑옷이다. 이제 우리는 이 갑옷을 입은 애플리케이션이 스스로 "나는 건강합니다" 혹은 "나는 지금 아픕니다"라고 쿠버네티스에게 정확하게 신호를 보낼 수 있도록 만드는 방법을 배워야 한다.