## 02\. 죽은 컨테이너와 아픈 컨테이너: Liveness, Readiness 프로브의 올바른 설계

우리는 이제 멀티스테이지 빌드를 통해 군더더기 없이 단단하고 안전한 컨테이너 이미지를 만드는 법을 알게 되었다. 하지만 이 완벽해 보이는 갑옷 안에서, 애플리케이션은 여전히 병들 수 있다. 쿠버네티스는 컨테이너의 메인 프로세스가 `PID 1`로 실행 중인지 아닌지는 감시할 수 있다. 만약 프로세스가 예기치 않게 종료된다면, 쿠버네티스는 이를 '죽었다'고 판단하고 파드를 재시작할 것이다.

하지만 그것이 과연 '건강하다'는 의미와 동일할까? 천만에. 애플리케이션은 프로세스는 멀쩡히 살아있지만, 내부적으로는 완전히 멈춰버린 \*\*'좀비 상태'\*\*에 빠질 수 있다. 데이터베이스 커넥션 풀이 모두 고갈되어 더 이상 쿼리를 날릴 수 없거나, 내부의 스레드가 데드락(deadlock)에 걸려 아무런 작업도 처리하지 못하는 상태를 생각해보라. 겉으로 보기엔 살아있지만, 실질적으로는 죽은 것과 다름없다. 혹은, 애플리케이션이 시작은 되었지만, 초기 데이터를 로딩하거나 외부 서비스와의 연결을 설정하느라 아직 요청을 받을 **'준비가 되지 않은'** 상태일 수도 있다.

쿠버네티스는 컨테이너 내부의 사정을 들여다볼 수 있는 천리안을 가지고 있지 않다. 우리가 애플리케이션의 건강 상태를 진단할 수 있는 청진기를 컨테이너 내부에 꽂아주지 않는 한, 쿠버네티스는 아픈 컨테이너에게 계속해서 트래픽을 보내는 어리석은 의사처럼 행동할 것이다. 이 청진기 역할을 하는 것이 바로 \*\*헬스 체크 프로브(Health Check Probe)\*\*다. 쿠버네티스는 크게 두 종류의 프로브를 제공하며, 이 둘의 목적과 결과를 명확히 구분하는 것이 플랫폼 안정성의 핵심이다. 이 둘을 혼동하는 것은 재앙적인 결과를 낳을 수 있다.

-----

### Liveness Probe (생존 프로브): "당신, 정말 살아있습니까?"

**Liveness Probe**는 "이 컨테이너가 회복 불가능한 상태에 빠졌는가?"를 판단하기 위한 최후의 질문이다. 이 프로브의 목적은 위에서 언급한 데드락과 같은 '좀비' 상태를 감지해내는 것이다. 쿠버네티스는 주기적으로 이 프로브를 실행하여 컨테이너의 생존 여부를 확인한다. 만약 Liveness Probe가 설정된 횟수만큼 연속으로 실패하면, 쿠버네티스는 이 컨테이너가 더 이상 가망이 없다고 판단하고 가차 없이 \*\*컨테이너를 재시작(restart)\*\*시킨다.

이것은 매우 강력하지만 위험한 **자가 치유(self-healing)** 메커니즘이다. 재시작이 문제를 해결할 수 있는 경우(예: 일시적인 메모리 누수로 인한 교착 상태)에는 효과적이지만, 만약 프로브의 실패 원인이 외부 서비스의 일시적인 장애 때문이라면 어떻게 될까? 의존하는 데이터베이스가 잠시 느려졌을 뿐인데, 애플리케이션 전체가 끊임없이 재시작의 굴레에 빠지는 **CrashLoopBackOff** 상태를 유발할 수 있다. 따라서 Liveness Probe는 정말로 재시작 외에는 답이 없는, 내부적인 문제 상황을 감지하는 데 신중하게 사용되어야 한다.

### Readiness Probe (준비성 프로브): "이제 일할 준비가 되었습니까?"

**Readiness Probe**는 "이 컨테이너가 지금 당장 트래픽을 받을 준비가 되었는가?"를 묻는, 훨씬 더 온건하고 일상적인 질문이다. 이 프로브는 컨테이너가 살아있는지(alive)와는 별개로, 현재 정상적으로 서비스를 제공할 수 있는 상태인지(ready)를 확인한다. Readiness Probe가 실패하면, 쿠버네티스는 컨테이너를 죽이는 대신, 이 파드를 **서비스(Service)의 엔드포인트 목록에서 일시적으로 제외**한다.

이는 다음과 같은 상황에서 매우 유용하다.

  * **느린 초기화:** 애플리케이션이 시작될 때 대용량의 캐시를 메모리에 올리거나, 외부 설정 서버로부터 설정을 받아오는 데 수십 초가 걸릴 수 있다. 이 시간 동안 Readiness Probe는 실패 상태를 반환하여, 애플리케이션이 완전히 준비될 때까지 트래픽이 들어오지 않도록 보호한다.
  * **과부하 상태:** 애플리케이션이 처리 용량을 초과하는 요청을 받아 일시적으로 과부하 상태일 때, 스스로 Readiness Probe를 실패시켜 더 이상의 요청을 받지 않고 현재 작업을 처리하는 데 집중할 수 있다.
  * **롤링 업데이트:** 새로운 버전의 파드가 배포될 때, Readiness Probe가 성공하기 전까지는 구버전 파드로 가던 트래픽이 넘어오지 않는다. 이를 통해 신버전이 완전히 준비된 것이 확인된 후에만 트래픽이 전환되도록 보장할 수 있다.

### 프로브의 구현과 설계

쿠버네티스는 세 가지 방식으로 프로브를 실행할 수 있다.

  * `httpGet`: `/healthz`나 `/ready`와 같은 특정 HTTP 엔드포인트를 호출한다. 200\~399 사이의 응답 코드가 오면 성공이다.
  * `tcpSocket`: 특정 TCP 포트로 연결을 시도한다. 연결에 성공하면 성공이다.
  * `exec`: 컨테이너 내에서 특정 스크립트나 명령어를 실행한다. 종료 코드(exit code)가 0이면 성공이다.

다음은 두 프로브를 모두 적용한 디플로이먼트의 예시다.

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-app-deployment
spec:
  replicas: 3
  template:
    spec:
      containers:
      - name: my-app
        image: my-app:1.0.0
        ports:
        - containerPort: 8080
        
        # Liveness Probe: 30초 후부터 10초마다 체크. 3번 실패 시 재시작.
        livenessProbe:
          httpGet:
            path: /healthz
            port: 8080
          initialDelaySeconds: 30 # 앱이 시작할 시간을 충분히 준다.
          periodSeconds: 10
          failureThreshold: 3
          
        # Readiness Probe: 5초 후부터 5초마다 체크. 
        readinessProbe:
          httpGet:
            path: /readyz
            port: 8080
          initialDelaySeconds: 5
          periodSeconds: 5
```

Liveness와 Readiness 프로브는 쿠버네티스에게 당신의 애플리케이션과 대화하는 법을 가르쳐주는 것이다. 이 섬세한 신호 체계를 올바르게 설계하는 것은, 플랫폼의 자동화된 능력을 100% 활용하여 진정한 회복탄력성을 달성하기 위한 필수 불가결한 과제다.

이제 애플리케이션이 자신의 건강 상태를 알릴 수 있게 되었으니, 다음으로는 클러스터라는 공동체 안에서 다른 이웃들에게 피해를 주지 않고 약속된 만큼의 자원만 사용하는 예의범절, 즉 자원 요청과 제한에 대해 알아볼 차례다.