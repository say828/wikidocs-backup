## 02. mTLS를 통한 서비스 간 통신 암호화 자동화

우리는 이제 서비스 메시의 두뇌, 즉 컨트롤 플레인을 선택할 수 있는 지혜를 얻었다. 하지만 어떤 두뇌를 선택하든, 서비스 메시가 우리에게 제공하는 가장 즉각적이고, 가장 근본적인 가치는 바로 **보안**이다. 8장에서 배운 네트워크 정책은 훌륭한 L3/L4 방화벽이지만, 그것은 마치 국경에서 통행증의 '출발지'와 '목적지'만을 확인하는 것과 같다. 하지만 그 통행증을 가진 사람이 정말로 우리가 신뢰하는 그 사람이 맞는지, 그리고 그가 국경을 넘어와 나누는 대화가 도청당하지 않을 것이라고 어떻게 보장할 수 있는가?

이것이 바로 **상호 TLS(Mutual TLS, mTLS)**가 해결하는 문제다. 우리가 웹사이트에 접속할 때 사용하는 일반적인 TLS(HTTPS)는 서버만이 자신의 신원(인증서)을 클라이언트에게 증명하는 단방향 인증이다. 반면, mTLS는 서버뿐만 아니라 **클라이언트 역시 자신의 신원을 서버에게 암호학적으로 증명**하는 양방향 인증 방식이다. 이것은 마치 두 명의 첩보원이 서로를 확인하기 위해 각자 암호의 절반씩을 대보는 것과 같다. 양쪽 모두가 올바른 암호를 대어야만 비로소 비밀 대화가 시작된다.

수천 개의 마이크로서비스를 위해 이 모든 인증서를 수동으로 발급하고, 교체하며, 관리하는 것은 인간에게는 불가능한 임무다. 바로 이 지점에서 서비스 메시의 컨트롤 플레인은 **클러스터 내부의 자동화된 인증 기관(Certificate Authority, CA)**으로 변신한다.

이 자동화된 보안 체계는 다음과 같이 작동한다.

1.  **신원 증명 및 인증서 발급:** 파드가 시작될 때, 파드에 주입된 사이드카 프록시는 자신의 쿠버네티스 서비스 어카운트(Service Account) 토큰을 들고 서비스 메시의 컨트롤 플레인(예: Istiod, Linkerd Controller)에 찾아간다. 컨트롤 플레인은 이 토큰을 검증하여 파드의 신원을 확인한 뒤, 그 신원 정보(예: `spiffee://my-cluster/ns/prod/sa/frontend` 와 같은 **SPIFFE** ID)가 담긴 단기(short-lived) X.509 인증서를 발급해준다.

2.  **상호 핸드셰이크:** 이제 `frontend`의 사이드카 프록시가 `backend`의 사이드카 프록시에게 통신을 시도한다.
    * `frontend` 프록시는 `backend` 프록시에게 자신의 인증서를 제시한다.
    * `backend` 프록시는 이 인증서가 신뢰할 수 있는 내부 CA(컨트롤 플레인)에 의해 발급되었는지 확인한다.
    * 동시에, `backend` 프록시 역시 `frontend` 프록시에게 자신의 인증서를 제시하고, `frontend` 프록시도 똑같은 검증 과정을 거친다.

3.  **암호화된 터널 생성:** 이 상호 인증 과정이 성공적으로 끝나면, 두 프록시 사이에는 암호화된 TLS 터널이 생성된다. 이제 `frontend`와 `backend` 애플리케이션이 주고받는 모든 평문 트래픽은 이 안전한 터널을 통해서만 흐르게 된다.



이 모든 과정은 애플리케이션에게는 **완벽하게 투명하다.** 개발자는 자신의 코드에 TLS 라이브러리를 추가하거나 인증서를 관리하는 로직을 단 한 줄도 작성할 필요가 없다. 서비스 메시는 제로 트러스트 보안을 코드 변경 없이, 플랫폼 수준에서, 자동으로 강제한다.

이제 우리의 제국 안에서는 오직 신원이 확인된 자들만이, 아무도 엿들을 수 없는 비밀 통로를 통해서만 대화할 수 있게 되었다. 이 견고한 보안 기반 위에서, 우리는 이제 서비스 메시의 또 다른 강력한 능력, 즉 트래픽의 흐름 자체를 예술의 경지로 제어하는 고급 트래픽 관리의 세계로 나아갈 준비를 마쳤다.